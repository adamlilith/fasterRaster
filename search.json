[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team adam.smith@mobot.org. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available https://www.contributor-covenant.org/version/1/4/code--conduct.html answers common questions code conduct, see https://www.contributor-covenant.org/faq","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Adam B. Smith. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith (2024). fasterRaster: Faster Raster Spatial Vector Processing Using 'GRASS GIS'. doi:NA, R package version 8.3.0.7024.","code":"@Manual{R-fasterRaster,   title = {fasterRaster: Faster Raster and Spatial Vector Processing Using 'GRASS GIS'},   author = {Adam B. Smith},   year = {2024},   note = {R package version 8.3.0.7024},   doi = {NA}, }"},{"path":"/index.html","id":"fasterraster","dir":"","previous_headings":"","what":"Faster Raster and Spatial Vector Processing Using GRASS GIS","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"Faster raster processing R using GRASS GIS  fasterRaster package designed specifically handle large--memory/large--disk spatial rasters vectors. fasterRaster using Open Source Geospatial’s GRASS GIS fasterRaster created five design principles: Value added: fasterRaster complements terra sf, highly dependent ! useful analyzing large--memory/large--disk rasters vectors packages struggle handle. medium- small-size objects, terra sf almost always faster. Familiarity: know use terra, basically know use fasterRaster! ’s functions name almost arguments terra functions. Comparability: degree possible, outputs fasterRaster functions terra name. Simplicity: GRASS requires users track things like “locations”, “mapsets”, “regions” comparable analog terra sf packages. fasterRaster handles behind scenes don’t need . ’s R: rgrass package provides powerful conduit can run GRASS modules R. , provides much flexibility fasterRaster. However, use rgrass, need know GRASS modules need familiar GRASS syntax. fasterRaster obviates step uses rgrass backend, allowing focus R syntax look help functions normal way R. don’t need know GRASS! fasterRaster makes heavy use rgrass package Roger Bivand others, terra package Robert Hijmans, sf package Edzer Pebesma Roger Bivand, course GRASS GIS, greatly indebted creators!","code":""},{"path":"/index.html","id":"where-we-are","dir":"","previous_headings":"","what":"Where we are","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"2024/09/15, new version package, fasterRaster 8.3, alpha release (.e., near final release). known issues unknown issues. encounter one latter, please file issue report. Special announcement: new bioclims() function creates “classic” set BIOCLIM variables, plus optional “extended” set. function works fasterRaster GRasters terra SpatRasters!","code":""},{"path":"/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"see detailed list functions available fasterRaster, attach package use ?fasterRaster. Note additional tutorials linked !","code":""},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"install fasterRaster, please use: remotes::install_github('adamlilith/fasterRaster', dependencies = TRUE) Alternatively, can install development version : remotes::install_github('adamlilith/fasterRaster@intuitive_fasterRaster', dependencies = TRUE) use fasterRaster must install GRASS version 8+ operating system. need use stand-alone installer, Open Source Geospatial (OS Geo) installer.","code":""},{"path":"/index.html","id":"an-example","dir":"","previous_headings":"","what":"An example","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"’ll simple operation : Add buffer lines representing rivers, Calculate distance cell closest buffer burn distance values raster. , ’ll using maps representing middle eastern coast Madagascar. also use terra sf packages.  use nearly function package, need tell fasterRaster GRASS installed system. installation folder vary operating system maybe GRASS version, look something like : Now, use faster() function tell fasterRaster GRASS installed: fast() function key function loading raster vector fasterRaster format. Rasters package called GRasters vectors GVectors (“G” stands GRASS). now convert madElev raster, SpatRaster terra package, GRaster. see metadata GRaster: Next, ’ll rivers vector. case, vector sf object sf package, also use SpatVector terra package. Now, let’s add 1000-m buffer rivers using buffer(). much possible, fasterRaster functions names arguments counterparts terra package help users familiar package. Note, though, output fasterRaster necessarily guaranteed output respective functions terra. different methods thing, developers GRASS may chosen different methods developers GIS packages. Now, let’s calculate distances buffered areas cells raster map using distance(). Finally, let’s plot output.  ’s ’s done! can almost anything fasterRaster can terra. examples show advantage fasterRaster use large--memory/large--disk spatial datasets. large datasets, fasterRaster can much faster! example, large raster (many cells), distance() function terra can take many days run even crash R, whereas fasterRaster, take just minutes hours.","code":"library(terra) library(sf) library(fasterRaster)  # Get example elevation raster and rivers vector: madElev <- fastData('madElev') # SpatRaster with elevation madRivers <- fastData('madRivers') # sp vector with rivers  # Plot inputs: plot(madElev) plot(st_geometry(madRivers), col = \"lightblue\", add = TRUE) grassDir <- \"C:/Program Files/GRASS GIS 8.3\" # Windows grassDir <- \"/Applications/GRASS-8.2.app/Contents/Resources\" # Mac OS grassDir <- \"/usr/local/grass\" # Linux faster(grassDir = grassDir) elev <- fast(madElev) elev class       : GRaster topology    : 2D dimensions  : 1024, 626, NA, 1 (nrow, ncol, ndepth, nlyr) resolution  : 59.85157, 59.85157, NA (x, y, z) extent      : 731581.552, 769048.635, 1024437.272, 1085725.279 (xmin, xmax, ymin, ymax) coord ref.  : Tananarive (Paris) / Laborde Grid name(s)     : madElev datatype    : integer min. value  :       1 max. value  :     570 rivers <- fast(madRivers) rivers class       : GVector geometry    : 2D lines dimensions  : 11, 11, 5 (geometries, sub-geometries, columns) extent      : 731627.1, 762990.132, 1024541.235, 1085580.454 (xmin, xmax, ymin, ymax) coord ref.  : Tananarive (Paris) / Laborde Grid names       :   F_CODE_DES          HYC_DESCRI      NAM   ISO     NAME_0 type        :        <chr>               <chr>    <chr> <chr>      <chr> values      : River/Stream Perennial/Permanent MANANARA   MDG Madagascar               River/Stream Perennial/Permanent MANANARA   MDG Madagascar               River/Stream Perennial/Permanent      UNK   MDG Madagascar              ...and  8  more rows # width in meters because CRS is projected river_buffers <- buffer(rivers, width = 1000, dissolve = TRUE) dist_to_rivers_meters <- distance(elev, river_buffers) plot(dist_to_rivers_meters) plot(river_buffers, border = 'white', add = TRUE) plot(rivers, col = \"lightblue\", add = TRUE)"},{"path":"/index.html","id":"exporting-grasters-and-gvectors-from-a-grass-session","dir":"","previous_headings":"","what":"Exporting GRasters and GVectors from a GRASS session","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"can convert GRaster SpatRaster raster using rast(): terra_elev <- rast(elev) convert GVector terra package’s SpatVector, use vect(): can use writeRaster() writeVector() save fasterRaster rasters vectors directly disk. always faster using rast() vect() saving.","code":"terra_rivers <- vect(rivers) elev_temp_file <- tempfile(fileext = \".tif\") # save as GeoTIFF writeRaster(elev, elev_temp_file)  vect_temp_shp <- tempfile(fileext = \".shp\") # save as shapefile vect_temp_gpkg <- tempfile(fileext = \".gpkg\") # save as GeoPackage writeVector(rivers, vect_temp_shp) writeVector(rivers, vect_temp_gpkg)"},{"path":"/index.html","id":"tips-for-making-fasterraster-faster","dir":"","previous_headings":"","what":"Tips for making fasterRaster faster","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"Loading rasters vectors directly disk using fast(), rather converting terra sf objects faster. ? object file R object points, fast() save disk first GeoTIFF GeoPackage file, load GRASS. Similarly, saving GRasters GVectors directly disk always faster converting SpatRasters SpatVector using rast() vect(), saving . ? functions actually save file disk uses respective function respective package connect file. Every time switch using GRaster GVector different coordinate reference system (CRS), GRASS spend second changing CRS. , can save time much work possible objects one CRS, switching work objects another CRS. default, fasterRaster use 2 cores 2048 MB (2 GB) memory GRASS modules allow users specify values. can set higher values using faster() thus potentially speed calculations. Functions newer versions GRASS capacity use options, updating GRASS latest version can help, . Compared terra sf, fasterRaster faster large vector operations, large vectors, vector processing packages first can. obviate problems disk space filling , default fasterRaster functions delete intermediate files. However, creating lot big GRasters GVectors, can skip time-taking step setting clean option FALSE using faster(clean = FALSE).","code":""},{"path":"/index.html","id":"versioning","dir":"","previous_headings":"","what":"Versioning","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"fasterRaster versions look something like 8.3.1.2, generally, M1.M2.S1.S2. , M1.M2 mirror version GRASS fasterRaster built tested. example, fasterRaster version 8.3 work using GRASS 8.3 (earlier versions starting 8.0). values S1.S2 refer “major” “minor” versions fasterRaster. , change value S1 (e.g., 8.3.1.0 8.3.2.0) indicates changes potentially break older code developed prior version fasterRaster. change S2 refers bug fix, additional functionality existing function, addition entirely new function. Note M1.M2 S1.S2 increment independently. example, version changes 8.3.1.5 8.4.1.5, new version tested GRASS 8.4, code developed version 8.3.1.X fasterRaster still work. NOTE: fasterRaster still beta/alpha release, version look something like 8.3.0.7XXX, following Hadley Wickham’s guidelines versioning development.","code":""},{"path":"/index.html","id":"further-reading","dir":"","previous_headings":"","what":"Further reading","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"Robert Hijman’s terra package Edzer Pebesma’s sf package good places start familiar GIS R. Roger Bivand’s rgrass package allows users call GRASS function functionality, cases far beyond allowed fasterRaster. GRASS GIS website authoritative contains manual GRASS functions used package . Wiki run GRASS R R GRASS help become power-user GRASS R.","code":""},{"path":"/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Faster Raster and Spatial Vector Processing Using GRASS GIS","text":"publication forthcoming(!), February 2024, yet package-specific citation fasterRaster. However, package first used : Morelli, T.L., Smith, .B., Mancini, .N., Balko, E. ., Borgenson, C., Dolch,R., Farris, Z., Federman, S., Golden, C.D., Holmes, S., Irwin, M., Jacobs,R.L., Johnson, S., King, T., Lehman, S., Louis, E.E. Jr., Murphy, .,Randriahaingo, H.N.T., Lucien,Randriannarimanana, H.L.L.,Ratsimbazafy, J.,Razafindratsima, O.H., Baden, .L. 2020. fate Madagascar’s rainforest habitat. Nature Climate Change 10:89-96. * Equal contribution DOI: https://doi.org/10.1038/s41558-019-0647-x. Abstract. Madagascar experienced extensive deforestation overharvesting, anthropogenic climate change compound pressures. Anticipating threats endangered species ecosystems requires considering climate change habitat loss effects. genus Varecia (ruffed lemurs), composed two Critically Endangered forest-obligate species, can serve status indicator biodiversity eastern rainforests Madagascar. , combined decades research show suitable habitat ruffed lemurs reduced 29–59% deforestation, 14–75% climate change (representative concentration pathway 8.5) 38–93% 2070. current protected areas avoid deforestation, climate change still reduce suitable habitat 62% (range: 38–83%). ongoing deforestation continues, suitable habitat decline 81% (range: 66–93%). Maintaining enhancing integrity protected areas, rates forest loss lower, essential ensuring persistence diversity rapidly diminishing Malagasy rainforests. ~ Adam","code":""},{"path":"/reference/Arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","title":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","text":"GRasters: can arithmetic operations GRasters using normal operators R: +, -, *, /, ^, %% (modulus), %/% (integer division). GVectors: can also arithmetic operations GVectors:+ operator: union()- operator: erase()* operator: intersect()/ operator: xor()","code":""},{"path":"/reference/Arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","text":"","code":"# S4 method for class 'GRaster,logical' Arith(e1, e2)  # S4 method for class 'logical,GRaster' Arith(e1, e2)  # S4 method for class 'GRaster,numeric' Arith(e1, e2)  # S4 method for class 'GRaster,integer' Arith(e1, e2)  # S4 method for class 'numeric,GRaster' Arith(e1, e2)  # S4 method for class 'integer,GRaster' Arith(e1, e2)  # S4 method for class 'GRaster,GRaster' Arith(e1, e2)  # S4 method for class 'GVector,GVector' Arith(e1, e2)"},{"path":"/reference/Arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","text":"e1, e2 GRasters, numerics, integers, logicals.","code":""},{"path":"/reference/Arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","text":"GRaster.","code":""},{"path":"/reference/Arithmetic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic operations on GRasters — Arith,GRaster,logical-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev) elevs <- c(elev, elev, log10(elev) - 1, sqrt(elev)) names(elevs) <- c(\"elev1\", \"elev2\", \"log_elev\", \"sqrt_elev\")  elev elevs  # do some math elev + 100 elev - 100 elev * 100 elev / 100 elev ^ 2 elev %/% 100 # divide then round down elev %% 100 # modulus  100 + elev 100 %/% elev 100 %% elev  elevs + 100 100 + elevs  # math with logicals elev + TRUE elev - TRUE elev * TRUE elev / TRUE elev ^ TRUE elev %/% TRUE # divide then round down elev %% TRUE # modulus  elevs + TRUE TRUE + elevs  # Raster interacting with raster(s): elev + elev elev - elev elev * elev elev / elev elev ^ log(elev) elev %/% sqrt(elev) # divide then round down elev %% sqrt(elev) # modulus  elevs + elev elev * elevs  # sign abs(-1 * elev) abs(elevs)  # powers sqrt(elevs)  # trigonometry sin(elev) cos(elev) tan(elev)  asin(elev) acos(elev) atan(elev)  atan(elevs) atan2(elev, elev^1.2) atan2(elevs, elev^1.2) atan2(elev, elevs^1.2) atan2(elevs, elevs^1.2)  # logarithms exp(elev) log(elev) ln(elev) log2(elev) log1p(elev) log10(elev) log10p(elev) log(elev, 3)  log(elevs)  # rounding round(elev + 0.5) floor(elev + 0.5) ceiling(elev + 0.5) trunc(elev + 0.5)  # comparison elev < 100 elev <= 100 elev == 100 elev != 100 elev > 100 elev >= 100  elev + 100 < 2 * elev  elevs > 10 10 > elevs  # logic elev < 10 | elev > 200 elev < 10 | cos(elev) > 0.9  elev < 10 | TRUE TRUE | elev > 200  elev < 10 | FALSE FALSE | elev > 200  elev < 10 & cos(elev) > 0.9  elev < 10 & TRUE TRUE & elev > 200  elev < 10 & FALSE FALSE & elev > 200  # Mathematical functions on GRasters with >= 2 layers: mean(elevs) mmode(elevs) median(elevs) nunique(elevs)  sum(elevs) count(elevs) min(elevs) max(elevs) range(elevs) skewness(elevs) kurtosis(elevs)  which.min(elevs) which.max(elevs)  slope(elevs) intercept(elevs) r2(elevs) tvalue(elevs)  stdev(elevs) stdev(elevs, pop = FALSE) var(elevs) varpop(elevs)  # Note: To get quantiles for each layer, use # global(x, \"quantile\", probs = 0.2). quantile(elevs, 0.1)  }"},{"path":"/reference/Compare-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","title":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","text":"can comparative operations GRasters using normal operators R: <, <=, ==, !=, >=, >. can also use %% categorical GRasters. can also compare two GRegions using == != operators. users fasterRaster work much regions, can ignore functionality. GRegions coordinate reference system, location mapset, topology (2D 3D), extent, resolution. 3D, must also vertical extent number depths.","code":""},{"path":"/reference/Compare-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' Compare(e1, e2)  # S4 method for class 'logical,GRaster' Compare(e1, e2)  # S4 method for class 'GRaster,logical' Compare(e1, e2)  # S4 method for class 'numeric,GRaster' Compare(e1, e2)  # S4 method for class 'GRaster,numeric' Compare(e1, e2)  # S4 method for class 'GRaster,integer' Compare(e1, e2)  # S4 method for class 'integer,GRaster' Compare(e1, e2)  # S4 method for class 'GRaster,character' Compare(e1, e2)  # S4 method for class 'character,GRaster' Compare(e1, e2)  # S4 method for class 'GRegion,GRegion' Compare(e1, e2)"},{"path":"/reference/Compare-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","text":"e1, e2 Values depend type comparison: Comparing GRasters logical, numeric, character values: e1 e2 can one . Comparison character string can useful using categorical raster, case can use something like raster1 == \"Wetlands\" coerce \"wetland\" cells 1 (TRUE) others 0 (FALSE) NA (originally NA). Comparing GRegion another GRegion: e1 e2 must GRegions!","code":""},{"path":"/reference/Compare-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","text":"Comparing GRasters: \"integer\" GRaster values 0 (FALSE), 1 (TRUE), NA (neither). Comparing GRegions: Output logical.","code":""},{"path":"/reference/Compare-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare-methods operations on GRasters and GRegions — Compare,GRaster,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev) elevs <- c(elev, elev, log10(elev) - 1, sqrt(elev)) names(elevs) <- c(\"elev1\", \"elev2\", \"log_elev\", \"sqrt_elev\")  elev elevs  # do some math elev + 100 elev - 100 elev * 100 elev / 100 elev ^ 2 elev %/% 100 # divide then round down elev %% 100 # modulus  100 + elev 100 %/% elev 100 %% elev  elevs + 100 100 + elevs  # math with logicals elev + TRUE elev - TRUE elev * TRUE elev / TRUE elev ^ TRUE elev %/% TRUE # divide then round down elev %% TRUE # modulus  elevs + TRUE TRUE + elevs  # Raster interacting with raster(s): elev + elev elev - elev elev * elev elev / elev elev ^ log(elev) elev %/% sqrt(elev) # divide then round down elev %% sqrt(elev) # modulus  elevs + elev elev * elevs  # sign abs(-1 * elev) abs(elevs)  # powers sqrt(elevs)  # trigonometry sin(elev) cos(elev) tan(elev)  asin(elev) acos(elev) atan(elev)  atan(elevs) atan2(elev, elev^1.2) atan2(elevs, elev^1.2) atan2(elev, elevs^1.2) atan2(elevs, elevs^1.2)  # logarithms exp(elev) log(elev) ln(elev) log2(elev) log1p(elev) log10(elev) log10p(elev) log(elev, 3)  log(elevs)  # rounding round(elev + 0.5) floor(elev + 0.5) ceiling(elev + 0.5) trunc(elev + 0.5)  # comparison elev < 100 elev <= 100 elev == 100 elev != 100 elev > 100 elev >= 100  elev + 100 < 2 * elev  elevs > 10 10 > elevs  # logic elev < 10 | elev > 200 elev < 10 | cos(elev) > 0.9  elev < 10 | TRUE TRUE | elev > 200  elev < 10 | FALSE FALSE | elev > 200  elev < 10 & cos(elev) > 0.9  elev < 10 & TRUE TRUE & elev > 200  elev < 10 & FALSE FALSE & elev > 200  # Mathematical functions on GRasters with >= 2 layers: mean(elevs) mmode(elevs) median(elevs) nunique(elevs)  sum(elevs) count(elevs) min(elevs) max(elevs) range(elevs) skewness(elevs) kurtosis(elevs)  which.min(elevs) which.max(elevs)  slope(elevs) intercept(elevs) r2(elevs) tvalue(elevs)  stdev(elevs) stdev(elevs, pop = FALSE) var(elevs) varpop(elevs)  # Note: To get quantiles for each layer, use # global(x, \"quantile\", probs = 0.2). quantile(elevs, 0.1)  }"},{"path":"/reference/GLocation.html","id":null,"dir":"Reference","previous_headings":"","what":"Classes for fasterRaster sessions, regions, rasters, and vectors — GLocation-class","title":"Classes for fasterRaster sessions, regions, rasters, and vectors — GLocation-class","text":"G suite S4 classes contain pointers GRASS objects metadata current GRASS session. users manipulate objects using classes, need know details. GLocation class stores information GRASS \"session\" (\"location\" mapsets\"), coordinate reference system. Contained rest. GSpatial class contains GLocation class stores information spatial objects (extent, topology) plus name file representing GRASS (source). Contained GRegion, GRaster, GVector. GRegion class contains GSpatial class stores information grids (dimensions resolution). sources, used (always NA). Contained GRaster. GRegion corresponds GRASS \"regions\", though GRegion objects actually pointers GRASS \"region\" files. GRaster class contains GRegion class represents rasters. stores information number layers, categories, min/max values, user-friendly names. Categorical rasters can also associated \"levels\" table representing categorical data (e.g., wetlands, forest, etc.). GVector class contains GSpatial class represents spatial vectors. may may associated data.table (.e., data.frame), contains metadata geometry vector.","code":""},{"path":"/reference/GLocation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classes for fasterRaster sessions, regions, rasters, and vectors — GLocation-class","text":"object class GLocation, GSpatial, GRegion, GRaster, GVector.","code":""},{"path":"/reference/GLocation.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Classes for fasterRaster sessions, regions, rasters, and vectors — GLocation-class","text":"location Character (classes): GRASS \"location\" object. default value default. Can obtained using hidden function .location(). mapset Character (classes): GRASS \"mapset\". Default value PERMANENT. Typically hidden users. Can obtained using hidden function .mapset(). workDir Character (classes): Directory GRASS stores files. topology Character (GSpatial objects, including GRegions, GRasters, GVectors): Valid values 2D (2-dimensional–rasters vectors) 3D (3-dimensional–e.g., LIDAR data). Can obtained using topology(). sources Character (GRasters GVectors): Name object GRASS. typically made --fly provide pointer object R GRASS. Changing manually break connection. Can obtained using sources(). names Character  (GRasters ): Name raster raster layer . Can obtained using names(). crs Character (classes): Coordinate reference systems string (preferably WKT2 format). Can obtained using crs() st_crs(). projection Character: GRASS \"projection\" GRaster GVector. Can obtained using .projection(). dimensions Dimensions: GRegions GRasters: Vector three integers indicating number rows, columns, depths (3D objects). Can obtained using dim(), plus nrow(), ncol(), ndepth(). GVectorss: Vector two integers indicating number geometries number fields. Can obtained using dim(), plus nrow() ncol(). extent Numeric vector four values (GSpatial objects, including GRegions, GRasters, GVectors): Extent object listed order westernmost longitude, easternmost longitude, southernmost latitude, northernmost latitude. Can obtained using ext(). zextent Numeric (GSpatial objects, including GRegions, GRasters, GVectors): Bottom- top-extents 3D GRasters GVectors. Can obtained using zext(). geometry Character (GVectorss): Either points, lines, polygons. Can obtained using geomtype(). nLayers Integer (GRasters): Number layers (\"stacked\" rasters–different number depths 3D rasters). Can obtained using nlyr(). nGeometries Integer (GVectors): Number features (points, lines, polygons). Can obtained using nrow(). datatypeGRASS Character (GRasters): Type data stored raster, interpreted GRASS. either CELL (integers), FCELL (floating-point values), DCELL (double-values). Can obtained using datatype(). resolution Vector two numeric values (GRegions, including GRasters): Size raster cell east-west direction north-south direction. Can obtained using res() res3d(). minVal,maxVal Numeric (GRasters): Minimum maximum value across cells. Can obtained using minmax(). activeCat Integer (GRasters): Column index category labels. Must >0. Note user's standpoint, 1 subtracted number. value @activeCat 2, user see \"1\" printed. Can obtained using activeCat(). levels List data.tables (GRasters): Tables categorical rasters. raster categorical, data.table NULL, data.table(NULL). Can obtained using levels() cats(). table data.table (GVectors): Table metadata, one row per geometry (point, line, plane). table associated vector, must data.table(NULL). column category value given @catName. catName Character (GVectors): Name column vector's database contains category values (integers).","code":""},{"path":"/reference/Logic-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","title":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","text":"can logical operations GRasters. , value 1 interpreted TRUE, value 0 interpreted FALSE. can compare: GRaster another GRaster GRaster logical value (TRUE FALSE, NA) GRaster numeric integer value 0 1 Operators include: |: TRUE either condition TRUE (1), returns NA either condition NA. &: TRUE conditions TRUE (1), NA either NA.","code":""},{"path":"/reference/Logic-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' Logic(e1, e2)  # S4 method for class 'logical,GRaster' Logic(e1, e2)  # S4 method for class 'GRaster,logical' Logic(e1, e2)  # S4 method for class 'GRaster,numeric' Logic(e1, e2)  # S4 method for class 'numeric,GRaster' Logic(e1, e2)  # S4 method for class 'GRaster,integer' Logic(e1, e2)  # S4 method for class 'integer,GRaster' Logic(e1, e2)"},{"path":"/reference/Logic-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","text":"e1, e2 Two GRasters, GRaster logical value (TRUE FALSE, NA), numeric value 0 1 (NA_real_), integer value 0 1 (NA_integer_).","code":""},{"path":"/reference/Logic-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","text":"binary GRaster (1 ==> TRUE, 0 ==> FALSE, plus NA comparison results NA).","code":""},{"path":"/reference/Logic-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logic-methods operations on GRasters — Logic,GRaster,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev) elevs <- c(elev, elev, log10(elev) - 1, sqrt(elev)) names(elevs) <- c(\"elev1\", \"elev2\", \"log_elev\", \"sqrt_elev\")  elev elevs  # do some math elev + 100 elev - 100 elev * 100 elev / 100 elev ^ 2 elev %/% 100 # divide then round down elev %% 100 # modulus  100 + elev 100 %/% elev 100 %% elev  elevs + 100 100 + elevs  # math with logicals elev + TRUE elev - TRUE elev * TRUE elev / TRUE elev ^ TRUE elev %/% TRUE # divide then round down elev %% TRUE # modulus  elevs + TRUE TRUE + elevs  # Raster interacting with raster(s): elev + elev elev - elev elev * elev elev / elev elev ^ log(elev) elev %/% sqrt(elev) # divide then round down elev %% sqrt(elev) # modulus  elevs + elev elev * elevs  # sign abs(-1 * elev) abs(elevs)  # powers sqrt(elevs)  # trigonometry sin(elev) cos(elev) tan(elev)  asin(elev) acos(elev) atan(elev)  atan(elevs) atan2(elev, elev^1.2) atan2(elevs, elev^1.2) atan2(elev, elevs^1.2) atan2(elevs, elevs^1.2)  # logarithms exp(elev) log(elev) ln(elev) log2(elev) log1p(elev) log10(elev) log10p(elev) log(elev, 3)  log(elevs)  # rounding round(elev + 0.5) floor(elev + 0.5) ceiling(elev + 0.5) trunc(elev + 0.5)  # comparison elev < 100 elev <= 100 elev == 100 elev != 100 elev > 100 elev >= 100  elev + 100 < 2 * elev  elevs > 10 10 > elevs  # logic elev < 10 | elev > 200 elev < 10 | cos(elev) > 0.9  elev < 10 | TRUE TRUE | elev > 200  elev < 10 | FALSE FALSE | elev > 200  elev < 10 & cos(elev) > 0.9  elev < 10 & TRUE TRUE & elev > 200  elev < 10 & FALSE FALSE & elev > 200  # Mathematical functions on GRasters with >= 2 layers: mean(elevs) mmode(elevs) median(elevs) nunique(elevs)  sum(elevs) count(elevs) min(elevs) max(elevs) range(elevs) skewness(elevs) kurtosis(elevs)  which.min(elevs) which.max(elevs)  slope(elevs) intercept(elevs) r2(elevs) tvalue(elevs)  stdev(elevs) stdev(elevs, pop = FALSE) var(elevs) varpop(elevs)  # Note: To get quantiles for each layer, use # global(x, \"quantile\", probs = 0.2). quantile(elevs, 0.1)  }"},{"path":"/reference/activeCat.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","title":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","text":"functions return set column labels matched value raster categorical GRaster. Important: Following terra::activeCat(), first column \"levels\" table ignored, \"active category\" value 1 means second column used labels, value 2 means third used, . activeCat() returns column labels matched value raster single raster layer. activeCats() , layers GRaster. activeCat()<- sets column used category labels.","code":""},{"path":"/reference/activeCat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","text":"","code":"# S4 method for class 'GRaster' activeCat(x, layer = 1, names = FALSE)  # S4 method for class 'GRaster' activeCats(x, names = FALSE)  # S4 method for class 'GRaster' activeCat(x, layer = 1) <- value  # S4 method for class 'GRaster' activeCat(x, layer = 1) <- value  # S4 method for class 'GRaster' activeCat(x, layer = 1) <- value"},{"path":"/reference/activeCat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","text":"x categorical GRaster. layer Numeric, integer, logical, character: Indicates layer(s) get set active category column. can number (index raster(s)), logical vector (TRUE ==> get/set active category column, FALSE ==> leave -), character vector (names layers). names Logical: TRUE, display name(s) active column(s). FALSE (default), report index active column. Following terra::activeCat(), first column levels table ignored. , active column \"1\" means second column active. \"2\" means third column active, . value Numeric, integer, character. Following terra::activeCat(), first column levels table ignored. , want second column category label, use 1. want third column, use 2, . can also specify active column column name (though first column's name).","code":""},{"path":"/reference/activeCat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","text":"activeCat() returns integer character active column index name. activeCats() returns vector indices names. activeCat()<- returns GRaster.","code":""},{"path":"/reference/activeCat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set the column with category labels in a categorical raster — activeCat,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/add.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function \"stacks\" one GRaster another. functionality c().","code":""},{"path":"/reference/add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"# S4 method for class 'GRaster,GRaster' add(x) <- value"},{"path":"/reference/add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"x, value GRaster.","code":""},{"path":"/reference/add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/addCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Add rows or columns to the ","title":"Add rows or columns to the ","text":"addCats() addCats()<- add information categorical`GRaster's \"levels\" table. addCats()` uses data.table::merge() cbind() –add new rows, rather new columns. addCats()<- uses rbind() add new categories (rows) \"levels\" table. GRasters can represent [categorical data][tutorial_raster_data_types]. Cell values actually integers, corresponding category, \"desert\" \"wetland.\" categorical raster associated \"levels\" table matches value category name. table must NULL` (.e., categories–categorical raster), least two columns. first column must integers represent raster values. One subsequent columns must category labels. column labels \"active category\".","code":""},{"path":"/reference/addCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add rows or columns to the ","text":"","code":"# S4 method for class 'GRaster' addCats(x, value, merge = FALSE, layer = 1)  # S4 method for class 'GRaster' addCats(x, layer = 1) <- value"},{"path":"/reference/addCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add rows or columns to the ","text":"x GRaster. value data.frame, data.table, list data.frames data.tables one per raster layer, categorical SpatRaster. table's first column \"value\" column must contain numeric values (class numeric character). SpatRaster supplied, categories transferred GRaster. merge Logical (function addCats()): FALSE (default), columns combined existing \"levels\" table using cbind(). TRUE, combined using data.table::merge(). layer Numeric integers, logical vector, character: Layer(s) add drop levels.","code":""},{"path":"/reference/addCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add rows or columns to the ","text":"GRaster. \"levels\" table raster modified.","code":""},{"path":[]},{"path":"/reference/addCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add rows or columns to the ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/addTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","title":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","text":"addTable() adds entire table GVector. replace existing table. must one row table geometry (see ngeom()). can also add table column--column using $<- operator. dropTable() removes data table associated GVector.","code":""},{"path":"/reference/addTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","text":"","code":"# S4 method for class 'GVector,data.frame' addTable(x, ...) <- value  # S4 method for class 'GVector,data.table' addTable(x, ...) <- value  # S4 method for class 'GVector,matrix' addTable(x, ...) <- value  # S4 method for class 'GVector' dropTable(x)"},{"path":"/reference/addTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","text":"x GVector. ... arguments (ignored). value data.frame, data.table, matrix.","code":""},{"path":"/reference/addTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/addTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Attach or detach GVector's data table — addTable<-,GVector,data.frame-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Rivers vector madRivers <- fastData(\"madRivers\")  # Convert sf to a GVector rivers <- fast(madRivers)  # Convert GVector to data.frame or data.table as.data.frame(rivers) as.data.table(rivers)  # Subset rivers vector rivers1 <- rivers[1:2] rivers2 <- rivers[10:11]  # Concatenate rivers riversCombo <- rbind(rivers1, rivers2) riversCombo  # Add columns newCol <- data.frame(new = 1:11) riversCol <- colbind(rivers, newCol) riversCol  # Remove table riversCopy <- rivers riversCopy # has data table riversCopy <- dropTable(riversCopy) riversCopy # no data table  # Add a new table newTable <- data.frame(num = 1:11, letters = letters[1:11]) addTable(riversCopy) <- newTable riversCopy  }"},{"path":"/reference/aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","title":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","text":"applied GRaster, aggregate() creates new raster cells multiple size cells original raster. new cells can larger smaller original cells (function thus emulates terra::aggregate() terra::disagg() functions terra.) applied GVector, geometries combined \"multipart\" geometry, geometries treated single unit. Borders aggregated geometries can dissolved dissolve argument TRUE. GVector data table associated , output also data table long least one column values . Values columns duplicated values converted NA.","code":""},{"path":"/reference/aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","text":"","code":"# S4 method for class 'GRaster' aggregate(   x,   fact = 2,   fun = \"mean\",   weight = FALSE,   prob = NULL,   na.rm = FALSE )  # S4 method for class 'GVector' aggregate(x, dissolve = TRUE)"},{"path":"/reference/aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","text":"x GRaster GVector. fact Numeric vector (rasters ): One, two, three positive values. reflect size new cells multiples size old cells. just one value supplied, used two three dimensions. two values supplied, first multiplied east-west size cells, second north-south size cells (raster must 2D). three values supplied, third value used multiplier vertical dimension cells. Values calculated using cells centers contained target cell. Note unlike terra::aggregate() terra::disagg(), values need integers. fun Character (rasters ): Name function used aggregate. GRasters, function summarizes across cells. GVectors, function used calculate new values numeric integer cells. mean: Average (default) median: Median mode: common value min: Minimum max: Maximum range: Difference maximum minimum sum: Sum varpop: Population variance sdpop: Population standard deviation quantile: Quantile (see argument prob) count: Number non-NA cell diversity: Number unique values weight Logical (rasters ): FALSE, source cell center destination cell counted equally. TRUE, value source weighted proportion destination cell source cell covers. prob Numeric (rasters ): Quantile calculate quantile. na.rm Logical (rasters ): FALSE (default), propagate NA cells NA values. dissolve Logical (vectors ): TRUE (default), aggregated geometries borders dissolved. ignored input GVector \"polygons\" vector.","code":""},{"path":"/reference/aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","text":"GRaster GVector.","code":""},{"path":[]},{"path":"/reference/aggregate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate raster cells into larger cells or combine geometries of a vector — aggregate,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madCoast4 <- fastData(\"madCoast4\")  ### aggregating a GRaster #########################  # Convert: elev <- fast(madElev)  ### Aggregate GRaster by same factor in 2 dimensions # fasterRaster agg2 <- aggregate(elev, 2, \"mean\") agg2  # terra agg2terra <- aggregate(madElev, 2, \"mean\") agg2terra  # Compare rasters aggregated by fasterRaster and terra. # These should be the same. agg2 <- rast(agg2) agg2 <- extend(agg2, agg2terra) agg2 - agg2terra  ### Aggregate GRaster by a non-integer factor in 2 dimensions # fasterRaster agg2.9 <- aggregate(elev, 2.9, \"mean\") agg2.9  # terra agg2.9terra <- aggregate(madElev, 2.9, \"mean\") agg2.9terra  # Compare rasters aggregated by fasterRaster and terra. # These should be different. res(agg2.9) res(agg2.9terra) # terra rounds aggregation factor down 2 * res(madElev) # original resolution multiplied by 2  ### Aggregate GRaster by different factor in 2 dimensions agg2x3 <- aggregate(elev, c(2, 3), \"mean\") agg2x3  ### aggregating a GVector #########################  madCoast4 <- fastData(\"madCoast4\")  # Convert: coast <- fast(madCoast4)  # Aggregate and disaggregate: aggCoast <- aggregate(coast) disaggCoast <- disagg(coast)  ngeom(coast) ngeom(aggCoast) ngeom(disaggCoast)  # plot oldpar <- par(mfrow = c(1, 3)) plot(coast, main = \"Original\", col = 1:nrow(coast)) plot(aggCoast, main = \"Aggregated\", col = 1:nrow(aggCoast)) plot(disaggCoast, main = \"Disaggregated\", col = 1:nrow(disaggCoast)) par(oldpar)  }"},{"path":"/reference/app.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to a set of rasters — app,GRaster-method","title":"Apply a function to a set of rasters — app,GRaster-method","text":"app() applies function set \"stacked\" rasters. similar terra::app() terra::lapp() functions. appFuns() provides table GRASS functions can used app() equivalents R. appCheck() tests whether formula supplied app() \"forbidden\" function calls. app() function operates manner slightly different terra::app(). function applied must written character string. example, raster layer names \"x1\" \"x2\", function might like \"= max(sqrt(x1), log(x2))\". Rasters names functions used formula. example, rasters named \"max\", \"sqrt\", \"log\". app() function automatically check raster names appear also functions appear formula. However, can check formula running app() using appCheck() function. can obtain list app() functions using appFuns(). Note sometimes different applied R. Tips: Make sure GRasters names(). function matches , name variable use R GRaster. GRASS, use null() instead NA, use isnull() instead .na(). want calculate values using ignoring NA (null) values, see functions begin n (like nmean). mindful data type function returns. GRASS, CELL (integer), FCELL (floating point values–precise 7th decimal place), DCELL (double-floating point values–precise 15th decimal place). cases want datatype raster treated like float double data type raster, wrap raster float() double() functions datatype treated . especially useful raster might assumed CELL type contains integer values. can get data type raster using datatype() type argument set GRASS. can change data type GRaster using .int(), .float(), .doub(). Note categorical rasters really CELL (integer) rasters associated \"levels\" table. can also change CELL raster FCELL raster adding subtracting decimal value, x - 0.1 + 0.1. rand() function returns integer values default. want non-integer values, use tricks mentioned datatype non-integer values. example, want uniform random values range 0 1, use something like = float(rand(0 + 0.1, 1 + 0.1) - 0.1).","code":""},{"path":"/reference/app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to a set of rasters — app,GRaster-method","text":"","code":"# S4 method for class 'GRaster' app(x, fun, datatype = \"auto\", seed = NULL)  appFuns(warn = TRUE)  # S4 method for class 'GRaster,character' appCheck(x, fun, msgOnGood = TRUE, failOnBad = TRUE)"},{"path":"/reference/app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to a set of rasters — app,GRaster-method","text":"x GRaster one named layers. fun Character: function apply. must written character string follows rules: must use typical arithmetic operators like +, -, *, / /functions can seen using appFuns(TRUE). names() rasters match functions appFuns(TRUE) table. Note x y forbidden names :( help page GRASS module r.mapcalc especially helpful. datatype Character: ensures rasters treated certain type operated . useful using rasters integer values, GRASS can assume represent integers, even supposed . case, output operations raster might integer otherwise corrected. Partial matching used, options include: \"integer\": Force rasters integers truncating values. output may still type float operation creates non-integer values. \"float\": Force rasters considered floating-point values. \"double\": Force rasters considered double-floating point values. \"auto\" (default): Ensure rasters represented native datatype() (.e., \"CELL\" rasters integers, \"FCELL\" rasters floating-point, \"DCELL\" double-floating point). seed Numeric integer vector NULL (default): number random seed. Used app() function rand(), generates random number. NULL, seed generated. Defining seed useful replicating raster made rand(). must integer! warn Logical (function appFuns()): TRUE (default), display warning allFuns() called interactively. msgOnGood Logical (function appCheck()): TRUE (default), display message overt problems raster names formula detected. failOnBad Logical (function appCheck()): TRUE (default), fail overt problems raster names formula detected.","code":""},{"path":"/reference/app.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to a set of rasters — app,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to a set of rasters — app,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert SpatRaster to a GRaster: elev <- fast(madElev)  # Create a \"stack\" of rasters for us to operate on: x <- c(elev, elev^2, sqrt(elev))  # Demonstrate check for badly-named rasters: names(x) <- c(\"cos\", \"asin\", \"exp\") fun <- \"= cos / asin + exp\" appCheck(x, fun, failOnBad = FALSE)  # Rename rasters acceptable names and run the function: names(x) <- c(\"x1\", \"x2\", \"x3\") fun <- \"= (x1 / x2) + x3\" appCheck(x, fun, failOnBad = FALSE) app(x, fun = fun)  # This is the same as: (x[[1]] / x[[2]]) + x[[3]]  # We can view a table of app() functions using appFuns(): appFuns(FALSE) # Change to TRUE to see a Shiny version.  # We can also get the table using: data(appFunsTable)  # Apply other functions: fun <- \"= median(x1 / x2, x3, x1 * 2, cos(x2))\" app(x, fun = fun)  fun <- \"= round(x1) * tan(x2) + log(x3, 10)\" app(x, fun = fun)  # Demonstrate effects of data type. The \"+\" sign does not guarantee # output is of a given type, and the rasters are coerced to integers before # the operation is conducted in the second function. fun <- \"= x1 + x3\" app(x, fun = fun, datatype = \"float\") # output is floating-point app(x, fun = fun, da = \"integer\") # output is integer  # Some functions override the \"datatype\" argument. In this case, the output will # not be an integer because the sin() function returns a float value. fun <- \"= sin(x2)\" app(x, fun = fun, datatype = \"integer\")  # Make a raster with random numbers between 1 and 4, with equal probability # of each: fun <- \"= round(rand(0.5, 4.5))\" rand <- app(elev, fun = fun) rand  freq(rand) # cell frequencies  }"},{"path":"/reference/appFunsTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions that can be used in app() — appFunsTable","title":"Functions that can be used in app() — appFunsTable","text":"table functions can used app() function, R equivalents, datatype() return. can view table using ?appFunsTable searchable, sortable Shiny table using appFuns().","code":""},{"path":"/reference/appFunsTable.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Functions that can be used in app() — appFunsTable","text":"data.frame.","code":""},{"path":"/reference/appFunsTable.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Functions that can be used in app() — appFunsTable","text":"OSGeo","code":""},{"path":"/reference/appFunsTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions that can be used in app() — appFunsTable","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert SpatRaster to a GRaster: elev <- fast(madElev)  # Create a \"stack\" of rasters for us to operate on: x <- c(elev, elev^2, sqrt(elev))  # Demonstrate check for badly-named rasters: names(x) <- c(\"cos\", \"asin\", \"exp\") fun <- \"= cos / asin + exp\" appCheck(x, fun, failOnBad = FALSE)  # Rename rasters acceptable names and run the function: names(x) <- c(\"x1\", \"x2\", \"x3\") fun <- \"= (x1 / x2) + x3\" appCheck(x, fun, failOnBad = FALSE) app(x, fun = fun)  # This is the same as: (x[[1]] / x[[2]]) + x[[3]]  # We can view a table of app() functions using appFuns(): appFuns(FALSE) # Change to TRUE to see a Shiny version.  # We can also get the table using: data(appFunsTable)  # Apply other functions: fun <- \"= median(x1 / x2, x3, x1 * 2, cos(x2))\" app(x, fun = fun)  fun <- \"= round(x1) * tan(x2) + log(x3, 10)\" app(x, fun = fun)  # Demonstrate effects of data type. The \"+\" sign does not guarantee # output is of a given type, and the rasters are coerced to integers before # the operation is conducted in the second function. fun <- \"= x1 + x3\" app(x, fun = fun, datatype = \"float\") # output is floating-point app(x, fun = fun, da = \"integer\") # output is integer  # Some functions override the \"datatype\" argument. In this case, the output will # not be an integer because the sin() function returns a float value. fun <- \"= sin(x2)\" app(x, fun = fun, datatype = \"integer\")  # Make a raster with random numbers between 1 and 4, with equal probability # of each: fun <- \"= round(rand(0.5, 4.5))\" rand <- app(elev, fun = fun) rand  freq(rand) # cell frequencies  }"},{"path":"/reference/as.contour.html","id":null,"dir":"Reference","previous_headings":"","what":"Contour lines from a ","title":"Contour lines from a ","text":"Create GVector contour lines GRaster.","code":""},{"path":"/reference/as.contour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contour lines from a ","text":"","code":"# S4 method for class 'GRaster' as.contour(x, nlevels, levels)"},{"path":"/reference/as.contour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contour lines from a ","text":"x GRaster. nlevels Numeric: positive integer missing (default). Number levels calculate contours. Levels calculated equal-sized steps smallest largest value x. Either nlevels levels must specified. levels Numeric vector: numeric vector values calculate contour lines. Either nlevels levels must specified.","code":""},{"path":[]},{"path":"/reference/as.contour.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contour lines from a ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Calculate contour lines: conts <- as.contour(elev, nlevels = 10)  plot(madElev) plot(conts, add = TRUE)  }"},{"path":"/reference/as.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert GVector to a data frame — as.data.frame,GVector-method","title":"Convert GVector to a data frame — as.data.frame,GVector-method","text":"Convert GVector's data table data.frame data.table.","code":""},{"path":"/reference/as.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert GVector to a data frame — as.data.frame,GVector-method","text":"","code":"# S4 method for class 'GVector' as.data.frame(x)  # S4 method for class 'GVector' as.data.table(x)"},{"path":"/reference/as.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert GVector to a data frame — as.data.frame,GVector-method","text":"x GVector.","code":""},{"path":"/reference/as.data.frame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert GVector to a data frame — as.data.frame,GVector-method","text":"data.frame NULL (GRaster data table).","code":""},{"path":[]},{"path":"/reference/as.data.frame.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert GVector to a data frame — as.data.frame,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/as.int.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","title":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","text":"fasterRaster, rasters can three data types: \"factor\" (categorical rasters), \"integer\" (integers), \"float\" (floating point values, accurate 6th 9th decimal places), \"double\" (double-precision values, accurate 15th 17th decimal places). type raster can checked : .int(): Coerce values integers (GRASS type CELL). .float(): Coerce values floating-point precision. .doub(): Coerce values double-floating point precision. Integer rasters can converted categorical rasters adding \"levels\" tables levels<- categories().","code":""},{"path":"/reference/as.int.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","text":"","code":"# S4 method for class 'GRaster' as.int(x)  # S4 method for class 'GRaster' as.float(x)  # S4 method for class 'GRaster' as.doub(x)"},{"path":"/reference/as.int.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","text":"x GRaster.","code":""},{"path":"/reference/as.int.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/as.int.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce raster to integer, float, or double precision — as.int,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/as.lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a raster to a lines vector — as.lines,GRaster-method","title":"Convert a raster to a lines vector — as.lines,GRaster-method","text":".lines() converts GRaster \"lines\" GVector. apply function, may need run thinLines() raster reduce linear features single-cell width. may also need use clean geometry (especially \"duplicated\" \"removeDangles\" methods) afterward remove duplicated vertices \"dangling\" lines.","code":""},{"path":"/reference/as.lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a raster to a lines vector — as.lines,GRaster-method","text":"","code":"# S4 method for class 'GRaster' as.lines(x)"},{"path":"/reference/as.lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a raster to a lines vector — as.lines,GRaster-method","text":"x GRaster. one layer GRaster, first used (warning).","code":""},{"path":"/reference/as.lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a raster to a lines vector — as.lines,GRaster-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/as.lines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a raster to a lines vector — as.lines,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation madElev <- fastData(\"madElev\")  # Convert to GRaster: elev <- fast(madElev)  # Thin elevation raster. In this case, we need to run 300 thinning iterations # for the function to reduce the raster to linear features. thinned <- thinLines(elev, iter = 300) plot(thinned)  # Convert to lines: rastToLines <- as.lines(thinned) plot(rastToLines)  # We can clean this: cleanLines <- fixDangles(x = rastToLines) plot(rastToLines, col = \"red\") plot(cleanLines, add = TRUE)  }"},{"path":"/reference/as.points.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","title":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","text":".points() converts GRaster, lines polygons GVector points GVector. GRasters, points coordinates cell centers assigned cells' values. non-NA cells converted points. GVectors, point attributes line polygon belonged. Points extracted vertex.","code":""},{"path":"/reference/as.points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","text":"","code":"# S4 method for class 'GRaster' as.points(x, values = TRUE)  # S4 method for class 'GVector' as.points(x)"},{"path":"/reference/as.points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","text":"x GRaster, GVector. values Logical: TRUE (default), create attribute table raster cell values, one row per point.","code":""},{"path":"/reference/as.points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","text":"points GVector.","code":""},{"path":[]},{"path":"/reference/as.points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a GRaster, or lines or polygons GVector to a points vector — as.points,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, outline of a part of Madagascar, and rivers vector: madElev <- fastData(\"madElev\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\")  # Convert to GRaster and GVectors: elev <- fast(madElev) coast <- fast(madCoast0) rivers <- fast(madRivers)  # Extract points from raster. To make this fast, we will first crop the raster # to a small extent defined by a single river. river <- rivers[1] elevCrop <- crop(elev, river) elevPoints <- as.points(elevCrop) elevPoints  plot(elevCrop) plot(elevPoints, pch = '.', add = TRUE)  # Extract points from vectors: coastPoints <- as.points(coast) riversPoints <- as.points(rivers)  plot(coast) plot(coastPoints, add = TRUE)  plot(rivers, col = \"blue\", add = TRUE) plot(riversPoints, col = \"blue\", add = TRUE)  }"},{"path":"/reference/as.polygons.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a raster to a polygons vector — as.polygons,GRaster-method","title":"Convert a raster to a polygons vector — as.polygons,GRaster-method","text":".polygons() converts GRaster \"polygons\" GVector. running function, geometry cleaning may useful use \"tidy \" vector.","code":""},{"path":"/reference/as.polygons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a raster to a polygons vector — as.polygons,GRaster-method","text":"","code":"# S4 method for class 'GRaster' as.polygons(x, round = TRUE, smooth = FALSE)"},{"path":"/reference/as.polygons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a raster to a polygons vector — as.polygons,GRaster-method","text":"x GRaster. one layer GRaster, first used (warning). round Logical: TRUE (default), values raster rounded first conversion vector. causes cells adjacent (rounded) values combined single polygon. control, see clump(). smooth Logical: TRUE, round corners square features. Default FALSE.","code":""},{"path":"/reference/as.polygons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a raster to a polygons vector — as.polygons,GRaster-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/as.polygons.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a raster to a polygons vector — as.polygons,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation madElev <- fastData(\"madElev\")  # Convert SpatRaster to GRaster: elev <- fast(madElev)  # To speed things up, first group cells of similar value: elevClumps <- clump(elev, minDiff = 0.0115)  # Convert to polygons: rastToPolys <- as.polygons(elevClumps) plot(rastToPolys)  }"},{"path":"/reference/bioclims.html","id":null,"dir":"Reference","previous_headings":"","what":"BIOCLIM rasters — bioclims,GRaster-method","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"BIOCLIM set bioclimatic variables created modeling species' geographic distributions (Booth et al. 2014). function can create \"standard\" 19 set variables, plus several \"extended\" set. units reported assume input rasters mm (precipitation) deg C (temperature), raster represents month (time units allowed, corresponding changes temporal units assumed ). BIO1: Mean annual temperature, calculated using monthly means (deg C) BIO2: Mean diurnal range across months (average monthly difference maximum minimum temperature) (deg C) BIO3: Isothermality (100 * BIO02 / BIO07; unit-less) BIO4: Temperature seasonality (standard deviation across months average monthly temperature * 100; deg C) BIO5: Maximum temperature warmest month (based maximum temperature; deg C) BIO6: Minimum temperature coldest month (based minimum temperature; deg C) BIO7: Range annual temperature (BIO05 - BIO06; deg C) BIO8: Temperature wettest quarter (based mean temperature; deg C) BIO9: Temperature driest quarter (based mean temperature; deg C) BIO10: Temperature warmest quarter (based mean temperature; deg C) BIO11: Temperature coldest quarter (based mean temperature; deg C) BIO12: Total annual precipitation (mm) BIO13: Precipitation wettest month (mm) BIO14: Precipitation driest month (mm) BIO15: Precipitation seasonality (100 * coefficient variation; unit-less) BIO16: Precipitation wettest quarter (mm) BIO17: Precipitation driest quarter (mm) BIO18: Precipitation warmest quarter (based mean temperature; mm) BIO19: Precipitation coldest quarter (based mean temperature; mm) \"Extended\" set BIOCLIM variables (starts 41 avoid conflicts Kriticos et al. 2014): BIO41: Temperature quarter following coldest quarter (based mean temperature; deg C) BIO42: Temperature quarter following warmest quarter (based mean temperature; deg C) BIO43: Precipitation quarter following coldest quarter (based mean temperature; mm) BIO44: Precipitation quarter following warmest quarter (based mean temperature; mm) BIO45: Temperature quarter following driest quarter (based mean temperature; deg C) BIO46: Temperature quarter following wettest quarter (based mean temperature; deg C) BIO47: Precipitation quarter following driest quarter (based mean temperature; mm) BIO48: Precipitation quarter following wettest quarter (based mean temperature; mm) BIO49: Hottest month (based maximum temperature) BIO50: Coldest month (based minimum temperature) BIO51: Wettest month BIO52: Driest month BIO53: First month warmest quarter (based mean temperature) BIO54: First month coldest quarter (based mean temperature) BIO55: First month wettest quarter BIO56: First month driest quarter BIO57: greatest decrease temperature one month next (deg C; always >= 0) BIO58: greatest increase temperature one month next (deg C; always >= 0) BIO59: greatest decrease precipitation one month next (mm; always >= 0) BIO60: greatest increase precipitation one month next (mm; always >= 0) default, \"quarter\" refers consecutive run three months, financial quarter. quarter can thus include November-December-January, December-January-February, example. However, length quarter can changed using argument quarter. variables defined assuming input rasters represent monthly values (12 rasters min/max temperature precipitation), can also use sets 52 rasters, representing one per week, case \"quarter\" successive run 3 weeks. also attempt 365 rasters, case \"quarter\" run 3 successive days. BIOCLIMs 41 44 added capture \"shoulder\" seasons (spring autumn) important temperature regions. BIOCLIMs 45 48 also included consistency. BIOCLIMs 49 60 bioclimatic variables per se, useful assessing properties variables defined based \"-est\" month quarter. numbering new BIOCLIMs begun 41 BIOCLIMs 20 40 taken (Kriticos et al. 2014).","code":""},{"path":"/reference/bioclims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"","code":"# S4 method for class 'GRaster' bioclims(   ppt,   tmin,   tmax,   tmean = NULL,   bios = NULL,   sample = TRUE,   quarter = 3,   pptDelta = 1,   verbose = TRUE )  # S4 method for class 'SpatRaster' bioclims(   ppt,   tmin,   tmax,   tmean = NULL,   bios = NULL,   sample = TRUE,   quarter = 3,   pptDelta = 1 )"},{"path":"/reference/bioclims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"ppt multi-layered GRaster SpatRaster, representing monthly/weekly/daily precipitation. tmin, tmax multi-layered GRaster SpatRaster, representing monthly/weekly/daily minimum maximum temperature. tmean Either NULL (default), multi-layered GRaster SpatRaster, representing monthly/weekly/daily average temperature. NULL, tmean calculated internally tmin tmax. Providing rasters thus saves time already hand. bios : Numeric values: Calculate BIOCLIM variables. example, bios = c(1, 12) calculates BIOCLIMs 1 12. NULL (default): Calculate BIOCLIMs 1 19 \"*\": Calculate BIOCLIMs function can calculate. \"+\": Calculate BIOCLIMs 41 onward. combination (e.g., c(1, 12, \"+\")). sample Logical: TRUE (default), BIO4 15 calculated sample standard deviation. FALSE, population standard deviation used. quarter Numeric: Length \"quarter\". BIOCLIM variables typically calculated using monthly-averaged rasters (e.g., precipitation temperature January, February, etc.), case \"quarter\" 3 months (default quarter 3). However, function can accommodate set rasters representing time series (e.g., 365 daily rasters), case user can decide constitutes \"quarter\" calculation BIOCLIMs use \"quarters\" definitions. pptDelta Numeric: Value add precipitation calculation BIO15 (coefficient variation precipitation, times 100). Adding small value avoids division 0. default 1. verbose Logical: TRUE (default), display progress.","code":""},{"path":"/reference/bioclims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"GRaster one layers.","code":""},{"path":"/reference/bioclims.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"Booth, T.H., Nix, H.., Busby, J.R., Hutchinson, M.F.  2014.  BIOCLIM: first species distribution modeling package, early applications relevance current MaxEnt studies. Diversity Distributions 20:1-9 doi:10.1111/ddi.12144 . Kriticos, D.J., Jarošik, V., Otam N.  2014.  Extending suite BIOCLIM variables: proposed registry system case study using principal components analysis. Methods Ecology Evolution 5:956-960 doi:10.1111/2041-210X.12244 .","code":""},{"path":"/reference/bioclims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BIOCLIM rasters — bioclims,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Load rasters with precipitation and min/max temperature madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\")  ### Classic and extended BIOCLIMs from SpatRasters bcSR <- bioclims(madPpt, madTmin, madTmax, bios = \"*\") bcSR  ### BIOCLIMs from GRasters ppt <- fast(madPpt) tmin <- fast(madTmin) tmax <- fast(madTmax)  # Takes longer to run compared to SpatRaster version for small rasters, so # just calculate select BIOCLIMs: bc <- bioclims(ppt, tmin, tmax, bios = c(1, 5, 6, 12, 15)) bc plot(bc)  }"},{"path":"/reference/breakPolys.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix issues with geometries of a vector — breakPolys,GVector-method","title":"Fix issues with geometries of a vector — breakPolys,GVector-method","text":"functions intended help fix geometric issues GVector. Note functionality snap() removeAreas() functions can also implemented using fast() create GVector. breakPolys(): Break topologically clean areas. similar fixLines(), except break loops. Topologically clean vectors may occur vector imported format enforce topology, shapefile. Duplicate geometries automatically removed breaking. fixBridges(): Change \"bridges\" \"islands\" (topologically incorrect) within geometries lines. fixDangles(): Change \"dangles\" hanging boundaries lines shorter tolerance distance. tolerance <0, dangles changed lines.  Units tolerance map units, degrees unprojected CRSs. tolerance <0, dangles removed, function retain closed loops lines connecting loops. Dangles removed longest shortest. fixLines(): Break lines intersections lines form closed loops. remove0(): Remove boundaries lines length 0. removeAngles(): Collapse lines diverge angle computationally equivalent 0. tool often needs followed break() removeDups() methods. removeBridges(): Remove \"bridges\" \"islands\" (topologically incorrect) within geometries. removeDangles(): Remove \"dangling\" lines shorter tolerance distance. tolerance <0, dangles removed. Units tolerance map units, degrees unprojected CRSs. tolerance <0, dangles removed, function retain closed loops lines connecting loops. Dangles removed longest shortest. removeDupCentroids(): Remove duplicated area centroids. GRASS, closed polygons attributes mapped (hidden) centroid polygon. removeDups(): Remove duplicated features area centroids. removeSmallPolys(): Remove polygons smaller tolerance. Units tolerance square meters (regardless CRS). snap(): Snap lines/boundaries less tolerance apart. Subsequent removal dangles may needed. Units tolerance map units, degrees unprojected CRSs.","code":""},{"path":"/reference/breakPolys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix issues with geometries of a vector — breakPolys,GVector-method","text":"","code":"# S4 method for class 'GVector' breakPolys(x)  # S4 method for class 'GVector' fixBridges(x)  # S4 method for class 'GVector' fixDangles(x, tolerance = -1)  # S4 method for class 'GVector' fixLines(x)  # S4 method for class 'GVector' remove0(x)  # S4 method for class 'GVector' removeAngles(x)  # S4 method for class 'GVector' removeBridges(x)  # S4 method for class 'GVector' removeDangles(x, tolerance = -1)  # S4 method for class 'GVector' removeDupCentroids(x)  # S4 method for class 'GVector' removeDups(x)  # S4 method for class 'GVector' removeSmallPolys(x, tolerance)  # S4 method for class 'GVector' snap(x, tolerance)"},{"path":"/reference/breakPolys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix issues with geometries of a vector — breakPolys,GVector-method","text":"x GVector. tolerance Numeric NULL (default): Minimum distance map units (degrees unprojected, usually meters projected) minimum area (meters-squared, regardless projection).","code":""},{"path":"/reference/breakPolys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix issues with geometries of a vector — breakPolys,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/breakPolys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fix issues with geometries of a vector — breakPolys,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers) soam <- rivers[rivers$NAM == \"SOAMIANINA\"] # select one river for illustration  ### Simplify geometry (remove nodes) ####################################  vr <- simplifyGeom(soam, tolerance = 2000) dp <- simplifyGeom(soam, tolerance = 2000, method = \"dp\") dpr <- simplifyGeom(soam, tolerance = 2000, method = \"dpr\", prop = 0.5) rw <- simplifyGeom(soam, tolerance = 2000, method = \"rw\")  plot(soam, col = \"black\", lwd = 3) plot(vr, col = \"blue\", add = TRUE) plot(dp, col = \"red\", add = TRUE) plot(dpr, col = \"chartreuse\", add = TRUE) plot(rw, col = \"orange\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Vertex reduction\",       \"Douglas-Peucker\",       \"Douglas-Peucker reduction\",       \"Reumann-Witkam\"   ),   col = c(\"black\", \"blue\", \"red\", \"chartreuse\", \"orange\"),   lwd = c(3, 1, 1, 1, 1) )  ### Smooth geometry ###################  hermite <- smoothGeom(soam, dist = 2000, angle = 3) chaiken <- smoothGeom(soam, method = \"Chaiken\", dist = 2000)  plot(soam, col = \"black\", lwd = 2) plot(hermite, col = \"blue\", add = TRUE) plot(chaiken, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Hermite\",       \"Chaiken\"   ),   col = c(\"black\", \"blue\", \"red\"),   lwd = c(2, 1, 1, 1, 1) )  ### Clean geometry ##################  # Has no effect on this vector! noDangs <- removeDangles(soam, tolerance = 10000)  plot(soam, col = \"black\", lwd = 2) plot(noDangs, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"No dangles\"   ),   lwd = c(2, 1),   col = c(\"black\", \"red\") )  }"},{"path":"/reference/buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","title":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","text":"Buffers can constructed GRasters GVectors. rasters, buffer() function creates buffer around non-NA cells. output raster. vectors, buffer() st_buffer() functions create vector polygon larger smaller focal vector.","code":""},{"path":"/reference/buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","text":"","code":"# S4 method for class 'GRaster' buffer(   x,   width,   unit = \"meters\",   method = \"Euclidean\",   background = 0,   lowMemory = FALSE )  # S4 method for class 'GVector' buffer(x, width, capstyle = \"round\", dissolve = TRUE)  # S4 method for class 'GVector' st_buffer(x, dist, endCapStyle = \"round\", dissolve = FALSE)"},{"path":"/reference/buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","text":"x GRaster GVector. width Numeric: rasters – Maximum distance cells must focal cells within buffer. rasters, buffering unit \"cells\", get n cell widths, use n + epsilon, epsilon small number (e.g., 0.001). larger buffer, smaller must ensure just n cells included. vectors, distance object place buffer. Negative values create \"inside\" buffers. Units units current coordinate reference system (e.g., degrees WGS84 NAD83, often meters projected systems). unit Character: Rasters – Indicates units width. Can one :   \"meters\" (default), \"metres\", \"m\"; \"kilometers\" \"km\"; \"feet\" \"ft\"; \"miles\" \"mi\"; \"nautical miles\" \"nmi\". Partial matching used case ignored. method Character: Rasters – used units \"cells\". Indicates manner distances calculated adding cells: \"Euclidean\": Euclidean distance (default) \"Manhattan\": \"taxi-cab\" distance \"maximum\": Maximum north-south east-west distances points. Partial matching used case ignored. background Numeric: Rasters – Value assign cells NA part buffer (default 0). lowMemory Logical: Rasters – used buffering raster units \"meters\". FALSE (default) use faster, memory-intensive procedure. TRUE use slower, low-memory version. help decide use, consider using low-memory version system 1 GB RAM raster larger 32000x32000 cells, system  8 GB RAM raster larger 90000x90000 cells. capstyle, endCapStyle Character: Vectors – Style ending \"cap\" buffers around lines. Valid options include \"rounded\", \"square\", \"flat\". dissolve Logical (GVectors): TRUE (default), dissolve buffers creation. FALSE, construct buffer geometry. Note overlapping buffers can cause function fail creates topologically ambiguous polygon. Thus, using dissolve = TRUE recommended. dist Vectors – width.","code":"* `\"cells\"`: Units are numbers of cells."},{"path":"/reference/buffer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","text":"Note cases, topologically incorrect vectors can created buffering. can arise buffers intersect create intersections technically belong two geometries. issue can resolved dissolving borders buffered geometries using dissolve = TRUE, now, fix want dissolve geometries. workaround create different GVector geometry, buffer individually :(.","code":""},{"path":[]},{"path":"/reference/buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Increase/decrease the size of a vector or around non-NA cells of a raster — buffer,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, rivers vector madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\")  # Convert a SpatRaster to a GRaster, and sf to a GVector elev <- fast(madElev) rivers <- fast(madRivers)  ### Buffer a raster by a given distance: buffByDist <- buffer(elev, width = 2000) # 2000-m buffer plot(buffByDist, legend = FALSE) plot(madElev, add = TRUE)  ### Buffer a raster by a given number of cells: buffByCells <- buffer(elev, width = 20.01, unit = \"cells\") # 20-cell buffer plot(buffByCells, legend = FALSE) plot(madElev, add = TRUE)  ### Buffer a vector: buffRivers <- buffer(rivers, width = 2000, dissolve = TRUE) # 2000-m buffer plot(buffRivers) plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  }"},{"path":"/reference/c.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"GRasters can \"stacked\" using function, effectively creating multi-layered raster. different creating 3-dimensional raster, though effect can emulated using stacking. GVectors can combined single vector.  Stacks can created : objects class (either GRasters GVectors). objects coordinate reference system (see crs()). Horizontal extents (see ext()). Horizontal dimensions (see res()). topology (2- 3-dimensional) must . 3D, rasters must number depths vertical extents (see topology()). Data tables associated GVectors combined vector table table columns data types. Otherwise, data table combined using merge().","code":""},{"path":"/reference/c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"# S4 method for class 'GRaster' c(x, ...)"},{"path":"/reference/c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"x GRaster GVector. ... One GRasters, one GVectors, list GRasters, list GVectors. can use mix lists individual rasters vectors.","code":""},{"path":"/reference/c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"if (grassStarted()) {  # Setup madForest2000 <- fastData(\"madForest2000\") madForest2014 <- fastData(\"madForest2014\")  # Convert SpatRasters to GRasters: forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  # Combine: forest <- c(forest2000, forest2014) forest  nlyr(forest)  }"},{"path":"/reference/catNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","title":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","text":"function returns column names \"levels\" table categorical raster.","code":""},{"path":"/reference/catNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","text":"","code":"# S4 method for class 'GRaster' catNames(x, layer = NULL)  # S4 method for class 'SpatRaster' catNames(x, layer = NULL)"},{"path":"/reference/catNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","text":"x GRaster. layer NULL, numeric integer, character: index (indices) name(s) one raster layers. default NULL, case names layers returned.","code":""},{"path":"/reference/catNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","text":"list character vectors.","code":""},{"path":[]},{"path":"/reference/catNames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Names of columns of the levels table of a categorical raster — catNames,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/cellSize.html","id":null,"dir":"Reference","previous_headings":"","what":"Area of GRaster cells — cellSize,GRaster-method","title":"Area of GRaster cells — cellSize,GRaster-method","text":"cellArea() returns raster cell values equal area. get area cells raster, see expanse().","code":""},{"path":"/reference/cellSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area of GRaster cells — cellSize,GRaster-method","text":"","code":"# S4 method for class 'GRaster' cellSize(x, mask = FALSE, lyrs = FALSE, unit = \"meters2\")"},{"path":"/reference/cellSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area of GRaster cells — cellSize,GRaster-method","text":"x GRaster. mask Logical: TRUE, cells NA x also NA output. lyrs Logical: lyrs FALSE (default), output single layer. case, mask TRUE, cells NA first layer also NA output. lyrs TRUE, output number layers x mask also TRUE. case, cells area NA input also NA output respective layer. unit Character: Units area. Partial matching used, case ignored. Can : \"meters2\" (default), \"metres2\", \"m2\" \"km2\" \"kilometers2\" \"ha\" \"hectares\" \"ac\" \"acres\" \"mi2\" \"miles2\" \"ft2\" \"feet2\"","code":""},{"path":"/reference/cellSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area of GRaster cells — cellSize,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/cellSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area of GRaster cells — cellSize,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Cell size, no masking, single layer cs1 <- cellSize(elev) plot(cs1)  # Cell size, with masking, single layer cs2 <- cellSize(elev, mask = TRUE) plot(cs2)  # Cell size, no masking, multilayer elev2 <- c(elev, log(elev - 200)) cs3 <- cellSize(elev2) plot(cs3)  # Cell size, masking by 1st layer, multilayer (ignores subsequent layers) cs4 <- cellSize(elev2, mask = TRUE) plot(cs4)  # Cell size, masking by each layer, multilayer cs5 <- cellSize(elev2, mask = TRUE, lyrs = TRUE) plot(cs5)  }"},{"path":"/reference/classify.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify GRaster cell values — classify,GRaster-method","title":"Classify GRaster cell values — classify,GRaster-method","text":"function classifies raster cells values within given range assigned new value. subst() function simpler method replacing specific values category levels.","code":""},{"path":"/reference/classify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify GRaster cell values — classify,GRaster-method","text":"","code":"# S4 method for class 'GRaster' classify(x, rcl, include.lowest = FALSE, right = TRUE, others = NULL)"},{"path":"/reference/classify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify GRaster cell values — classify,GRaster-method","text":"x GRaster. rcl Reclassification system: single integer: Number \"bins\" divide values. Arguments include.lowest right apply. vector numeric values: Breakpoints bins divide values. sorted lowest highest classification. Arguments include.lowest right apply. 2-column matrix, data.frame, data.table: first column provides specific values x replaced, second provides values replaced . method useful classifying integer GRasters. Arguments include.lowest right ignored. Cells classified order values listed first column. 3-column matrix, data.frame, data.table: first column provides lower value bin, second upper value, third value assign cells bin. Arguments include.lowest right apply. Cells classified order intervals listed (intervals sorted). include.lowest, right Logical: arguments determine cells values exactly equal lower upper ends interval classified. include.lowest = TRUE right = TRUE: intervals \"left-open, right-closed\" except lowest interval, \"left-closed/right-closed\". include.lowest = FALSE right = FALSE: Intervals \"left-closed/right-open\". Cells values equal highest higher boundary reclassified. include.lowest = TRUE right = FALSE: intervals \"left-closed/right-open\", except highest interval, \"right-closed/left-closed\". right = NA: useful classifying integer GRasters. intervals \"left-closed/right-closed\". easier accounting \"open\" intervals dealing integers. Argument include.lowest ignored. others Integer NULL (default), NA: Value assign cells fall set intervals. Cells NA values reclassified. Setting others equal NULL NA replaces values NA. value coerced integer value.","code":""},{"path":"/reference/classify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify GRaster cell values — classify,GRaster-method","text":"GRaster. raster categorical raster original values continuous (.e., single- double-precision raster), type \"integer\" input integer.","code":""},{"path":[]},{"path":"/reference/classify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify GRaster cell values — classify,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Classify using a scalar indicating number of bins scalar <- classify(elev, 5) scalar levels(scalar)  # Classify using a vector, indicating bin break points vector <- classify(elev, rcl = c(0, 100, 200, 300, 400, 500, 600)) vector levels(vector)  # Classify using a 2-column matrix (only valid for integer rasters) rcl <- data.frame(is = c(1:3, 5, 10), becomes = c(100:102, 105, 110)) twoCol <- classify(elev, rcl = rcl) twoCol  # Classify using a 3-column table rcl <- data.frame(    from = c(0, 100, 200, 300, 400, 500),    to = c(100, 200, 300, 400, 500, 600),    becomes = c(1, 2, 3, 10, 12, 15) ) threeCol <- classify(elev, rcl = rcl) threeCol levels(threeCol)  # Convert all values outside range to NA (default) rcl <- c(100, 200, 300) v1 <- classify(elev, rcl = rcl) v1 plot(v1)  # Convert all values outside range to -1 rcl <- c(100, 200, 300) v2 <- classify(elev, rcl = rcl, others = -1) v2 plot(v2)  # Left-open/right-closed (default) # Cells with a value of 1 are converted to the \"others\" value because # they are not \"inside\" the bins of `rcl`. minmax(elev) # note min/max values rcl <- c(1, 200, 570) v3 <- classify(elev, rcl = rcl, others = 10) levels(v3) plot(v3)  # Left-closed/right-open # Cells with a value of 570 are converted to the \"others\" value because # they are not \"inside\" the bins of `rcl`. There is only 1 cell with a # value of 570, so it probably won't be visible when plotted. minmax(elev) # note min/max values rcl <- c(1, 200, 570) v4 <- classify(elev, rcl = rcl, others = 10, right = FALSE) levels(v4)  # Left-open except for lowest bin/right-closed # All values will be in bins, and none assigned to \"others\". minmax(elev) # note min/max values rcl <- c(1, 200, 570) v5 <- classify(elev, rcl = rcl, others = 10, include.lowest = TRUE) v5 <- droplevels(v5) levels(v5)  # Left-closed/right-open except for highest bin # All values will be in bins, and none assigned to \"others\". minmax(elev) # note min/max values rcl <- c(1, 200, 570) v6 <- classify(elev, rcl = rcl, others = 10,    right = FALSE, include.lowest = TRUE) v6 <- droplevels(v6) levels(v6)  }"},{"path":"/reference/clump.html","id":null,"dir":"Reference","previous_headings":"","what":"Group adjacent cells with similar values — clump,GRaster-method","title":"Group adjacent cells with similar values — clump,GRaster-method","text":"clump() identifies groups adjacent cells value approximate value, assigns unique number, creating \"clumps\" - similar-valued cells.","code":""},{"path":"/reference/clump.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group adjacent cells with similar values — clump,GRaster-method","text":"","code":"# S4 method for class 'GRaster' clump(x, minDiff = 0, minClumpSize = 1, diagonal = TRUE)"},{"path":"/reference/clump.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group adjacent cells with similar values — clump,GRaster-method","text":"x GRaster. minDiff Numeric range [0, 1): Minimum difference cells order assigned clump. proportion range across cells. example, minDiff set 0.01, maximum difference cells clump can 1% entire range across cells. Small values can create large clumps. default 0, case values exactly . minClumpSize Numeric integer >= 1. Minimum number cells clump. default 1. diagonal Logical: TRUE (default), cells \"connected\" corners included part clump.","code":""},{"path":"/reference/clump.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group adjacent cells with similar values — clump,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/clump.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group adjacent cells with similar values — clump,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Find clumps based on exact values. This will appear as a gradient because # most cells are assigned to a group of 1 cell. exact <- clump(elev) plot(exact)  # Clump based on approximate values: approx <- clump(elev, minDiff = 0.0075) plot(approx)  # Clump based on approximate values with minimum clump size # (this can take a minute or two): approx20 <- clump(elev, minDiff = 0.005, minClumpSize = 20) plot(approx20)  approx approx20  }"},{"path":"/reference/clusterPoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify clusters of points — clusterPoints,GVector-method","title":"Identify clusters of points — clusterPoints,GVector-method","text":"clusterPoints() partitions points \"points\" GVector clusters.","code":""},{"path":"/reference/clusterPoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify clusters of points — clusterPoints,GVector-method","text":"","code":"# S4 method for class 'GVector' clusterPoints(x, method = \"DBSCAN\", minIn = NULL, maxDist = NULL)"},{"path":"/reference/clusterPoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify clusters of points — clusterPoints,GVector-method","text":"x \"points\" GVector. method Character: Method used identify clusters. Explanations methods provided help page GRASS module https://grass.osgeo.org/grass84/manuals/v.cluster.html. \"DBSCAN\" (default): Density-Based Spatial Clustering Applications Noise. \"DBSCAN2\": modification DBSCAN. \"density\": Cluster points relative density. \"OPTICS\": Ordering Points Identify Clustering Structure \"OPTICS2\": modification OPTICS. Case ignored, partial matching used. minIn Integer, numeric integer, NULL (default): Minimum number points cluster. NULL, minIn set 3 2-dimensional vector 4 3-dimensional vector. maxDist Numeric NULL (default): Maximum distance neighboring points cluster DBSCAN, DBSCAN2, OPTICS. NULL, maximum distance set 99th quantile observed pairwise distances points.","code":""},{"path":"/reference/clusterPoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify clusters of points — clusterPoints,GVector-method","text":"vector integers indicating cluster point belongs.","code":""},{"path":"/reference/colbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Add columns to the data table of a GVector — colbind,GVector-method","title":"Add columns to the data table of a GVector — colbind,GVector-method","text":"colbind() adds columns data table GVector. can combine multiple GVector's data table data.frames, data.tables, matrices, data table(s) GVector(s). combine two GVectors, see rbind().","code":""},{"path":"/reference/colbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add columns to the data table of a GVector — colbind,GVector-method","text":"","code":"# S4 method for class 'GVector' colbind(x, ...)"},{"path":"/reference/colbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add columns to the data table of a GVector — colbind,GVector-method","text":"x, ... first argument must GVector. Subsequent arguments can data.frames, data.tables, matrices, GVectors. data tables subsequent GVectors added table x; geometries ignored.","code":""},{"path":"/reference/colbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add columns to the data table of a GVector — colbind,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/colbind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add columns to the data table of a GVector — colbind,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Rivers vector madRivers <- fastData(\"madRivers\")  # Convert sf to a GVector rivers <- fast(madRivers)  # Convert GVector to data.frame or data.table as.data.frame(rivers) as.data.table(rivers)  # Subset rivers vector rivers1 <- rivers[1:2] rivers2 <- rivers[10:11]  # Concatenate rivers riversCombo <- rbind(rivers1, rivers2) riversCombo  # Add columns newCol <- data.frame(new = 1:11) riversCol <- colbind(rivers, newCol) riversCol  # Remove table riversCopy <- rivers riversCopy # has data table riversCopy <- dropTable(riversCopy) riversCopy # no data table  # Add a new table newTable <- data.frame(num = 1:11, letters = letters[1:11]) addTable(riversCopy) <- newTable riversCopy  }"},{"path":"/reference/combineCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","title":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","text":"function takes 2 10 integer categorical (factor) GRasters creates single GRaster one value per combination values inputs. example, say two input rasters, values 1 2 one raster, 3 4 . following combinations values occurred two rasters, output raster re-coded new values: argument na.rm set TRUE (, default), whenever least one cell NA value, output also NA (.e., new category number created). However, na.rm FALSE, combinations include NA assigned new category number, unless values NA (case output NA). difference function combineLevels() one creates \"combined\" GRaster combined levels table, whereas combineLevels() just merges levels tables. inputs categorical rasters, levels() table also returned new levels.","code":""},{"path":"/reference/combineCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","text":"","code":"# S4 method for class 'GRaster' combineCats(x, ..., na.rm = TRUE)"},{"path":"/reference/combineCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","text":"x GRaster one layers, must cells represent integers categories (factors). ... Either missing integer/categorical (factor) GRasters. na.rm Logical: TRUE (default), combinations include NA cell result NA cell output.","code":""},{"path":"/reference/combineCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","text":"GRaster. inputs categorical (factor) rasters, levels table also returned new combined levels.","code":""},{"path":[]},{"path":"/reference/combineCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine values/categories of multiple GRasters into a single GRaster — combineCats,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/combineLevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","title":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","text":"function creates single \"levels\" table levels tables one categorical GRasters. difference function combineCats() combineCats() creates \"combined\" GRaster combined levels table, whereas one just merges levels tables.","code":""},{"path":"/reference/combineLevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","text":"","code":"# S4 method for class 'GRaster' combineLevels(x, ...)  # S4 method for class 'list' combineLevels(x, ...)"},{"path":"/reference/combineLevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","text":"x GRaster list GRasters. ... Arguments pass data.table::merge().","code":""},{"path":"/reference/combineLevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","text":"list \"levels\" table (data.frame data.table), active category number new table. Following terra::activeCat(), number offset 1, value 1 indicates second column table used category labels, value 2 indicates third column used, .","code":""},{"path":[]},{"path":"/reference/combineLevels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine levels table from multiple categorical GRasters — combineLevels,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/compareGeom.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if GRasters and/or GVectors are geographically comparable — compareGeom,GRaster,GRaster-method","title":"Determine if GRasters and/or GVectors are geographically comparable — compareGeom,GRaster,GRaster-method","text":"compareGeom() compares geographic metadata two GRasters /GVectors. many cases, spatial objects must comparable \"interact\" (e.g., conducting arithmetic operations, masking, etc.).","code":""},{"path":"/reference/compareGeom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if GRasters and/or GVectors are geographically comparable — compareGeom,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' compareGeom(   x,   y,   ...,   location = TRUE,   mapset = TRUE,   topo = TRUE,   lyrs = FALSE,   crs = TRUE,   ext = TRUE,   zext = TRUE,   rowcol = TRUE,   depths = TRUE,   res = TRUE,   zres = TRUE,   stopOnError = TRUE,   messages = TRUE )  # S4 method for class 'GVector,GVector' compareGeom(   x,   y,   ...,   location = TRUE,   mapset = TRUE,   topo = FALSE,   crs = TRUE,   ext = FALSE,   zext = FALSE,   geometry = FALSE,   stopOnError = TRUE,   messages = TRUE )  # S4 method for class 'GRaster,GVector' compareGeom(   x,   y,   ...,   location = TRUE,   mapset = TRUE,   topo = FALSE,   crs = TRUE,   ext = FALSE,   zext = FALSE,   stopOnError = TRUE,   messages = TRUE )  # S4 method for class 'GVector,GRaster' compareGeom(   x,   y,   ...,   location = TRUE,   mapset = TRUE,   topo = FALSE,   crs = TRUE,   ext = FALSE,   zext = FALSE,   stopOnError = TRUE,   messages = TRUE )"},{"path":"/reference/compareGeom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if GRasters and/or GVectors are geographically comparable — compareGeom,GRaster,GRaster-method","text":"x, y, ... GRasters GVectors. y GRaster, ... must also GRasters (missing). y GVector, ... must also GVectors (missing). location, mapset Logical: Compare GRASS \"locations\" \"mapsets\". Default TRUE. topo Logical: Test topology (2D 3D). default, TRUE raster-raster comparisons, FALSE others. lyrs Logical (rasters ): Compare number layers \"stacked\" rasters. Note different number vertical \"depths\" raster. Default FALSE. crs Logical: Compare coordinate reference systems. Default TRUE. ext Logical: TRUE, test extent. default, TRUE raster-raster comparison FALSE others. zext Logical: Test vertical extents (3D ). default, TRUE raster-raster comparisons, FALSE others. rowcol Logical (rasters ): Test number rows columns. Default TRUE. depths Logical (rasters ): Test number depths. Default TRUE. res Logical (rasters ): Test resolution x- y-dimensions. Default TRUE. zres Logical (rasters ): Test resolution z dimension. Default TRUE. stopOnError Logical: TRUE (default), throw error explanation objects comparable. FALSE (default), return TRUE FALSE. messages Logical: TRUE (default), display warning condition met. comes effect stopOnErrorisFALSE`. geometry Logical (vector-vector comparison ): Compare geometry. Default FALSE.","code":""},{"path":"/reference/compareGeom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if GRasters and/or GVectors are geographically comparable — compareGeom,GRaster,GRaster-method","text":"Logical (invisibly): TRUE mismatches detected, FALSE incompatibility), side effect throwing error.","code":""},{"path":"/reference/complete.cases.html","id":null,"dir":"Reference","previous_headings":"","what":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","title":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","text":"applied categorical GRaster, compete.cases() returns TRUE row \"levels\" table NAs . contrast, missing.cases() returns TRUE row least one NA . raster categorical, NA returned. applied GVector data table, complete.cases() returns TRUE row NAs. GVector data table, vector TRUE values length total number geometries returned. contrast, missing.cases() returns TRUE every row least one NA . GVector data table, vector FALSE values returned.","code":""},{"path":"/reference/complete.cases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","text":"","code":"# S4 method for class 'GRaster' complete.cases(..., levels = TRUE)  # S4 method for class 'GVector' complete.cases(...)  # S4 method for class 'GRaster' missing.cases(..., levels = TRUE)  # S4 method for class 'GVector' missing.cases(...)"},{"path":"/reference/complete.cases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","text":"... GRaster GVector. levels Logical (GRasters ): TRUE (default), assess \"value\" activeCat() columns levels table (see levels()). FALSE, assess columns (see cats()).","code":""},{"path":"/reference/complete.cases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","text":"complete.cases() missing.cases() return type object. output depends input: categorical GRaster just one layer: logical vector. integer, float, double GRaster just one layer: NA. GRaster multiple layers: list one element per layer either logical vectors NAs, per . GVector data table: logical vector. GVector without data table: NA.","code":""},{"path":[]},{"path":"/reference/complete.cases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rows of a GRaster or GVector's table that have no NAs or that have NAs — complete.cases,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Plant specimens (points) and land cover madDypsis <- fastData(\"madDypsis\") madCover <- fastData(\"madCover\")  # Convert to GVector and GRaster dypsis <- fast(madDypsis) cover <- fast(madCover)  levels(cover)  ### GVector  # Look at the data table: as.data.table(dypsis)  # Which rows have no NAs? complete.cases(dypsis)  # Which rows have at least one NA (opposite of above)? missing.cases(dypsis)  ### GRaster  # Look at the levels table: levels(cover)  # Which rows of levels table have no NAs? complete.cases(cover)  # Which rows have at least one NA (opposite of above)? missing.cases(cover)  }"},{"path":"/reference/compositeRGB.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","title":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","text":"function takes arguments three rasters typically representing red, green, blue color bands, returns single raster values based combination. Typically, raster plotted grayscale.","code":""},{"path":"/reference/compositeRGB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","text":"","code":"# S4 method for class 'GRaster' compositeRGB(r, g = NULL, b = NULL, levels = 256, dither = FALSE)"},{"path":"/reference/compositeRGB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","text":"r, g, b Either: One GRaster one band r, g, b representing red, green, blue color bands; r  single GRaster 3 bands (R, G, B bands), g b NULL. levels Either single value integer, vector integers: Number levels red, green, blue intensities represented r, g, b. single value supplied, assumed three number levels. three values supplied, correspond R, G, B bands. default 256 (assume R, G, B rasters values 0 255). dither Logical: TRUE, apply Floyd-Steinberg dithering. Default FALSE.","code":""},{"path":"/reference/compositeRGB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/compositeRGB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine red, green, and blue color bands to make a composite GRaster — compositeRGB,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") # elevation raster madLANDSAT <- fastData(\"madLANDSAT\") # multi-layer raster madRivers <- fastData(\"madRivers\") # lines vector  # Convert SpatRaster to GRaster and SpatVector to GVector elev <- fast(madElev) rivers <- fast(madRivers) landsat <- fast(madLANDSAT)  # Plot: plot(elev) plot(rivers, add = TRUE)  # Histograms: hist(elev) hist(landsat)  # Plot surface reflectance in RGB: plotRGB(landsat, 3, 2, 1) # \"natural\" color plotRGB(landsat, 4, 1, 2, stretch = \"lin\") # emphasize near-infrared (vegetation)  # Make composite map from RGB layers and plot in grayscale: comp <- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]]) grays <- paste0(\"gray\", 0:100) plot(comp, col = grays)  }"},{"path":"/reference/connectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","title":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","text":"connectors() creates lines GVector represent shortest (Great Circle) paths feature one GVector nearest feature another GVector.","code":""},{"path":"/reference/connectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","text":"","code":"# S4 method for class 'GVector,GVector' connectors(x, y, minDist = NULL, maxDist = NULL)"},{"path":"/reference/connectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","text":"x, y GVectors. minDist, maxDist Either NULL (default) numeric values: Ignore features separated less greater distances.","code":""},{"path":"/reference/connectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/connectors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create lines connecting nearest features of two GVectors — connectors,GVector,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Rivers vector and locations of Dypsis plants madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf's to GVectors: rivers <- fast(madRivers) dypsis <- fast(madDypsis)  ### Connections from each point to nearest river consFromDypsis <- connectors(dypsis, rivers)  plot(rivers, col = \"blue\") plot(dypsis, add = TRUE) plot(consFromDypsis, col = \"red\", add = TRUE)  ### Connections from each river to nearest point consFromRivers <- connectors(rivers, dypsis)  plot(rivers, col = \"blue\") plot(dypsis, add = TRUE) plot(consFromRivers, col = \"red\", add = TRUE)  }"},{"path":"/reference/convHull.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum convex hull around a spatial vector — convHull,GVector-method","title":"Minimum convex hull around a spatial vector — convHull,GVector-method","text":"Create minimum convex hull around spatial vector.","code":""},{"path":"/reference/convHull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum convex hull around a spatial vector — convHull,GVector-method","text":"","code":"# S4 method for class 'GVector' convHull(x, by = \"\")"},{"path":"/reference/convHull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum convex hull around a spatial vector — convHull,GVector-method","text":"x GVector. Character: \"\" (default), convex hull created geometries together. Otherwise, name field vector. Hulls created set geometries value column.","code":""},{"path":"/reference/convHull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum convex hull around a spatial vector — convHull,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/convHull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum convex hull around a spatial vector — convHull,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Points vector of specimens of species in the plant genus Dypsis madDypsis <- fastData(\"madDypsis\")  # Convert sf to a GVector: dypsis <- fast(madDypsis)  ### Convex hull for all plant specimens together: ch <- convHull(dypsis)  ### Convex hull for each species: head(dypsis) # See the \"rightsHolder\" column? chHolder <- convHull(dypsis, by = \"rightsHolder\")  ### Plot: plot(dypsis) plot(ch, add = TRUE) n <- length(chHolder) for (i in 1:n) {    plot(chHolder[[i]], border = i, add = TRUE) }  }"},{"path":"/reference/copyGSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a copy of an object in GRASS — .copyGSpatial,GRaster-method","title":"Make a copy of an object in GRASS — .copyGSpatial,GRaster-method","text":"Create copy GRaster GVector GRASS.  function used internally little use users.  creates copy object GRASS session–make GRaster GVector, .makeGRaster() .makeGVector() need called making copy. Note object multi-layered, copy made layer.","code":""},{"path":"/reference/copyGSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a copy of an object in GRASS — .copyGSpatial,GRaster-method","text":"","code":"# S4 method for class 'GRaster' .copyGSpatial(x, reshapeRegion = TRUE)  # S4 method for class 'GVector' .copyGSpatial(x)  # S4 method for class 'character' .copyGSpatial(x, type = NULL, topo = NULL, reshapeRegion = TRUE)  .copyGRaster(x, topo = \"2D\", reshapeRegion = TRUE)  .copyGVector(x)"},{"path":"/reference/copyGSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a copy of an object in GRASS — .copyGSpatial,GRaster-method","text":"x GVector sources() name one. reshapeRegion Logical. TRUE, x must GRaster. type Character NULL (default): Either \"raster\" \"vector\". character, must one per value x. NULL, attempt auto-detect (takes longer). topo \"2D\" \"3D\"","code":""},{"path":"/reference/copyGSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a copy of an object in GRASS — .copyGSpatial,GRaster-method","text":"Character vector representing sources() names copied object(s), plus makes copy given object(s) GRASS. sources() names copied rasters.","code":""},{"path":"/reference/crds.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinates of a vector","title":"Coordinates of a vector","text":"Returns coordinates center cells GRaster coordinates GVector's vertices. output matrix, data.frame, list. want output \"points\" GVector, use .points().","code":""},{"path":"/reference/crds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinates of a vector","text":"","code":"# S4 method for class 'GRaster' crds(x, z = is.3d(x), na.rm = TRUE)  # S4 method for class 'GVector' crds(x, z = is.3d(x))  st_coordinates(x)"},{"path":"/reference/crds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinates of a vector","text":"x GVector GRaster. z TRUE (default), return x-, y-, z-coordinates. FALSE, just return x- y-coordinates. 2-dimensional objects, z-coordinates 0. na.rm Logical: TRUE, remove cells NA (GRasters ).","code":""},{"path":"/reference/crds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coordinates of a vector","text":"matrix, data.frame, list.","code":""},{"path":[]},{"path":"/reference/crds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinates of a vector","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Plant specimens (points), elevation (raster) madDypsis <- fastData(\"madDypsis\") madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster, and sf to a GVector dypsis <- fast(madDypsis) elev <- fast(madElev)  ### Get coordinates: dypsisPoints <- crds(dypsis) elevPoints <- crds(elev)  head(dypsisPoints) head(elevPoints)  }"},{"path":"/reference/crop.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove parts of a GRaster or GVector — crop,GRaster-method","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"crop() removes parts GRaster GVector fall \"outside\" another raster vector. make GRaster GVector larger already (see extend()). Rasters may cropped exact extent, extent enlarged encompass integer number cells. wish remove certain cells raster, see mask().","code":""},{"path":"/reference/crop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"","code":"# S4 method for class 'GRaster' crop(x, y, fail = TRUE)  # S4 method for class 'GVector' crop(x, y, extent = FALSE, fail = TRUE)"},{"path":"/reference/crop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"x GRaster GVector cropped. y GRaster GVector serve template cropping. fail Logical: TRUE (default), cropped object zero extent least one dimension, exit function error. FALSE, display warning return NULL. extent Logical: y \"points\" GVector: Use convex hull around y crop x. y \"lines\" \"polygons\" GVector: TRUE, use extent y crop x.","code":""},{"path":"/reference/crop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"GRaster GVector (NULL fail FALSE output zero east-west /north-south extent).","code":""},{"path":"/reference/crop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"Known differences terra::crop(): x y \"points\" vectors, extent TRUE, terra removes points fall extent boundary. fasterRaster remove points extent boundary. x \"points\" vector y \"lines\" vectors, extent FALSE, terra uses extent y crop points.  fasterRaster uses minimum convex hull lines vector.","code":""},{"path":[]},{"path":"/reference/crop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove parts of a GRaster or GVector — crop,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, plant specimen collections, rivers vector, # outline of area vector madElev <- fastData(\"madElev\") madDypsis <- fastData(\"madDypsis\") madRivers <- fastData(\"madRivers\") madCoast4 <- fastData(\"madCoast4\") madAnt <- madCoast4[madCoast4$NAME_4 == \"Antanambe\", ]  # Convert to fasterRaster format: elev <- fast(madElev) dypsis <- fast(madDypsis) rivers <- fast(madRivers) coast <- fast(madCoast4) ant <- fast(madAnt)  ### Crop raster by vector: rastByVect <- crop(elev, ant) plot(elev, col = \"gray\", legend = FALSE) plot(rastByVect, add = TRUE) plot(ant, add = TRUE)  ### Crop raster by raster: # To illustrate, we'll make the SpatRaster smaller in R, then crop the # raster by this. templateRast <- crop(madElev, madAnt)  template <- fast(templateRast) rastByRast <- crop(elev, template)  plot(elev, col = \"gray\", legend = FALSE) plot(rastByRast, add = TRUE)  ### Crop vector by raster: # To illustrate, we'll make the SpatRaster smaller in R, then crop the # raster by this. templateRast <- crop(madElev, madAnt)  template <- fast(templateRast) ptsByRast <- crop(dypsis, template)  plot(elev, col = \"gray\", legend = FALSE) plot(templateRast, add = TRUE) plot(dypsis, add = TRUE) plot(ptsByRast, pch = 21, bg = \"red\", add = TRUE)  ### Crop vector by vector: ptsSubset <- dypsis[1:10] # use first 10 points as cropping template  # Crop points vector by convex hull around points: ptsByPts <- crop(dypsis, ptsSubset) plot(dypsis) plot(convHull(ptsSubset), lty = \"dotted\", border = \"blue\", add = TRUE) plot(ptsByPts, col = \"red\", add = TRUE) plot(ptsSubset, col = \"blue\", pch = 3, cex = 1.6, add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Selected\", \"Crop template\", \"Convex hull\"),     pch = c(16, 16, 3, NA),     lwd = c(NA, NA, NA, 1),     col = c(\"black\", \"red\", \"blue\", \"blue\"),     lty = c(NA, NA, NA, \"dotted\"),     xpd = NA,     bg = \"white\" )  # Crop points vector by extent of points: ptsByPts <- crop(dypsis, ptsSubset, ext = TRUE) plot(dypsis) plot(ptsByPts, col = \"red\", add = TRUE) plot(ptsSubset, col = \"blue\", pch = 3, cex = 1.6, add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Selected\", \"Crop template\"),     pch = c(16, 16, 3),     lwd = c(NA, NA, NA),     col = c(\"black\", \"red\", \"blue\"),     lty = c(NA, NA, NA),     xpd = NA,     bg = \"white\" )  # Crop points vector by convex hull around lines: ptsByPts <- crop(dypsis, rivers) plot(rivers, col = \"blue\", pch = 3, cex = 1.6) plot(dypsis, add = TRUE) plot(convHull(rivers), lty = \"dotted\", border = \"blue\", add = TRUE) plot(ptsByPts, col = \"red\", add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Selected\", \"Rivers\", \"Convex hull\"),     pch = c(16, 16, NA, NA),     lwd = c(NA, NA, 1, 1),     col = c(\"black\", \"red\", \"blue\", \"blue\"),     lty = c(NA, NA, \"solid\", \"dotted\"),     xpd = NA,     bg = \"white\" )  # Crop points vector by extent of lines: ptsByPts <- crop(dypsis, rivers, ext = TRUE) plot(rivers, col = \"blue\", pch = 3, cex = 1.6) plot(dypsis, add = TRUE) plot(convHull(rivers), lty = \"dotted\", border = \"blue\", add = TRUE) plot(ptsByPts, col = \"red\", add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Selected\", \"Rivers\"),     pch = c(16, 16, NA),     lwd = c(NA, NA, 1),     col = c(\"black\", \"red\", \"blue\"),     lty = c(NA, NA, \"solid\"),     xpd = NA,     bg = \"white\" )  # Crop points vector by polygon: ptsByPts <- crop(dypsis, ant) plot(dypsis) plot(ant, border = \"blue\", pch = 3, cex = 1.6, add = TRUE) plot(ptsByPts, col = \"red\", add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Selected\", \"Antanambe\"),     pch = c(16, 16, NA),     lwd = c(NA, NA, 1),     col = c(\"black\", \"red\", \"blue\"),     lty = c(NA, NA, \"solid\"),     xpd = NA,     bg = \"white\" )  # Crop lines vector by polygon: linesByPoly <- crop(rivers, ant) plot(rivers) plot(ant, border = \"blue\", pch = 3, cex = 1.6, add = TRUE) plot(linesByPoly, col = \"red\", add = TRUE) legend(\"topleft\",     legend = c(\"Rivers\", \"Selected\", \"Antanambe\"),     col = c(\"black\", \"red\", \"blue\"),     lwd = 1,     xpd = NA,     bg = \"white\" )  # Crop polygon vector by convex hull around points: polyByPoints <- crop(ant, dypsis) plot(dypsis, col = \"red\") plot(ant, border = \"blue\", add = TRUE) plot(polyByPoints, border = \"red\", add = TRUE) legend(\"topleft\",     legend = c(\"Dypsis\", \"Antanambe\", \"Selected\"),     col = c(\"red\", \"blue\", \"red\"),     pch = c(16, NA, NA),     lwd = c(NA, 1, 1),     xpd = NA,     bg = \"white\" )  }"},{"path":"/reference/crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Coordinate reference system of a GRaster or GVector — crs,missing-method","title":"Coordinate reference system of a GRaster or GVector — crs,missing-method","text":"Get coordinate reference system (CRS) GLocation object, contain (especially GRasters GVectors), currently active GRASS location.","code":""},{"path":"/reference/crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coordinate reference system of a GRaster or GVector — crs,missing-method","text":"","code":"# S4 method for class 'missing' crs(x)  # S4 method for class 'GLocation' crs(x)  # S4 method for class 'missing' st_crs(x, ...)  # S4 method for class 'GLocation' st_crs(x, ...)  st_crs(x, ...)"},{"path":"/reference/crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coordinate reference system of a GRaster or GVector — crs,missing-method","text":"x object inherits GLocation (.e., GRaster GVector) missing. missing, coordinate reference system currently active GRASS location reported. ... arguments (generally unused).","code":""},{"path":"/reference/crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coordinate reference system of a GRaster or GVector — crs,missing-method","text":"Character.","code":""},{"path":[]},{"path":"/reference/crs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coordinate reference system of a GRaster or GVector — crs,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/datatype.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","title":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","text":"GRasters, datatype() returns data type. GVectors, datatype() returns class column attribute table.","code":""},{"path":"/reference/datatype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","text":"","code":"# S4 method for class 'GRaster' datatype(x, type = \"fasterRaster\", forceDouble = TRUE)  # S4 method for class 'GVector' datatype(x)"},{"path":"/reference/datatype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","text":"x GRaster GVector. type (GRasters ) NULL character: Type datatype report (GRaster ): \"fasterRaster\" (default): Reports fasterRaster type (factor, integer, float, double) \"terra\": Report (inferred) terra data type (e.g., INT2U, FLT4S). Please see table tutorial raster data types information. \"GRASS\": return \"CELL\" (integer), \"FCELL\" (floating-point value), \"DCELL\" (double-floating point value) \"GDAL\": See GDAL: Raster Band. Please also see table tutorial raster data types. forceDouble Logical (GRasters SpatRasters ): TRUE (default), raster appears represent non-integer values, raster assumed represent double-floating point values (GRASS: type \"DCELL\", terra: type \"FLT8S\", fasterRaster: type \"double\", GDAL: type \"Float64\"). forceDouble reports actual datatype type = \"fasterRaster\" (.e., type forced \"double\").","code":""},{"path":"/reference/datatype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","text":"datatype() GRaster returns character. datatype() GVector returns data frame, one row per field. GVector attribute table, function returns NULL.","code":""},{"path":[]},{"path":"/reference/datatype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the datatype of a GRaster or of GVector columns — datatype,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/delaunay.html","id":null,"dir":"Reference","previous_headings":"","what":"Delaunay triangulation for points — delaunay,GVector-method","title":"Delaunay triangulation for points — delaunay,GVector-method","text":"function creates Delaunay triangulation \"points\" GVector.","code":""},{"path":"/reference/delaunay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delaunay triangulation for points — delaunay,GVector-method","text":"","code":"# S4 method for class 'GVector' delaunay(x)"},{"path":"/reference/delaunay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delaunay triangulation for points — delaunay,GVector-method","text":"x GVector \"points\" object.","code":""},{"path":"/reference/delaunay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delaunay triangulation for points — delaunay,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/delaunay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delaunay triangulation for points — delaunay,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example vectors madDypsis <- fastData(\"madDypsis\") # points madCoast4 <- fastData(\"madCoast4\") # polygons  # Convert sf vectors to GVectors dypsis <- fast(madDypsis) coast4 <- fast(madCoast4) ant <- coast4[coast4$NAME_4 == \"Antanambe\"]  # Delaunay triangulation dypsisDel <- delaunay(dypsis) plot(dypsisDel) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Voronoi tessellation vor <- voronoi(dypsis) plot(vor) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Random Voronoi tessellation rand <- rvoronoi(coast4, size = 100) plot(rand)  }"},{"path":"/reference/denoise.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove or retain ","title":"Remove or retain ","text":"denoise() applies principal component analysis (PCA) layers GRaster, uses PCA predict values back raster. retains coarse-scale trends, thereby removing \"noise\" (locally extreme values fall far PC axis). noise() opposite first constructing PCA, predicting values back raster, subtracting values original, removing coarse-scale trends thereby leaving \"noise\".","code":""},{"path":"/reference/denoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove or retain ","text":"","code":"# S4 method for class 'GRaster' denoise(x, scale = FALSE, percent = 80)  # S4 method for class 'GRaster' noise(x, scale = FALSE, percent = 80)"},{"path":"/reference/denoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove or retain ","text":"x GRaster two layers. scale Logical: TRUE, input layers rescaled dividing layer overall population standard deviation. Note rasters always centered (mean subtracted values). Centering scaling recommended rasters values different units. default FALSE (scale). percent Numeric integer integer range 50 99 (default 80): Minimum total variation explained retained PC axes. Higher values cause denoise() remove less noise, noise() return less noise. value low retain even one axis, function fail message effect.","code":""},{"path":"/reference/denoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove or retain ","text":"multi-layer GRaster one layer per input.","code":""},{"path":[]},{"path":"/reference/denoise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove or retain ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Climate raster: madChelsa <- fastData(\"madChelsa\")  # Convert a SpatRaster to a GRaster: chelsa <- fast(madChelsa)  ### Denoise: quiet <- denoise(chelsa, scale = TRUE)  compare1 <- c(chelsa[[\"bio1\"]], quiet[[\"bio1\"]]) plot(compare1)  compare2 <- c(chelsa[[\"bio7\"]], quiet[[\"bio7\"]]) plot(compare2)  ### Noise: loud <- noise(chelsa, scale = TRUE)  compare1 <- c(chelsa[[\"bio1\"]], loud[[\"bio1\"]]) plot(compare1)  compare2 <- c(chelsa[[\"bio7\"]], loud[[\"bio7\"]]) plot(compare2)  }"},{"path":"/reference/dim.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","title":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","text":"GRegions: Number rows, columns, depths, cells: dim(): Rows columns dim3d(): Rows, columns, depths nrow(): Rows ncol(): Columns ndepth(): Depths (3-dimensional rasters ) ncell(): Number cells (2 dimensions) ncell3d(): Number cells (3 dimensions) GRasters: , plus number layers: nlyr(): Layers (number \"stacked\" rasters–different depths raster). GVectors: Number geometries fields (columns): dim(): Number geometries number columns data table nrow(): Number geometries ncol(): Number columns data table","code":""},{"path":"/reference/dim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","text":"","code":"# S4 method for class 'GRegion' dim(x)  # S4 method for class 'missing' dim3d(x)  # S4 method for class 'GRegion' dim3d(x)  # S4 method for class 'missing' nrow(x)  # S4 method for class 'GRegion' nrow(x)  # S4 method for class 'missing' ncol(x)  # S4 method for class 'GRegion' ncol(x)  # S4 method for class 'missing' ndepth(x)  # S4 method for class 'GRegion' ndepth(x)  # S4 method for class 'missing' ncell(x)  # S4 method for class 'GRegion' ncell(x)  # S4 method for class 'missing' ncell3d(x)  # S4 method for class 'GRegion' ncell3d(x)  # S4 method for class 'GVector' dim(x)  # S4 method for class 'GVector' nrow(x)  # S4 method for class 'GVector' ncol(x)  # S4 method for class 'missing' nlyr(x)  # S4 method for class 'GRaster' nlyr(x)"},{"path":"/reference/dim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","text":"x GRegion, GRaster, GVector, missing. missing, dimensions currently active region returned.","code":""},{"path":"/reference/dim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","text":"numeric value vector.","code":""},{"path":[]},{"path":"/reference/dim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of rows, columns, depths, cells, and layers — dim,GRegion-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/disagg.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","title":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","text":"GVectors can contain mix \"singlepart\" \"multipart\" features. singlepart feature single point, set connected line segments, polygon. multipart feature set lines, sets connected line segments, set polygons treated single feature. function converts multipart features singlepart features. GVector attribute table, rows duplicated new GVector's geometries rows correspond \"parent\" geometries. want \"split\" cells GRaster smaller cells, use aggregate().","code":""},{"path":"/reference/disagg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","text":"","code":"# S4 method for class 'GVector' disagg(x)"},{"path":"/reference/disagg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","text":"x GVector.","code":""},{"path":"/reference/disagg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/disagg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce as multipart GVector to a singlepart GVector — disagg,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madCoast4 <- fastData(\"madCoast4\")  ### aggregating a GRaster #########################  # Convert: elev <- fast(madElev)  ### Aggregate GRaster by same factor in 2 dimensions # fasterRaster agg2 <- aggregate(elev, 2, \"mean\") agg2  # terra agg2terra <- aggregate(madElev, 2, \"mean\") agg2terra  # Compare rasters aggregated by fasterRaster and terra. # These should be the same. agg2 <- rast(agg2) agg2 <- extend(agg2, agg2terra) agg2 - agg2terra  ### Aggregate GRaster by a non-integer factor in 2 dimensions # fasterRaster agg2.9 <- aggregate(elev, 2.9, \"mean\") agg2.9  # terra agg2.9terra <- aggregate(madElev, 2.9, \"mean\") agg2.9terra  # Compare rasters aggregated by fasterRaster and terra. # These should be different. res(agg2.9) res(agg2.9terra) # terra rounds aggregation factor down 2 * res(madElev) # original resolution multiplied by 2  ### Aggregate GRaster by different factor in 2 dimensions agg2x3 <- aggregate(elev, c(2, 3), \"mean\") agg2x3  ### aggregating a GVector #########################  madCoast4 <- fastData(\"madCoast4\")  # Convert: coast <- fast(madCoast4)  # Aggregate and disaggregate: aggCoast <- aggregate(coast) disaggCoast <- disagg(coast)  ngeom(coast) ngeom(aggCoast) ngeom(disaggCoast)  # plot oldpar <- par(mfrow = c(1, 3)) plot(coast, main = \"Original\", col = 1:nrow(coast)) plot(aggCoast, main = \"Aggregated\", col = 1:nrow(aggCoast)) plot(disaggCoast, main = \"Disaggregated\", col = 1:nrow(disaggCoast)) par(oldpar)  }"},{"path":"/reference/distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Geographic distance — distance,GRaster,missing-method","title":"Geographic distance — distance,GRaster,missing-method","text":"function produces raster matrix geographic distances, depending input: Case 1: Argument x GRaster y missing: default, function replaces values NA cells distance closest non-NA cell. Alternatively, non-NA cells can values replaced distance NA cells. can also specify cells (value) values replaced distance cells. Case 2: Argument x GRaster y GVector: cells raster value replaced distance nearest features GVector. Alternatively, calculate distance cell covered vector object nearest cell covered vector object. Note vector rasterized first. Case 3: Argument x GVector y GVector: matrix pairwise distances features one versus GVector returned. Case 4: Argument x GVector y missing: matrix pairwise distances features GVector returned.","code":""},{"path":"/reference/distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geographic distance — distance,GRaster,missing-method","text":"","code":"# S4 method for class 'GRaster,missing' distance(   x,   y,   target = NA,   fillNA = TRUE,   unit = \"meters\",   method = ifelse(is.lonlat(x), \"geodesic\", \"Euclidean\"),   minDist = NULL,   maxDist = NULL )  # S4 method for class 'GRaster,GVector' distance(   x,   y,   fillNA = TRUE,   thick = TRUE,   unit = \"meters\",   method = ifelse(is.lonlat(x), \"geodesic\", \"Euclidean\"),   minDist = NULL,   maxDist = NULL )  # S4 method for class 'GVector,GVector' distance(x, y, unit = \"meters\", minDist = NULL, maxDist = NULL)  # S4 method for class 'GVector,missing' distance(x, y, unit = \"meters\", minDist = NULL, maxDist = NULL)"},{"path":"/reference/distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geographic distance — distance,GRaster,missing-method","text":"x GRaster GVector. y Either missing, GVector. target Numeric: applicable case 1, x GRaster y missing.  NA (default), cells NAs values replaced distance nearest non-NA cell. another value, cells values values replaced distance cell (meaning, NA non-NA, except cells value). fillNA Logical: Determines raster cells fill distances. Case 1, x GRaster y missing: TRUE (default), fill values NA cells distances non-NA cells. FALSE, fill non-NA cells width distance NA cells. Case 2, x GRaster y GVector: TRUE (default), returned raster contain distance cell closest feature vector. FALSE, cells covered vector values replaced distance nearest cell covered, cells covered vector values 0. Case 3, x GVector y GVector: argument used case. unit Character: Units output. : \"meters\", \"metres\", \"m\" (default) \"kilometers\" \"km\" \"miles\" \"mi\" \"nautical miles\" \"nmi\" \"yards\" \"yd\" \"feet\" \"ft\" – international, 1 foot exactly equals 0.3048 meters Partial matching used case ignored. method Character: type distance calculate. Partial matching used capitalization ignored. Possible values include: Euclidean (default projected rasters): Euclidean distance. geodesic (default unprojected rasters): Geographic distance. x unprojected (e.g., WGS84 NAD83), method must \"geodesic\". squared: Squared Euclidean distance (faster just Euclidean distance rank–good cases order matters). maximum: Maximum Euclidean distance. Manhattan: Manhattan distance (.e., \"taxicab\" distance, distance along cells going north-south east-west never along diagonal). minDist, maxDist Either NULL (default) numeric values: Ignore distances less greater distances. thick Logical: applicable case 2, x GRaster y GVector. TRUE (default), vector represented \"thickened\" lines (.e., cell line/boundary touches, just ones rendering path).","code":""},{"path":"/reference/distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geographic distance — distance,GRaster,missing-method","text":"x GRaster, output GRaster. x GVector, output numeric vector.","code":""},{"path":[]},{"path":"/reference/distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geographic distance — distance,GRaster,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, rivers vector, locations of Dypsis plants madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert a SpatRaster to a GRaster, and sf to a GVector elev <- fast(madElev) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  ### case 1: GRaster by itself  # Distance between NA cells and nearest non-NA cells naDist <- distance(elev) names(naDist) <- \"NA Distance\" plot(naDist)  # Distance between non-NA cells and nearest NA cells nonNaDist <- distance(elev, fillNA = FALSE) names(nonNaDist) <- \"non-NA Distance\" plot(nonNaDist)  # Distance between cells with an elevation of 3 and any other cell that != 3 distFocal3 <- distance(elev, target = 3) names(distFocal3) <- \"Distance from 3\" plot(distFocal3)  # Distance between any cell and cells with a value of 3 distTo3 <- distance(elev, fillNA = FALSE, target = 3) names(distTo3) <- \"Distance to 3\" plot(distTo3)  ### Case 2: GRaster and GVector distToVect <- distance(elev, rivers)  plot(distToVect) plot(st_geometry(madRivers), add = TRUE)  ### Case 3: GVector vs GVector plot(st_geometry(madRivers)) plot(st_geometry(madDypsis), add = TRUE)  distToRivers <- distance(dypsis, rivers, unit = \"yd\") distToPlants <- distance(rivers, dypsis) distToRivers distToPlants  ### Case 4: GVector vs itself distToItself <- distance(dypsis) distToItself  }"},{"path":"/reference/dot-ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to get extent from a ","title":"Function to get extent from a ","text":"Function get extent \"sources\" name raster vector","code":""},{"path":"/reference/dot-ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to get extent from a ","text":"","code":".ext(x, rastOrVect = NULL)"},{"path":"/reference/dot-ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to get extent from a ","text":"x GRaster, GSpatial, character (sources() name GRaster GVector). rastOrVect Either NULL (class taken x, x character), \"raster\" \"vector\" (partial matching used).","code":""},{"path":"/reference/dot-ext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to get extent from a ","text":"numeric vector.","code":""},{"path":"/reference/dot-geomtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Get geometry type from the sources() name of a vector — .geomtype","title":"Get geometry type from the sources() name of a vector — .geomtype","text":"Get geometry type sources() name vector","code":""},{"path":"/reference/dot-geomtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get geometry type from the sources() name of a vector — .geomtype","text":"","code":".geomtype(x)"},{"path":"/reference/dot-geomtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get geometry type from the sources() name of a vector — .geomtype","text":"x GVector sources() name one.","code":""},{"path":"/reference/dot-geomtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get geometry type from the sources() name of a vector — .geomtype","text":"Character (\"point\", \"line\", \"area\"; .e., GRASS nomenclature).","code":""},{"path":"/reference/dot-layerIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index of raster layers — .layerIndex","title":"Get index of raster layers — .layerIndex","text":"Get index raster layers","code":""},{"path":"/reference/dot-layerIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index of raster layers — .layerIndex","text":"","code":".layerIndex(layer, x, recycle = TRUE)"},{"path":"/reference/dot-layerIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get index of raster layers — .layerIndex","text":"layer Integer, numeric, logical, character: Refers one layers. x GRaster. recycle Logical: TRUE (default), layer logical smaller number number layers, recycle vector layer.","code":""},{"path":"/reference/dot-layerIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get index of raster layers — .layerIndex","text":"integer vector.","code":""},{"path":"/reference/dot-makeGRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GRaster — .makeGRaster","title":"Create a GRaster — .makeGRaster","text":"Create GRaster raster existing current GRASS session.","code":""},{"path":"/reference/dot-makeGRaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GRaster — .makeGRaster","text":"","code":".makeGRaster(src, names = \"raster\", levels = \"\", ac = NULL, fail = TRUE)"},{"path":"/reference/dot-makeGRaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GRaster — .makeGRaster","text":"src Character (name raster **GRASS) rastInfo object. names Character: Name raster. levels NULL (default), data.frame, data.table, empty string (\"\"), list data.frames, data.tables, /empty strings: become raster's levels(). \"\", levels defined. ac vector numeric integer values >=1, NULL (default): Active category column (offset 1, 1 really means second column, 2 means third, etc.). value NULL uses automated procedure figure . fail Logical: TRUE (default), raster either 0 east-west north-south extent, exit function error. fail FALSE, display warning return NULL.","code":""},{"path":"/reference/dot-makeGRaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GRaster — .makeGRaster","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/dot-makeGRaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GRaster — .makeGRaster","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/dot-makeGVector.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GVector — .makeGVector","title":"Create a GVector — .makeGVector","text":"Create GVector vector existing current GRASS session.","code":""},{"path":"/reference/dot-makeGVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GVector — .makeGVector","text":"","code":".makeGVector(   src,   table = NULL,   build = TRUE,   extensive = FALSE,   cats = NULL,   fail = TRUE )"},{"path":"/reference/dot-makeGVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GVector — .makeGVector","text":"src Character: name vector GRASS. table data.table, data.frame, GVector table, character. can data.table(NULL) data.frame(NULL) table associated vector. character, interpreted name table GRASS. build Logical: TRUE (default), build topology using GRASS module v.build. extensive Logical: TRUE, extensive topological checks using v.build. default FALSE. cats NULL (default) integer vector: Values \"cats\" (categories) vector GRASS. useful speeding GVector creation process \"cats\" already ascertained. fail Logical: TRUE (default), vector either 0 east-west north-south extent, exit function error. fail FALSE, display warning return NULL.","code":""},{"path":"/reference/dot-makeGVector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GVector — .makeGVector","text":"GVector (NULL fail TRUE GVector invalid).","code":""},{"path":[]},{"path":"/reference/dot-makeGVector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GVector — .makeGVector","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/dot-makeSourceName.html","id":null,"dir":"Reference","previous_headings":"","what":"Make unique GRASS name for rasters, vectors, etc. — .makeSourceName","title":"Make unique GRASS name for rasters, vectors, etc. — .makeSourceName","text":"Make unique GRASS name rasters, vectors, etc.","code":""},{"path":"/reference/dot-makeSourceName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make unique GRASS name for rasters, vectors, etc. — .makeSourceName","text":"","code":".makeSourceName(x = NULL, type = NULL, n = 1L, name = NULL)"},{"path":"/reference/dot-makeSourceName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make unique GRASS name for rasters, vectors, etc. — .makeSourceName","text":"x Character NULL: Descriptive string. Developers, please note: assist debugging, GRASS objects created GRASS module module named argument (underscores). Example: \"v_in_ogr\" \"r_resample\". type Character: raster, raster3D, vector, table. n Numeric integer: Number names make name NULL (default) character: Name output, attached attribute.","code":""},{"path":"/reference/dot-makeSourceName.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make unique GRASS name for rasters, vectors, etc. — .makeSourceName","text":"Character vector.","code":""},{"path":"/reference/dot-maxVal.html","id":null,"dir":"Reference","previous_headings":"","what":"Get maximum value from GRaster metadata — .maxVal","title":"Get maximum value from GRaster metadata — .maxVal","text":"Get maximum value GRaster metadata","code":""},{"path":"/reference/dot-maxVal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get maximum value from GRaster metadata — .maxVal","text":"","code":".maxVal(x)"},{"path":"/reference/dot-maxVal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get maximum value from GRaster metadata — .maxVal","text":"x GRaster.","code":""},{"path":"/reference/dot-minVal.html","id":null,"dir":"Reference","previous_headings":"","what":"Get minimum value from GRaster metadata — .minVal","title":"Get minimum value from GRaster metadata — .minVal","text":"Get minimum value GRaster metadata","code":""},{"path":"/reference/dot-minVal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get minimum value from GRaster metadata — .minVal","text":"","code":".minVal(x)"},{"path":"/reference/dot-minVal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get minimum value from GRaster metadata — .minVal","text":"x GRaster.","code":""},{"path":"/reference/dot-nlevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Count number of levels from a data.frame/table, list, or SpatRaster — .nlevels","title":"Count number of levels from a data.frame/table, list, or SpatRaster — .nlevels","text":"Counts number levels character string (specifically, empty string \"\"), data.frame, data.table, list data.frames data.tables empty strings.","code":""},{"path":"/reference/dot-nlevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count number of levels from a data.frame/table, list, or SpatRaster — .nlevels","text":"","code":".nlevels(x)"},{"path":"/reference/dot-nlevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count number of levels from a data.frame/table, list, or SpatRaster — .nlevels","text":"x GRaster, SpatRaster, data.frame, data.table, empty string, list thereof.","code":""},{"path":"/reference/dot-plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot using a G-object's sources() name — .plot","title":"Plot using a G-object's sources() name — .plot","text":"Plot using G-object's sources() name","code":""},{"path":"/reference/dot-plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot using a G-object's sources() name — .plot","text":"","code":".plot(x, ...)"},{"path":"/reference/dot-plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot using a G-object's sources() name — .plot","text":"x sources() name GRaster GVector ... arguments pass plot().","code":""},{"path":"/reference/dot-projection.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ","title":"Get ","text":"\"Getter\" @projection slot.","code":""},{"path":"/reference/dot-projection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ","text":"","code":".projection(x)"},{"path":"/reference/dot-projection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ","text":"x GRaster GVector.","code":""},{"path":"/reference/dot-projection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ","text":"Character.","code":""},{"path":"/reference/dot-rastInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Metadata on rasters and vectors in GRASS — .rastInfo","title":"Metadata on rasters and vectors in GRASS — .rastInfo","text":".rastInfo() .vectInfo() fetch metadata rasters vectors GRASS. print(), show(), summary() functions can used display metadata.","code":""},{"path":"/reference/dot-rastInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metadata on rasters and vectors in GRASS — .rastInfo","text":"","code":".rastInfo(x)"},{"path":"/reference/dot-rastInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metadata on rasters and vectors in GRASS — .rastInfo","text":"x GRaster, GVector, sources.","code":""},{"path":"/reference/dot-rastInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metadata on rasters and vectors in GRASS — .rastInfo","text":"Metadata extent, dimensions, resolution, bottom/top, etc. rasters vectors GRASS.","code":""},{"path":"/reference/dot-rename.html","id":null,"dir":"Reference","previous_headings":"","what":"Rename a raster or vector in an existing GRASS session — .rename","title":"Rename a raster or vector in an existing GRASS session — .rename","text":"Rename raster vector existing GRASS session.","code":""},{"path":"/reference/dot-rename.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rename a raster or vector in an existing GRASS session — .rename","text":"","code":".rename(from, to, rastOrVect = NULL)"},{"path":"/reference/dot-rename.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rename a raster or vector in an existing GRASS session — .rename","text":", sources raster vector rename. rastOrVect Either NULL (default), \"raster\", \"vector\". specifies type object renamed. Partial matching allowed. left NULL (default), function try identify object raster vector, return error raster vector given name. Note unlike R, GRASS can rasters vector\"s name.","code":""},{"path":"/reference/dot-rename.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rename a raster or vector in an existing GRASS session — .rename","text":"function invisibly returns TRUE desired rasters /vectors named, FALSE raster /vector renamed exist GRASS session. Notably, raster vector renamed existing GRASS session.","code":""},{"path":"/reference/dot-vValidCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Are the category values of a vector valid? — .vValidCats","title":"Are the category values of a vector valid? — .vValidCats","text":"Category values GRASS vector can invalid GRASS assigns one value geometry (e.g., \"7/12\"). can occur vector created software use topological system (e.g., shapefile).","code":""},{"path":"/reference/dot-vValidCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are the category values of a vector valid? — .vValidCats","text":"","code":".vValidCats(x)"},{"path":"/reference/dot-vValidCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are the category values of a vector valid? — .vValidCats","text":"x GVector sources() name one.","code":""},{"path":"/reference/dot-vValidCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are the category values of a vector valid? — .vValidCats","text":"Logical.","code":""},{"path":"/reference/dot-vectInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Metadata on a vector in GRASS — .vectInfo","title":"Metadata on a vector in GRASS — .vectInfo","text":"function queries GRASS obtain metadata vector.","code":""},{"path":"/reference/dot-vectInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metadata on a vector in GRASS — .vectInfo","text":"","code":".vectInfo(x, integer = TRUE, cats = NULL)"},{"path":"/reference/dot-vectInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metadata on a vector in GRASS — .vectInfo","text":"x GVector sources() name one. integer Logical. TRUE (default), \"cats\" vector returned type integer. FALSE, returned character vector. cats NULL (default) integer vector category numbers, one per geometry.","code":""},{"path":"/reference/dot-vectInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metadata on a vector in GRASS — .vectInfo","text":"vectInfo object (list).","code":""},{"path":"/reference/dot-zonal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for zonal() — .zonal","title":"Internal function for zonal() — .zonal","text":"Internal function zonal()","code":""},{"path":"/reference/dot-zonal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for zonal() — .zonal","text":"","code":".zonal(x, z, fun, probs, zones, xnames)"},{"path":"/reference/dot-zonal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function for zonal() — .zonal","text":"x sources() name GRaster. z sources() name \"zones\" GRaster. fun Character: Name function(s). probs Numeric range 0 1, inclusive. zones Vector zone values (integers). xnames Character: Names x.","code":""},{"path":"/reference/dot-zonalByVector.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for zonal() when y is a GVector — .zonalByVector","title":"Internal function for zonal() when y is a GVector — .zonalByVector","text":"Internal function zonal() y GVector","code":""},{"path":"/reference/dot-zonalByVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for zonal() when y is a GVector — .zonalByVector","text":"","code":".zonalByVector(x, z, fun, probs, gtype)"},{"path":"/reference/dot-zonalByVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function for zonal() when y is a GVector — .zonalByVector","text":"x GRaster sources() name. z GVector sources() name. fun Character gtype geomtype(z, grass = TRUE) (\"area\", \"line\", \"point\")","code":""},{"path":"/reference/dropRows.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","title":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","text":"September 2023, data.table package function removing rows index. function job.","code":""},{"path":"/reference/dropRows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","text":"","code":"# S4 method for class 'data.table' dropRows(x, drops)  # S4 method for class 'data.frame' dropRows(x, drops)  # S4 method for class 'matrix' dropRows(x, drops)"},{"path":"/reference/dropRows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","text":"x data.table data.frame. drops Numeric, integer, logical vector: Indices indicators rows remove. logical vector supplied, rows correspond TRUE removed. vector shorter number rows, values drops recycled.","code":""},{"path":"/reference/dropRows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","text":"data.table data.frame.","code":""},{"path":"/reference/dropRows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows in a data.table, data.frame, or matrix. — dropRows,data.table-method","text":"","code":"library(data.table) #>  #> Attaching package: ‘data.table’ #> The following objects are masked from ‘package:fasterRaster’: #>  #>     %notin%, as.data.table  dt <- data.table(    x = 1:10,    y = letters[1:10],    z = rnorm(10) )  # make some values NA dt[x == 4 | x == 8, y := NA_character_] #>         x      y            z #>     <int> <char>        <num> #>  1:     1      a -1.400043517 #>  2:     2      b  0.255317055 #>  3:     3      c -2.437263611 #>  4:     4   <NA> -0.005571287 #>  5:     5      e  0.621552721 #>  6:     6      f  1.148411606 #>  7:     7      g -1.821817661 #>  8:     8   <NA> -0.247325302 #>  9:     9      i -0.244199607 #> 10:    10      j -0.282705449 dt #>         x      y            z #>     <int> <char>        <num> #>  1:     1      a -1.400043517 #>  2:     2      b  0.255317055 #>  3:     3      c -2.437263611 #>  4:     4   <NA> -0.005571287 #>  5:     5      e  0.621552721 #>  6:     6      f  1.148411606 #>  7:     7      g -1.821817661 #>  8:     8   <NA> -0.247325302 #>  9:     9      i -0.244199607 #> 10:    10      j -0.282705449  # Replace NAs: replaceNAs(dt, replace = -99, cols = \"y\") #>         x      y            z #>     <int> <char>        <num> #>  1:     1      a -1.400043517 #>  2:     2      b  0.255317055 #>  3:     3      c -2.437263611 #>  4:     4    -99 -0.005571287 #>  5:     5      e  0.621552721 #>  6:     6      f  1.148411606 #>  7:     7      g -1.821817661 #>  8:     8    -99 -0.247325302 #>  9:     9      i -0.244199607 #> 10:    10      j -0.282705449 dt #>         x      y            z #>     <int> <char>        <num> #>  1:     1      a -1.400043517 #>  2:     2      b  0.255317055 #>  3:     3      c -2.437263611 #>  4:     4    -99 -0.005571287 #>  5:     5      e  0.621552721 #>  6:     6      f  1.148411606 #>  7:     7      g -1.821817661 #>  8:     8    -99 -0.247325302 #>  9:     9      i -0.244199607 #> 10:    10      j -0.282705449  # Drop rows: dropped <- dropRows(dt, 8:10) dropped #>        x      y            z #>    <int> <char>        <num> #> 1:     1      a -1.400043517 #> 2:     2      b  0.255317055 #> 3:     3      c -2.437263611 #> 4:     4    -99 -0.005571287 #> 5:     5      e  0.621552721 #> 6:     6      f  1.148411606 #> 7:     7      g -1.821817661  # NB May not print... in that case, use: print(dropped) #>        x      y            z #>    <int> <char>        <num> #> 1:     1      a -1.400043517 #> 2:     2      b  0.255317055 #> 3:     3      c -2.437263611 #> 4:     4    -99 -0.005571287 #> 5:     5      e  0.621552721 #> 6:     6      f  1.148411606 #> 7:     7      g -1.821817661  # We can also use replaceNAs() on vectors: y <- 1:10 y[c(2, 10)] <- NA replaceNAs(y, -99) #>  [1]   1 -99   3   4   5   6   7   8   9 -99  # Same as: y <- 1:10 y[c(2, 10)] <- NA y[is.na(y)] <- -99"},{"path":"/reference/droplevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows from the ","title":"Remove rows from the ","text":"droplevels() removes levels (category values) \"levels\" table categorical GRaster.","code":""},{"path":"/reference/droplevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows from the ","text":"","code":"# S4 method for class 'GRaster' droplevels(x, level = NULL, layer = 1)"},{"path":"/reference/droplevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows from the ","text":"x GRaster. level NULL, character, numeric, integer, logical: Level(s) drop. NULL (default), levels without values raster dropped (may remove \"levels\" table entirely levels dropped, converting raster integer-type raster).  character, category label(s) drop. numeric integer, category value(s) drop. logical, values TRUE dropped. layer Numeric integers, logical vector, character: Layer(s) add drop levels.","code":""},{"path":"/reference/droplevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows from the ","text":"GRaster. \"levels\" table raster modified.","code":""},{"path":[]},{"path":"/reference/droplevels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows from the ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/erase.html","id":null,"dir":"Reference","previous_headings":"","what":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","title":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","text":"erase() function removes x \"polygons\" GVector parts overlap y \"polygons\" GVector. can also use - operator (e.g., vect1 - vect2).","code":""},{"path":"/reference/erase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","text":"","code":"# S4 method for class 'GVector,GVector' erase(x, y)"},{"path":"/reference/erase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","text":"x, y GVectors.","code":""},{"path":"/reference/erase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/erase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select parts of a polygon GVector erase shared by another polygon GVector — erase,GVector,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Polygon of coastal Madagascar and Dypsis specimens madCoast4 <- fastData(\"madCoast4\") # polygons madDypsis <- fastData(\"madDypsis\") # points  # Convert vectors: coast4 <- fast(madCoast4) dypsis <- fast(madDypsis)  # Create another polygons vector from a convex hull around Dypsis points hull <- convHull(dypsis)  ### union() ###########  unioned <- union(coast4, hull) plot(unioned)  plus <- coast4 + hull # same as union()  ### intersect #############  inter <- intersect(coast4, hull) plot(coast4) plot(hull, border = \"red\", add = TRUE) plot(inter, border = \"blue\", add = TRUE)  ### xor #######  xr <- xor(coast4, hull) plot(coast4) plot(xr, border = \"blue\", add = TRUE)  ### erase #########  erased <- erase(coast4, hull) plot(coast4) plot(erased, border = \"blue\", add = TRUE)  minus <- coast4 - hull # same as erase()  }"},{"path":"/reference/exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the ","title":"Does the ","text":"GRasters GVectors R objects contain pointer raster vector GRASS. Thus, GRaster GVector functional, GRASS file must exist. function indicates .","code":""},{"path":"/reference/exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the ","text":"","code":"# S4 method for class 'GRaster' .exists(x)  # S4 method for class 'GVector' .exists(x)  # S4 method for class 'character' .exists(x)"},{"path":"/reference/exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the ","text":"x GRaster, GVector, sources() name one.","code":""},{"path":"/reference/exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the ","text":"Logical.","code":""},{"path":"/reference/exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the ","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/expanse.html","id":null,"dir":"Reference","previous_headings":"","what":"Area of polygons or length of lines — expanse,GVector-method","title":"Area of polygons or length of lines — expanse,GVector-method","text":"function calculates area polygon \"polygons\" GVector length lines \"lines\" GVector.","code":""},{"path":"/reference/expanse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area of polygons or length of lines — expanse,GVector-method","text":"","code":"# S4 method for class 'GVector' expanse(x, unit = \"m\")"},{"path":"/reference/expanse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area of polygons or length of lines — expanse,GVector-method","text":"x \"polygons\" \"lines\" GVector. unit Character: Units report values. Areal units squared, linear . Can : \"meters\"(default), \"metres\", \"m\" \"km\" \"kilometers\" \"ha\" \"hectares\" \"ft\" \"feet\" \"ac\" \"acres\" \"percent\" Partial matching used case ignored.","code":""},{"path":"/reference/expanse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area of polygons or length of lines — expanse,GVector-method","text":"Numeric values, one per geometry x.","code":""},{"path":"/reference/expanse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area of polygons or length of lines — expanse,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial bounds of a GRaster or GVector — ext,missing-method","title":"Spatial bounds of a GRaster or GVector — ext,missing-method","text":"functions return extent GSpatial object (GRegions, GRasters, GVectors): ext(): 2-dimensional spatial extent (.e., westernmost/easternmost southernmost/northernmost coordinates area represented). zext(): Vertical extent (.e., topmost bottom-elevation volume represented). vertical extent NA object 3-dimensional. W(), E(), N(), S(): Coordinates one side horizontal extent. top() bottom(): Coordinates top bottom vertical extent.","code":""},{"path":"/reference/ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial bounds of a GRaster or GVector — ext,missing-method","text":"","code":"# S4 method for class 'missing' ext(x, vector = FALSE)  # S4 method for class 'GSpatial' ext(x, vector = FALSE)  # S4 method for class 'missing' zext(x)  # S4 method for class 'GSpatial' zext(x)  # S4 method for class 'missing' W(x, char = FALSE)  # S4 method for class 'GSpatial' W(x, char = FALSE)  # S4 method for class 'missing' E(x, char = FALSE)  # S4 method for class 'GSpatial' E(x, char = FALSE)  # S4 method for class 'missing' N(x, char = FALSE)  # S4 method for class 'GSpatial' N(x, char = FALSE)  # S4 method for class 'missing' S(x, char = FALSE)  # S4 method for class 'GSpatial' S(x, char = FALSE)  # S4 method for class 'missing' top(x, char = FALSE)  # S4 method for class 'GSpatial' top(x, char = FALSE)  # S4 method for class 'GSpatial' bottom(x, char = FALSE)  # S4 method for class 'GSpatial' bottom(x, char = FALSE)"},{"path":"/reference/ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial bounds of a GRaster or GVector — ext,missing-method","text":"x object inherits GSpatial (.e., GRaster GVector) missing. missing, horizontal vertical extent currently active region returned. vector Logical: FALSE (default), return SpatExtent object. TRUE, return extent named vector. char Logical: FALSE (default), return numeric value. TRUE, return character.","code":""},{"path":"/reference/ext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial bounds of a GRaster or GVector — ext,missing-method","text":"returned values depend function: ext(): SpatExtent object (terra package) numeric vector. zext(): numeric vector. W(), E(), N(), S(), top(), bottom(): numeric value character.","code":""},{"path":[]},{"path":"/reference/ext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial bounds of a GRaster or GVector — ext,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/extend.html","id":null,"dir":"Reference","previous_headings":"","what":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"extend() adds cells around raster, making larger.","code":""},{"path":"/reference/extend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"","code":"# S4 method for class 'GRaster,numeric' extend(x, y, fill = NA)  # S4 method for class 'GRaster,SpatRaster' extend(x, y, snap = \"near\", fill = NA)  # S4 method for class 'GRaster,SpatVector' extend(x, y, snap = \"near\", fill = NA)  # S4 method for class 'GRaster,SpatExtent' extend(x, y, snap = \"near\", fill = NA)  # S4 method for class 'GRaster,sf' extend(x, y, snap = \"near\", fill = NA)  # S4 method for class 'GRaster,GSpatial' extend(x, y, snap = \"near\", fill = NA)"},{"path":"/reference/extend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"x GRaster. y : object extent can obtained; .e., SpatRaster, SpatVector, SpatExtent, sf vector, GSpatial object (GRaster, GVector, GRegion). extent x \"outside\" extent y side, side(s) x outside kept -(.e., extent x never shrunk). single positive integer: Number rows columns add top, bottom, sides raster. Two integers >= 0: Number columns (1st value) add sides, number rows (2nd value) add top bottom raster. Four integers >= 0: Number rows columns add (left column, right column, bottom row, top row). fill Numeric: Value place new cells. default NA. snap Character: Method used align y x. Partial matching used. used y set numbers. \"near\" (default): Round nearest row/column \"\": Round \"inward\" toward extent x nearest row/column \"\": Round \"outward\" away extent x nearest row/column.","code":""},{"path":"/reference/extend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"GRaster.","code":""},{"path":"/reference/extend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"Known issues: GRasters saved disk explicitly using writeRaster(), implicitly using rast() plot(), rows columns entirely NA dropped.","code":""},{"path":[]},{"path":"/reference/extend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add rows and columns around a writeRaster — extend,GRaster,numeric-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\")  # Send spatial objects to GRASS: elev <- fast(madElev) rivers <- fast(madRivers)  # Extend raster by number of rows/columns: extended1 <- extend(elev, 10, fill = 900) extended2 <- extend(elev, c(10, 20), fill = 900) extended3 <- extend(elev, c(10, 80, 0, 100), fill = 900) dim(elev) dim(extended1) dim(extended2) dim(extended3)  plot(extended3)  # Note that when exporting a raster (including plotting it), NA rows and # columns are removed. extended4 <- extend(elev, 100, fill=1) # default fill is NA extended4terra <- rast(extended4)  dim(extended4) dim(extended4terra)  plot(extended4)  # Extend the raster by another object with a wider extent. We will crop the # raster so that it is smaller than the object we use to extend it, # then extend it. elevCrop <- crop(elev, rivers) uncrop <- extend(elevCrop, elev, fill = 900) plot(uncrop)  }"},{"path":"/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","title":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","text":"extract() obtains values GRaster GVector associated locations set points. output depends input: Case #1: x numeric integer GRaster y points GVector: Returns values cells points. xy TRUE, also returns coordinates points. Case #2: x categorical (factor) GRaster y points GVector: case #1, cats TRUE, returns category labels cells points. xy TRUE, also returns coordinates points. Case #3: x categorical GRaster y lines polygons GVector: Returns summary (e.g., mean, standard deviation, etc.) cells overlap line(s) polygon(s). Case #4: x GVector y points GVector: Returns data table row associated point. xy TRUE, also returns coordinates points. Note whenever points GVector allowed y, data.frame, data.table, matrix, numeric values representing points can used instead.","code":""},{"path":"/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","text":"","code":"# S4 method for class 'GRaster,GVector' extract(   x,   y,   fun = \"mean\",   prob = 0.5,   overlap = TRUE,   xy = FALSE,   cats = TRUE,   verbose = FALSE )  # S4 method for class 'GRaster,data.frame' extract(x, y, xy = FALSE, cats = TRUE)  # S4 method for class 'GRaster,data.table' extract(x, y, xy = FALSE, cats = TRUE)  # S4 method for class 'GRaster,matrix' extract(x, y, xy = FALSE, cats = TRUE)  # S4 method for class 'GRaster,numeric' extract(x, y, xy = FALSE, cats = TRUE)  # S4 method for class 'GVector,GVector' extract(x, y, xy = FALSE)  # S4 method for class 'GVector,data.frame' extract(x, y, xy = FALSE)  # S4 method for class 'GVector,data.table' extract(x, y, xy = FALSE)  # S4 method for class 'GVector,matrix' extract(x, y, xy = FALSE)  # S4 method for class 'GVector,numeric' extract(x, y, xy = FALSE)"},{"path":"/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","text":"x GRaster GVector. y GVector, data.frame matrix first two columns represent longitude latitude (order), two-element numeric vector first column represents longitude second latitude. Values x extracted points y. GVectors can types points, lines, polygons. fun Character vector: Name(s) function(s) apply values. used x GRaster y lines polygons GVector. method(s) specified fun applied cell values overlap geometry (.e., individual cell values returned). Valid functions include: \"countNonNA\": Number overlapping cells. \"countNA\": Number overlapping NA cells. \"mean\": Average. \"min\": Minimum. \"max\": Minimum. \"sum\": Sum. \"range\": Maximum - minimum. \"sd\": Sample standard deviation (stats::sd()). \"sdpop\": Population standard deviation. \"var\": Sample variance (stats::var()). \"varpop\": Population variance. \"cv\": Coefficient variation. \"cvpop\": Population coefficient variation. \"median\": Median. \"quantile\": Quantile; can specify quantile using prob argument. prob Numeric range 0 1: Quantile calculate. value prob rounded nearest hundredth. overlap Logical: TRUE (default), y lines polygons GVector, account potential overlap geometries extracting. can slow, sure geometries overlap, can change FALSE. argument ignored y points GVector. xy Logical: TRUE y represents points, also return coordinates point. Default FALSE. cats Logical (extracting raster): TRUE (default) x categorical raster, return category labels instead values. verbose Logical: TRUE, display progress (function extracting points GRaster number GRasters large).","code":""},{"path":"/reference/extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","text":"data.frame data.table.","code":""},{"path":[]},{"path":"/reference/extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract values from a GRaster at locations in a points GVector — extract,GRaster,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data: elevation raster and points vector madElev <- fastData(\"madElev\") # raster madCover <- fastData(\"madCover\") # categorical raster madDypsis <- fastData(\"madDypsis\") # points vector madRivers <- fastData(\"madRivers\") # lines vector madCoast4 <- fastData(\"madCoast4\") # polygons vector  # Convert to fasterRaster formats: elev <- fast(madElev) # raster cover <- fast(madCover) # categorical raster dypsis <- fast(madDypsis) # points vector rivers <- fast(madRivers) # lines vector coast <- fast(madCoast4) # polygons vector  # Get values of elevation at points where Dypsis species are located: extract(elev, dypsis, xy = TRUE)  # Extract from categorical raster at points: dypsisWGS84 <- project(dypsis, cover) # Convert to same CRS categories <- extract(cover, dypsisWGS84) categoryValues <- extract(cover, dypsisWGS84, cats = FALSE) categories categoryValues  # Extract and summarize values on a raster across polygons: extract(elev, coast, fun = c(\"sum\", \"mean\", \"countNonNA\"), overlap = FALSE)  # Extract and summarize values on a raster across lines: extract(elev, rivers, fun = c(\"sum\", \"mean\", \"countNonNA\"), overlap = FALSE)  # Extract from a polygons vector at a points vector: table <- extract(coast, dypsis, xy = TRUE) head(table) # first 3 are outside polygons vector, next 3 are inside  }"},{"path":"/reference/fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GRaster or GVector — fast","title":"Create a GRaster or GVector — fast","text":"fast() creates GRaster GVector 1) file; 2) SpatRaster, SpatVector, sf vector; 3) numeric vector, matrix, data.frame, data.table. Behind scenes, function also create connection GRASS none yet made yet. GRASS supports loading disk variety raster formats (see GRASS manual page r..gdal) vector formats (v..ogr), though work function. Note GVectors may fail created contain issues coincide topological data model used GRASS. common overlapping polygons. See Details fix kinds issues. Note also GRASS (thus, fasterRaster) fast loading vectors. , vector large want portion , consider using extent argument load spatial subset need.","code":""},{"path":"/reference/fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GRaster or GVector — fast","text":"","code":"# S4 method for class 'character' fast(   x,   rastOrVect = NULL,   levels = TRUE,   extent = NULL,   correct = TRUE,   snap = NULL,   area = NULL,   steps = 10,   dropTable = FALSE,   resolve = NA,   verbose = TRUE,   ... )  # S4 method for class 'SpatRaster' fast(x, ...)  # S4 method for class 'SpatVector' fast(   x,   extent = NULL,   correct = TRUE,   snap = NULL,   area = NULL,   steps = 10,   dropTable = FALSE,   resolve = NA,   verbose = TRUE )  # S4 method for class 'sf' fast(   x,   extent = NULL,   correct = TRUE,   snap = NULL,   area = NULL,   steps = 10,   dropTable = FALSE,   resolve = NA,   verbose = TRUE )  # S4 method for class 'missing' fast(x, rastOrVect, crs = \"\")  # S4 method for class 'numeric' fast(x, crs = \"\", keepgeom = FALSE)  # S4 method for class 'data.frame' fast(x, geom = 1:2, crs = \"\", keepgeom = FALSE)  # S4 method for class 'data.table' fast(x, geom = 1:2, crs = \"\", keepgeom = FALSE)  # S4 method for class 'matrix' fast(x, geom = 1:2, crs = \"\", keepgeom = FALSE)"},{"path":"/reference/fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GRaster or GVector — fast","text":"x one : SpatRaster raster. Rasters can one layers. SpatVector sf spatial vector. See especially arguments correct, area, snap, steps, verbose. character string vector strings path(s) filename(s) one rasters one vector loaded directly GRASS. function attempt ascertain type object file extension (raster vector), can help indicate using rastOrVect argument unclear. rasters, see especially argument levels. vectors, see especially arguments correct, resolve, area, snap, steps, verbose. vector even number numeric values representing longitude/latitude pairs. See arguments geom, keepgeom, crs. data.frame, data.table, matrix: Create points GVector. Two columns must represent longitude latitude. See arguments geom, keepgeom, crs. Missing: Creates generic GRaster GVector. must specify rastOrVect; example, fast(rastOrVect = \"raster\"). Also see argument crs. rastOrVect Either NULL (default), \"raster\" \"vector\": x filename, function try ascertain whether represents raster vector, sometimes fail. case, can help specify file holds raster vector. Partial matching used. levels (GRasters ): : Logical: TRUE (default) least one layer raster type integer, search \"levels\" file, load , attach levels. levels file name raster file, end \"rdata\", \"rdat\", \"rda\", \"rds\", \"csv\", \"tab\" (case generally matter). file found, levels assigned. levels file must contain either data.frame, data.table, list data.frames data.tables, NULL. data.frame, data.table, list data.frames data.tables categories categorical rasters. first column table corresponds raster values must type integer. subsequent column corresponds category labels. default, second column assumed represent labels, can changed activeCat<-. Level tables can also NULL (e.g., data.fame(NULL)). can also assign levels loading raster using levels<-. NULL: attach levels table. #' extent (GVectors ): Either NULL (default), GVector, SpatVector, SpatExtent object, sf vector, bbox object, numeric vector 4 values providing bounding box. provided, vector features within bounding box imported. extent numeric vector, values must order west, east, south, north. NULL, entire vector imported. correct Logical (GVectors ): Correct topological issues. See Details details! default, TRUE. snap GVectors : Numeric NULL (default). value snap indicates close vertices need shifted location. Units snap map units (usually meters), degrees unprojected CRSs. lines polygons vectors, value NULL invoke iterative procedure find optimal, smallest value snap. turn snapping , set snap = 0. See Details details! area Polygon GVectors : Either positive numeric value NULL (default). Remove polygons area smaller value. Units area square meters (regardless CRS). NULL, iterative procedure used identify value area results topologically correct polygon vector. point lines vectors, argument ignored. turn area removal , set area = 0. See Details details! steps GVectors : positive integer > 1 (default 10). using automatic vector correction (.e., either snap = NULL /area = NULL), number values snap /area try generate correct topology, including snapping polygon removal (.e, snap = 0 area = 0). dropTable GVectors : Logical. TRUE, drop data table associated vector. default, FALSE. See Details details! resolve GVectors : Character. GVector topologically invalid first attempt creating , method used resolve issue create valid GVector. Partial matching used. \"disaggregate\": Coerce area overlap polygons geometry. output data table associated . \"aggregate\": Coerce geometries \"multipart\" geometry acts like single geometry. output data table associated . NA (default): neither either snap area NULL, keep trying create GVector. Upon success, GVector retain data table associated unless dropTable FALSE. verbose GVectors : Logical. Displays progress using automatic topology correction. ... arguments:: table (GVectors–useful mainly developers, users): data.frame data.table one row per geometry GVector. Serves attribute table. xVect (GVectors–useful mainly developers, users): SpatVector corresponds file named x. crs String: Coordinate reference system (CRS) WKT2 string. argument used creating GVector numeric vector data.frame similar, fast(rastOrVect = \"vector\") fast(rastOrVect = \"raster\"). default, function use value crs() (arguments), CRS current GRASS \"location\". keepgeom Logical: x set numeric coordinates, data.frame similar, can coerced points GVector. keepgeom TRUE, coordinates included data table GVector. default FALSE. geom Character integer vector: x data.frame, data.table, matrix, specifies columns x represent longitude latitude. Columns can given name (character vector) index (numeric integer vector). default use first two columns x.","code":""},{"path":"/reference/fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GRaster or GVector — fast","text":"GRaster GVector.","code":""},{"path":"/reference/fast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a GRaster or GVector — fast","text":"GRASS uses \"topological\" model vectors. Topological issues generally arise polygon vectors, point line vectors. Sometimes, polygons created software topologically incorrect–borders adjacent polygons may cross one another, may small gaps . errors can corrected slightly shifting vertices /removing small polygons result intersections larger ones border one another. topological system also recognizes boundaries adjacent polygons shared areas, ascribed attributes belong areas (e.g., shared border two countries \"belongs\" countries). default, fast() try correct topological errors vectors. three levels correction, necessarily mutually exclusive: Automatic correction: default, fast() apply automatic topology correction. can turn using correct = FALSE argument, though cases recommended. Manual snapping /area removal: addition correction step 1, can cause vertices polygons close one another \"snapped\" place /polygons smaller threshold removed. Problems mis-aligned vertices arise adjacent polygons meant share borders, slight differences locations vertices cause  mis-align. mis-alignment can also produce small \"slivers\" polygons areas overlap. can snap vertices within given distance one another using snap argument followed numeric value, like snap = 0.000001. Units snap map units (usually meters) projected coordinate reference systems degrees unprojected systems (e.g., WGS84, NAD83, NAD27). can also remove polygons smaller particular area using area argument followed numeric value (e.g., area = 1). units area meters-squared, regardless coordinate reference system. Note using snap area entails risk, possible nearby vertices actually distinct small areas legitimate. Automatic snapping /area removal: addition correction step 1, can use automatic snap /area correction polygons vectors setting snap /area NULL (.e., default values). just snap NULL, automatic snapping performed, just area NULL, automatic area removal performed. Regardless, also need set integer value steps, number steps take smallest value snap /area maximum value attempted. function proceed first attempting snap = 0 /area = 0 (.e., snapping area removal). produce topologically correct vector, GRASS (internally) suggest range snap. fast() function creates steps values lowest highest values range evenly-spaced along log values range, proceed repeat importing process either vector imported correctly maximum value snap reached results failed topology. Smaller values step result fine-grained attempts less likely yield overcorrection, can also take time. value area automatic correction set snap^2. NB: Automated snapping area removal performed polygons vectors, even snap area NULL. snap lines points, must set snap equal numeric value. area correction ignored points lines. Issues can also arise due : Data table-vector mismatching: vector data table (\"attribute table\") associated , errors can occur /fewer geometries (multi-geometries) per row table. really need data table analysis, can remove (thus obviate error) using dropTable = TRUE. Dissolving aggregating \"invalid\" geometries: Using resolve argument, can create topologically valid vector either coercing overlapping portions polygons geometries (resolve = \"disaggregate\"), coercing single, combined geometry (resolve = \"aggregate\"). Aggregation/disaggregation implemented loading vector GRASS using settings given snap area. Aggregation/disaggregation cause associated data table dropped (forces dropTable TRUE). default action neither aggregation disaggregation (resolve = NA). none fixes work, can try: Correction outside fasterRaster: convert vector fasterRaster's GVector format, can also try using terra::makeValid() sf::st_make_valid() tools fix issues, use fast(). Post-conversion GVector: get vector loaded GVector format, can also use set fasterRaster vector-manipulation tools fillHoles() fix issues.","code":""},{"path":[]},{"path":"/reference/fast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GRaster or GVector — fast","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") # integer raster madCover <- fastData(\"madCover\") # categorical raster madCoast4 <- fastData(\"madCoast4\") # polygons vector madRivers <- fastData(\"madRivers\") # lines vector madDypsis <- fastData(\"madDypsis\") # points vector  ### Create GRasters from SpatRasters ####################################  # Create an integer raster: elev <- fast(madElev) elev  # Create a categorical raster: cover <- fast(madCover) madCover levels(madCover) # category levels  # Create a GRaster from a file on disk: rastFile <- system.file(\"extdata\", \"madForest2000.tif\", package = \"fasterRaster\") forest2000 <- fast(rastFile) forest2000  # Create a 1's raster that spans the world: ones <- fast(rastOrVect = \"raster\", crs = \"epsg:4326\") ones  ### Create GVectors ###################  # Create a GVector from an sf vector: coast4 <- fast(madCoast4) coast4  # Create a GVector from a SpatVector: madRivers <- vect(madRivers) class(madRivers) rivers <- fast(madRivers) rivers  # Create a GVector from a vector on disk vectFile <- system.file(\"extdata/shapes\", \"madCoast.shp\",    package = \"fasterRaster\") coast0 <- fast(vectFile) coast0  # Import only Dypsis occurrences in a restricted area ant <- coast4[coast4$NAME_4 == \"Antanambe\"] dypsisRestrict <- fast(madDypsis, extent = ant) dypsis <- fast(madDypsis)  plot(coast4) plot(ant, col = \"gray80\", add = TRUE) plot(dypsis, add = TRUE) plot(dypsisRestrict, col = \"red\", add = TRUE)  # Create a generic GVector that spans the world wallToWall <- fast(rastOrVect = \"vector\", crs = \"epsg:4326\") # WGS84 wallToWall  # Create a GVector from a numeric vector pts <- c(-90.2, 38.6, -122.3, 37.9) pts <- fast(pts, crs = \"epsg:4326\") # WGS84  # Create a GVector from a matrix (can also use data.frame or data.table) mat <- matrix(c(-90.2, 38.6, -122.3, 37.9), ncol = 2, byrow = TRUE) mat <- fast(mat, crs = \"epsg:4326\", keepgeom = TRUE) # WGS84  }"},{"path":"/reference/fastData.html","id":null,"dir":"Reference","previous_headings":"","what":"Get one of the example rasters or spatial vectors — fastData","title":"Get one of the example rasters or spatial vectors — fastData","text":"function simple way get example rasters spatial vector datasets come fasterRaster.","code":""},{"path":"/reference/fastData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get one of the example rasters or spatial vectors — fastData","text":"","code":"fastData(x)"},{"path":"/reference/fastData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get one of the example rasters or spatial vectors — fastData","text":"x name raster spatial vector get. represent portion eastern coast Madagascar. Spatial vectors (objects class sf sf package): madCoast0: Outline region (polygon) madCoast4: Outlines Fokontanies (Communes) region (polygons) madDypsis: Records plants genus Dypsis (points) madRivers: Major rivers (lines) Rasters (objects class SpatRaster terra package, saved GeoTIFF files): madChelsa: Bioclimatic variables madCover: Land cover (also see madCoverCats)  madForest2000: Forest cover year 2000 madForest2014: Forest cover year 2014 madLANDSAT: Surface reflectance 2023 madPpt, madTmin, madTmax: Rasters mean monthly precipitation, minimum maximum temperature. Data frames appFunsTable: Table functions usable app(). madCoverCats: Land cover values categories. vegIndices: Vegetation indices can calculated vegIndex().","code":""},{"path":"/reference/fastData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get one of the example rasters or spatial vectors — fastData","text":"SpatRaster, sf spatial vector, data.frame.","code":""},{"path":"/reference/fastData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get one of the example rasters or spatial vectors — fastData","text":"","code":"### vector data ###############  library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE #>  #> Attaching package: ‘sf’ #> The following objects are masked from ‘package:fasterRaster’: #>  #>     st_as_sf, st_buffer, st_coordinates, st_crs  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra) #> terra 1.7.78 #>  #> Attaching package: ‘terra’ #> The following object is masked from ‘package:data.table’: #>  #>     shift  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/faster.html","id":null,"dir":"Reference","previous_headings":"","what":"Set or get options shared across ","title":"Set or get options shared across ","text":"faster() either sets gets options used across fasterRaster functions. use can vary: Get current values particular option: Use faster(\"option_name\"). Values remain unchanged. Get current values options: Use faster() (arguments). Values remain unchanged. Get default values particular option: Use faster(\"option_name\", default = TRUE). Values remain unchanged. Get default values options: Use faster(default = TRUE). Values remain unchanged. Set values particular options: Use form faster(option 1 = value1, option2 = value2). Set options defaults: Use faster(restore = TRUE). simultaneously get set options.","code":""},{"path":"/reference/faster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set or get options shared across ","text":"","code":"faster(..., default = FALSE, restore = FALSE)"},{"path":"/reference/faster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set or get options shared across ","text":"... Either: character vector: Name(s) option(s) get values ; option value option using option = value pattern; names list names match options wish change, values assign option. Options include: grassDir (character): folder GRASS installed computer. Typically, option set run faster(). Depending operating system, install directory look something like : Windows: \"C:/Program Files/GRASS GIS 8.3\" Mac OS: \"/Applications/GRASS-8.3.app/Contents/Resources\" Linux: \"/usr/local/grass\" addonsDir (character): Folder GRASS addons stored. NA grassDir NA, assumed file.path(grassDir, \"addons\"). default values NA. cores (integer/numeric integer): Number processor cores use task. default 2. GRASS modules parallelized. memory (integer/numeric): amount memory allocate task, GB, GRASS. default 2048 MB (.e., 2 GB). GRASS modules can take advantage memory. clean (logical): TRUE (default), remove temporary files created internally functions. deleted, can eventually fill hard drive space, deleting takes little bit time (usually <1 second function). useDataTable (logical): FALSE (default), functions return tabular output produce data.frames. TRUE, output data.tables data.table package. can much faster, might require know use data.tables want manipulate R. can always convert data.frames using base::.data.frame(). verbose (logical): TRUE, show GRASS messages otherwise hidden slots classes. mainly used debugging, users want keep default, FALSE. workDir (character): folder GRASS rasters, vectors, objects created manipulated. default, given tempdir(). default Logical: Return default value(s) option(s). default value default FALSE. restore Logical: TRUE, options reset default values. default FALSE.","code":""},{"path":"/reference/faster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set or get options shared across ","text":"options changed, named list option values changed returned invisibly. option values requested, named list option values returned (invisibly).","code":""},{"path":"/reference/faster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set or get options shared across ","text":"","code":"if (grassStarted()) {  # See current values for options: faster(\"grassDir\") faster(\"addonsDir\") faster(\"clean\") faster(\"cores\") faster(\"memory\") faster(\"useDataTable\") faster(\"verbose\") faster(\"workDir\") faster() # all options  # See default values for options: faster(\"cores\", default = TRUE) faster(default = TRUE) # all options  # Set options (change accordingly for your system!!!) if (FALSE) {  opts. <- faster() # remember starting values of options  faster(grassDir = \"C:/Program Files/GRASS GIS 8.4\") faster(verbose = TRUE, memory = 1024, cores = 1)  faster(c(\"grassDir\", \"verbose\", \"memory\", \"cores\"))  faster(opts.) # reset options to starting values  }  }"},{"path":"/reference/fasterRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"fasterRaster: Processing large--memory/-disk rasters spatial vectors using GRASS GIS. functions terra sf packages recreated. Processing medium-sized smaller spatial objects nearly always faster using terra sf. use functions must stand-alone version GRASS GIS version 8.3 higher (OSGeoW4 installer version). Note due differences GRASS, terra, sf implemented, results always strictly comparable functions operation.","code":""},{"path":"/reference/fasterRaster.html","id":"most-useful-tutorials-and-functions-","dir":"Reference","previous_headings":"","what":"Most useful tutorials and functions:","title":"","text":"quick-start tutorial tutorial raster data typesfaster(): Set directory GRASS installed system, set get package-wide optionsfast(): Convert SpatRaster, SpatVector, sf vector fasterRaster's raster format (GRasters) vector format (GVectors), load one filerast(), vect(), st_as_sf(): Convert GRasters GVectors SpatRasters, SpatVectors, sf vectorswriteRaster() writeVector(): Save GRasters GVectors disk","code":""},{"path":"/reference/fasterRaster.html","id":"properties-of-grasters","dir":"Reference","previous_headings":"","what":"Properties of GRasters","title":"","text":"crs(): Coordinate reference systemdatatype(): Data typedim() dim3d(): Number rows, columns, depthsext(), N(), S(), E(), W(), top(), bottom(): Spatial extentfreq(): Frequencies cell values rasteris.2d() .3d(): object 2- 3-dimensional?.int(), .cell(), .float(), .doub(): GRaster data type (integer/float/double).factor(): raster represent categorical data?.lonlat(): object projected (e.g., WGS84)?levels(): Names levels categorical GRasterminmax(): Minimum maximum values across non-NA cellsnames(): GRaster namesncol(): Number columnsnacell(): Number NA cellsncell(): Number cellsncell3d(): Number cells 3D GRasterndepth(): Number depths 3D GRasternlyr(): Number layersnonnacell(): Number non-NA cellsnrow(): Number rowsnlevels(): Number categoriesres(), xres(), yres(), zres(): Spatial resolutionsources(): Name GRaster GRASStopology(): Dimensionality (2D 3D)zext(): Vertical extentzres(): Vertical resolution","code":""},{"path":"/reference/fasterRaster.html","id":"functions-that-operate-on-or-create-grasters","dir":"Reference","previous_headings":"","what":"Functions that operate on or create GRasters","title":"","text":"Arithmetic: Mathematical operations GRasters: +, -, *, /, ^, %% (modulus), %/% (integer division)Logical comparisons: <, <=, ==, !=, >=, >, plus %% %notin% (categorical rasters )Logical operators: |& Single-layer mathematical functions (applied layer GRaster): Working NAs: .na(), .na(), maskNA() Trigonometry: sin(), cos(), tan(), asin(), acos(), atan(), atan2() Logarithms powers: exp(), log(), ln(), log1p(), log2(), log10(), sqrt() Rounding: round(), floor(), ceiling(), trunc() Signs: abs() Multi-layer functions (applied across layers \"stack\" GRasters): Numeration: sum(), count() Central tendency: mean(), mmode(), median() Dispersion: stdev(), var(), varpop(), nunique(), range(), quantile(), skewness(), kurtosis() Extremes: min(), max(), .min(), .max() operators $ [[ can used subset remove specific layers GRaster. [<- operator can used replace values cells GRaster. assign operators, $<-, [[<-, add<- can used replace specific layers GRaster..int(), .float(), .doub(): Change data type (integer/float/double).lines(): Convert GRaster \"lines\" vectoras.points(): Convert GRaster \"points\" vectoras.polygons(): Convert GRaster \"polygons\" vectoraggregate(): Aggregate values GRaster cells larger cellsbioclims(): BIOCLIM rasters (classic set extended set)buffer(): Create buffer around non-NA cellsapp(): Apply user-defined function multiple layers GRaster (helper functions appFuns() appCheck())c(): \"Stack\" two rasterscellSize(): Cell areaclassify(): Partition cell values strataclump(): Group adjacent cells similar valuescombineCats(): Combine values two categorical /integer rasterscombineLevels(): Combine \"levels\" tables two categorical GRasterscrop(): Remove parts GRasterdenoise(): Remove \"noise\" GRaster using principal components analysis (PCA)distance(): Distance non-NA cells, vice versaextend(): Add rows columns GRasterextract(): Extract values GRaster locations GVectorfillNAs(): Fill NA cellsfocal(): Calculate cell values based values nearby cellsfragmentation(): Landscape fragmentation class Riitters et al. (2020)global(): Summary statistics across cells GRaster layerhist(): Histogram GRaster valuesinterpIDW(): Interpolate values points GRasterkernel(): Kernel density estimator pointslayerCor(): Correlation covariance two GRaster layerslonglat(): Create longitude/latitude rastersmask(): Remove values GRaster based values another GRaster vectormaskNA(): Mask non-NA cells NA cellsmatch(), %%, %notin%: Find cells GRaster match match certain valuesmerge(): Combine two rasters different extents fill NAsnames<-: Assign names GRasternoise(): Remove coarse-scale trends GRaster, leaving just fine-scale \"noise\"pairs(): Plot correlations GRaster layerspca(): Apply principal components analysis (PCA) GRasterpcs(): Retrieve principal components model PCA GRaster generated using pca()plot(): Display GRasterplotRGB(): Display multispectral GRaster using red, blue, green, alpha channelsproject(): Change coordinate reference system cell sizepredict(): Make predictions GRaster linear model generalized linear modelresample(): Change cell sizereorient(): Convert degrees 'north-orientation' 'east orientation'scale(), scalepop(), unscale(): Subtract means divide standard deviations, inverse thatselectRange(): Select values rasters stack based values another GRasterspatSample(): Randomly points GRastersubst(): Re-assign cell valuesthinLines(): Reduce linear features GRaster linear features 1 cell widetiles(): Divide GRaster spatially exclusive subsets (though possible overlap)trim(): Remove rows columns GRaster NAzonal(): Statistics (mean, sum, etc.) areas GRaster defined sets cells values another GRaster, geometries GVectorzonalGeog(): Geographic statistics (area, perimeter, fractal dimension, etc.) sets cells values","code":""},{"path":"/reference/fasterRaster.html","id":"functions-for-creating-grasters-de-novo","dir":"Reference","previous_headings":"","what":"Functions for creating GRasters de novo","title":"","text":"fractalRast(): Create fractal GRasterrnormRast(): random GRaster values drawn normal distributionrSpatialDepRast(): Create random GRaster without spatial dependencerunifRast(): random GRaster values drawn uniform distributionsineRast(): Sine wave rasters","code":""},{"path":"/reference/fasterRaster.html","id":"functions-for-analysis-of-terrain-and-flow-of-water-across-landscapes","dir":"Reference","previous_headings":"","what":"Functions for analysis of terrain and flow of water across landscapes","title":"","text":".contour(): Contour lines GRasterflow(): Identify watershed basins direction accumulation flowflowPath(): Path water flow across landscapegeomorphons(): Identify terrain feature typeshillshade(): Create hillshade GRasterhorizonHeight(): Horizon heightsun(): Solar radiance irradianceruggedness(): Terrain Ruggedness Indexstreams(): Create stream networkterrain(): Slope, aspect, curvature, partial slopeswetness(): Topographic wetness index","code":""},{"path":"/reference/fasterRaster.html","id":"functions-operating-on-categorical-factor-rasters","dir":"Reference","previous_headings":"","what":"Functions operating on categorical (factor) rasters","title":"","text":"%%, %notin%: Mask cells match match given categoryactiveCat() activeCats(): Column(s) defines category labelsactiveCat<-: Set column defines category labelsaddCats(): Add new columns \"levels\" tableaddCats<-: Add new rows (levels) \"levels\" tablecategories(): Set \"levels\" table specific layers categorical rastercatNames(): Column names \"levels\" tablecats(): \"Levels\" table categorical rastercombineCats(): Combine categories two categorical rasterscombineLevels(): Combine \"levels\" tables two categorical GRasterscomplete.cases(): Find rows categorical GRaster's \"levels\" table NAs themdroplevels(): Remove one levelsfreq(): Frequency category across cells rasteris.factor(): raster categorical?levels(): \"Levels\" table categorical rasterlevels<-: Set \"levels\" table categorical rastermatch(), %%, %notin%: Find cells GRaster match match certain category labelsminmax(): \"Lowest\" \"highest\" category values categorical rasters (argument levels = TRUE)missing.cases(): Find rows categorical GRaster's \"levels\" table least one NA themmissingCats(): Values category assigned themnlevels(): Number levelssubst(): Re-assign category levelszonalGeog(): Geographic statistics (area, perimeter, fractal dimension, etc.) sets cells values","code":""},{"path":"/reference/fasterRaster.html","id":"functions-for-analysis-of-remote-sensing-rasters","dir":"Reference","previous_headings":"","what":"Functions for analysis of remote sensing rasters","title":"","text":"compositeRGB(): Combine red, green, blue color bands make composite GRasterplotRGB(): Display multispectral GRaster using red, blue, green, alpha channelsvegIndex(): Vegetation indices surface reflectance","code":""},{"path":"/reference/fasterRaster.html","id":"functions-that-operate-on-terra-spatrasters","dir":"Reference","previous_headings":"","what":"Functions that operate on terra SpatRasters","title":"","text":"bioclims(): BIOCLIM rasters (classic set extended set)fragmentation(): Landscape fragmentation class Riitters et al. (2020)","code":""},{"path":"/reference/fasterRaster.html","id":"properties-of-gvectors","dir":"Reference","previous_headings":"","what":"Properties of GVectors","title":"","text":"crs(): Coordinate reference systemdatatype(): Data type fieldsdim(): Number geometries columnsexpanse(): Area polygons length linesext(), N(), S(), E(), W(), top(), bottom(): Spatial extentgeomtype(): Type vector (points, lines, polygons).2d() .3d(): object 2- 3-dimensional?.lonlat(): object projected (e.g., WGS84)?.points(), .lines(), .polygons(): GVector represent points, lines, polygons?names(): Names GVector fieldsncol(): Number fieldsngeom(): Number geometries (points, lines, polygons)nrow(): Number rows vector data tablensubgeom(): Number subgeometries (points, lines, polygons make single- multipart geometries)sources(): Name vector GRASStopology(): Dimensionality (2D 3D)zext(): Vertical extent","code":""},{"path":"/reference/fasterRaster.html","id":"functions-that-operate-on-or-create-gvectors","dir":"Reference","previous_headings":"","what":"Functions that operate on or create GVectors","title":"","text":"[ operator can used subset geometries GVector. $ [[ operators can used get columns GVector's data table. $<- operator can used replace specific columns GVector's data table add columns.addTable<-: Add data table GVectoraggregate(): Combine GVector geometriesas.data.frame(): Convert GVector's attribute table data.frameas.data.table(): Convert GVector's attribute table data.tableas.points(): Extract vertex coordinates \"lines\" \"polygons\" GVectorbuffer(): Create polygon around/inside GVectorclusterPoints(): Identify clusters pointscolbind(): Add columns data table GVectorcomplete.cases(): Find rows GVector's data table NAs themconnectors(): Create lines connecting nearest features two GVectorsconvHull(): Minimum convex hullcrds(): Extract coordinates GVectorcrop(): Remove parts GVectordelaunay(): Delaunay triangulationdisagg(): Separate multipart geometries singlepart geometriesdistance(): Distance geometries two GVector, GVector cells GRasterdropTable(): Remove data table GVectorerase() -: Remove part GVector overlaps anotherexpanse(): Area polygons length linesextract(): Extract values GVector specific pointsgrid(): Create grid GVectorhead(): First rows GVector's data tablehexagons(): Create hexagonal gridinterpIDW(): Interpolate values points GRaster using inverse-distance weightinginterpSplines(): Interpolate values points GRaster using splinesintersect() *: Intersection two GVectors.kernel(): Kernel density estimator points.missing.cases(): Find rows GVector's data table least NA themnames<-: Assign names columns GVectors data tableproject(): Change coordinate reference systemrasterize(): Convert GVector GRasterrbind(): Combine GVectorssimplifyGeom(): Remove verticessmoothGeom(): Remove \"angular\" aspects featuresst_as_sf(): Convert GVector sf vectorst_buffer(): Create polygon around/inside GVectortail(): Last rows GVector's data tablethinPoints(): Reduce number points raster cellunion() +: Combine two GVectorsxor() /``: Select parts polygons shared two GVector`s","code":""},{"path":"/reference/fasterRaster.html","id":"functions-for-fixing-issues-with-gvectors","dir":"Reference","previous_headings":"","what":"Functions for fixing issues with GVectors","title":"","text":"(See also tools can used GVector creation/loading fast().) breakPolys(): Break topologically clean areasfillHoles(): Fill \"holes\" GVectorfixBridges(): Change \"bridges\" \"islands\"fixDangles(): Change \"dangles\" hanging boundaries linesfixLines(): Break lines intersections lines form closed loopsremove0(): Remove boundaries lines length 0removeAngles(): Collapse lines diverge angle computationally equivalent 0removeBridges(): Remove \"bridges\" \"islands\"removeDangles(): Remove \"dangling\" linesremoveDupCentroids(): Remove duplicated area centroidsremoveDups(): Remove duplicated features area centroidsremoveSmallPolys(): Remove small polygonssnap(): Snap lines/boundaries ","code":""},{"path":"/reference/fasterRaster.html","id":"converting-between-data-types","dir":"Reference","previous_headings":"","what":"Converting between data types","title":"","text":".contour(): Convert GRaster GVector representing contour linesas.doub(): Convert GRaster double-floating point raster (GRASS data type DCELL).data.frame(): Convert GVector data.frameas.data.table(): Convert GVector data.tableas.float(): Convert GRaster floating-point raster (GRASS data type FCELL).int(): Convert GRaster integer raster (GRASS data type CELL).points(), .lines(), .polygons(): Convert GRaster GVectorfast(): Convert SpatRaster GRaster; SpatVector, sf vector, numeric vector, matrix, data.frame, data.table GVector; load vector raster filecategories() levels<-: Convert integer raster categorical (\"factor\") raster. rast(): Convert GRaster SpatRasterrasterize(): Convert GVector GRasterst_as_sf(): Convert GVector sf vectorvect(): Convert GVector SpatVector","code":""},{"path":"/reference/fasterRaster.html","id":"general-purpose-functions","dir":"Reference","previous_headings":"","what":"General purpose functions","title":"","text":"compareGeom(): Determine geographic metadata GRasters /GVectorsdropRows(): Remove rows data.frame data.tablegrassInfo(): GRASS version citationmow(): Remove unused rasters vectors GRASS cachereorient(): Convert degrees 'north-orientation' 'east orientation'replaceNAs(): Replace NAs columns data.table data.frame, vectorseqToSQL(): Format numeric series SQL value callupdate(): Refresh metadata GRaster GVector object","code":""},{"path":"/reference/fasterRaster.html","id":"data-objects","dir":"Reference","previous_headings":"","what":"Data objects","title":"","text":"appFunsTable (see also appFuns()): Functions usable app() functionmadChelsa: Climate rasters portion eastern MadagascarmadCoast0, madCoast4, madCoast: Borders eastern portion MadagascarmadCover: Land cover rastermadCoverCats: Table land cover classesmadDypsis: Specimens records species genus DypsismadElev: Elevation rastermadForest2000 madForest2014: Forest cover 2000 2014madLANDSAT: Surface reflectance 2023madPpt, madTmin, madTmax: Rasters mean monthly precipitation, minimum maximum temperaturemadRivers: Rivers vectorvegIndices: Vegetation indices can calculated using vegIndex().","code":""},{"path":"/reference/fasterRaster.html","id":"esoteric-tutorials-and-arcane-notes","dir":"Reference","previous_headings":"","what":"Esoteric tutorials and arcane notes","title":"","text":"Comparisons GRegions can performed using == != operators. Tutorial GRASS regions Tutorial GRASS projects/locations mapsetsHidden functions fasterRaster: Useful power users developersgrassStarted(): connection GRASS made within current R session?","code":""},{"path":[]},{"path":"/reference/fasterRaster.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"","text":"Adam B. Smith","code":""},{"path":"/reference/fillHoles.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill holes in a GVector — fillHoles,GVector-method","title":"Fill holes in a GVector — fillHoles,GVector-method","text":"fillHoles() removes holes GVector.","code":""},{"path":"/reference/fillHoles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill holes in a GVector — fillHoles,GVector-method","text":"","code":"# S4 method for class 'GVector' fillHoles(x, fail = TRUE)"},{"path":"/reference/fillHoles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill holes in a GVector — fillHoles,GVector-method","text":"x GVector. fail Logical: TRUE (default), GRASS 8.4 higher installed, cause error. FALSE, warning displayed NULL value returned. function requires GRASS 8.4 higher installed.","code":""},{"path":"/reference/fillHoles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill holes in a GVector — fillHoles,GVector-method","text":"GVector.","code":""},{"path":"/reference/fillHoles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill holes in a GVector — fillHoles,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/fillNAs.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","title":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","text":"function uses splines fill NA cells raster based values nearby cells. Depending method used, NA cells can filled.","code":""},{"path":"/reference/fillNAs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","text":"","code":"# S4 method for class 'GRaster' fillNAs(   x,   lambda = NULL,   method = \"bilinear\",   min = -Inf,   max = Inf,   cells = Inf )"},{"path":"/reference/fillNAs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","text":"x GRaster. lambda Either NULL (default), numeric value > 0: NULL, function use leave-one-crossvalidation find optimal value. method Character: Type spline, either \"bilinear\" (default), \"bicubic\", \"RST\" (regularized splines tension). Partial matching used case ignored. Note: RST method often display warnings, thesecan ignored. min, max Numeric: Lowest highest values allowed interpolated values. Values outside bounds truncated minimum/maximum value(s) allowed. default imposes constraints. multi-layered rasters, can supply single value min /max, multiple values (one per layer). Values recycled fewer one per layer raster. cells Integer numeric integer: Number cells away non-NA cells fill. example, cells = 2, cells within 2-cell buffer non-NA cells filled. default Inf (fill possible cells–methods may able , depending configuration raster).","code":""},{"path":"/reference/fillNAs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/fillNAs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill NA cells in a raster using interpolation — fillNAs,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster: madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Fill NAs: biline <- interp <- fillNAs(elev) bicube <- interp <- fillNAs(elev, method = \"bicubic\") rst <- interp <- fillNAs(elev, method = \"rst\")  maps <- c(elev, biline, bicube, rst) names(maps) <- c(\"original\", \"bilinear\", \"bicubic\", \"RST\") plot(maps)  ### Constrain interpolated values to > 0 constrained <- fillNAs(elev, min = 0)  # Compare unconstrained and constrained: minmax(biline) minmax(constrained)  ### Interpolate to only first 10 cells away from non-NA cells: restrained <- fillNAs(elev, cells = 10)  maps <- c(elev, restrained) names(maps) <- c(\"Original\", \"within 10 cells\") plot(maps)  }"},{"path":"/reference/flow.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","title":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","text":"flow() function uses raster representing elevation compute rasters representing: Flow accumulation; Direction flow; Watershed basins; Flooded areas; /Topographic convergence (log flow accumulation divided local slope). details computations can found help page r.terraflow module GRASS.","code":""},{"path":"/reference/flow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","text":"","code":"# S4 method for class 'GRaster' flow(   x,   direction = \"multi\",   return = \"accumulation\",   dirThreshold = Inf,   scratchDir = tempdir() )"},{"path":"/reference/flow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","text":"x GRaster single layer, typically representing elevation. direction Character: Either \"single\" \"multi\". indicates whether single-direction flow multi-direction flow model used. default \"multi\". Partial matching used case ignored. return Character vector: Indicates rasters return. Partial matching used case ignored. Options include: \"accumulation\" (default): Flow accumulation raster. \"basins\": Watershed basins \"direction\": Flow direction \"flooded\": Flooded areas \"TCI\": Topographic convergence index \"*\": dirThreshold Numeric (default Inf): multi-direction flow model, indicates amount accumulated flow single-direction flow rule used locate egress water cell. d8cut parameter r.stream.extract. scratchDir Character: Directory store temporary files. GRASS module r.terraflow makes lot temporary files. default given tempdir().","code":""},{"path":"/reference/flow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/flow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify watershed basins and direction and accumulation of flow — flow,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") elev <- fast(madElev)  # Calculate flow accumulation and watershed basins water <- flow(elev, return = c(\"accum\", \"basins\")) water  elevWater <- c(elev, water) plot(elevWater)  }"},{"path":"/reference/flowPath.html","id":null,"dir":"Reference","previous_headings":"","what":"Path of water flow across a landscape — flowPath,GRaster-method","title":"Path of water flow across a landscape — flowPath,GRaster-method","text":"function finds least-cost pathway set starting points lowest cells accessible , step, traversing \"\" slope gradients. intended depict path drop water take flowing across landscape. single starting point, defaults settings produce raster cells values 1 along path. cells set NA.","code":""},{"path":"/reference/flowPath.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Path of water flow across a landscape — flowPath,GRaster-method","text":"","code":"# S4 method for class 'GRaster' flowPath(x, y, return = \"ID\")"},{"path":"/reference/flowPath.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Path of water flow across a landscape — flowPath,GRaster-method","text":"x GRaster single layer, typically representing elevation. y \"points\" GVector. GVector must <= 1024 points. return Character: Indicates type values \"burned\" cells output raster. Case ignored partial matching used, one option can selected. \"ID\" (default): Cells path labeled index starting point. cell flow path first point value 1, cell flow path second point value 2, . \"sequence\": output raster's cells start 1 source point(s), accumulate next cell flow path 2, one 3, . \"copy\": cells flow path elevation raster's values cells along flow path(s). \"accumulation\": Cells flow path accumulate elevation raster's cell values. example, starting cell elevation 700 next cell drainage path value 600 one 500, first cell path value 700, next 1300 (= 700 + 600), third 1800 (= 700 + 600 + 500). numeric value: cells flow paths assigned value.","code":""},{"path":"/reference/flowPath.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Path of water flow across a landscape — flowPath,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/flowPath.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Path of water flow across a landscape — flowPath,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madCoast4 <- fastData(\"madCoast4\")  # Convert to GRaster and crop to a sub-portion (easier for visualizing) elev <- fast(madElev) coast4 <- fast(madCoast4) ant <- coast4[coast4$NAME_4 == \"Antanambe\"] elevAnt <- crop(elev, ant)  # Create a set of random points to serve as starting points: starts <- spatSample(elevAnt, 10, as.points = TRUE, seed = 1)  # Remove points in water: starts <- starts[complete.cases(starts)]  # Calculate flow paths and label each by ID: paths <- flowPath(elevAnt, starts) paths  plot(paths) plot(starts, pch = 1, add = TRUE)  # Calculate flow paths with cell values indicating the number # of cells from each start: seqs <- flowPath(elevAnt, starts, return = \"seq\")  plot(seqs) plot(starts, pch = 1, add = TRUE)  # We can convert flow paths to lines: seqLines <- as.lines(seqs) plot(seqLines) seqLines  }"},{"path":"/reference/focal.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate cell values based on values of nearby cells — focal,GRaster-method","title":"Calculate cell values based on values of nearby cells — focal,GRaster-method","text":"function calculates statistics moving \"neighborhood\" cells raster. neighborhood can square, circle, user-defined set cells (without weights).","code":""},{"path":"/reference/focal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate cell values based on values of nearby cells — focal,GRaster-method","text":"","code":"# S4 method for class 'GRaster' focal(x, w = 3, fun = \"sum\", circle = FALSE, quantile = 0.5)"},{"path":"/reference/focal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate cell values based on values of nearby cells — focal,GRaster-method","text":"x GRaster. w Numeric integer square matrix odd number rows columns: size nature neighborhood: \"Square\" neighborhoods (circle = FALSE): odd integer >= 3, indicating indicates size \"square\" neighborhood (number cells wide number cells tall). \"Circular\" neighborhoods (circle = TRUE): odd integer >=3, indicating diameter circle. matrix cell weights: matrix must square odd number rows columns (example: matrix(c(0.5, 1, 0.5, 1, 2, 1, 0.5, 1, 0.5), nrow=3)). use weights matrix circle = TRUE. Cells NA weight ignored. Note weighted matrices used function min, max, count, nunique, interspersion. fun Character: Name function apply neighborhood: \"mean\" (default) \"median\" \"mode\" \"min\" \"max\": Minumum maximum. use weights matrix. \"range\": Difference maximum minimum.  use weights matrix. \"sd\": Sample standard deviation.  NB: stats::sd() function. \"sdpop\": Population standard deviation. NB: function \"stddev\" GRASS module r.neighbors. \"sum\": Sum non-`NA“ cells. \"count\": Number non-`NA cells. use weights matrix. \"var\": Sample variance.  NB: stats::var() function. \"varpop\": Population variance. NB: function \"variance\" GRASS module r.neighbors. \"nunique\": Number unique values. use weights matrix. \"interspersion\": Proportion cells values different focal cell (e.g., 6 8 cells different values, interspersion 6/8 = 0.75). NB: slightly different defined GRASS module r.neighbors. use weights matrix. \"quantile\": Quantile values. value argument quantile used specify quantile. center cell value always included calculations, calculations ignore NA cells (.e., count cells focal neighborhood). circle Logical: FALSE (default), use square neighborhood. TRUE, use circular neighborhood. TRUE, argument w matrix. quantile Numeric 0 1, inclusive: Quantile calculate fun = \"quantile\". default value 0.5 (median), valid values must range 0 1, inclusive.","code":""},{"path":"/reference/focal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate cell values based on values of nearby cells — focal,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/focal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate cell values based on values of nearby cells — focal,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Focal calculations: sums <- focal(elev, fun = \"sum\") means <- focal(elev, fun = \"mean\")  # Focal calculations on a circular window: sds <- focal(elev, fun = \"sd\") # square sdsCircle <- focal(elev, fun = \"sd\", circle = TRUE) # circle  sds sdsCircle  plot(sds - sdsCircle)  # Focal calculations with user-defined weights: w <- matrix(c(1, 0, 1, 0, 1, 0, 1, 0, 1), ncol = 3) w sumsWeighted <- focal(elev, fun = \"sum\", w = w)  s <- c(sums, sumsWeighted) minmax(s)  }"},{"path":"/reference/fractalRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create fractal raster — fractalRast,GRaster-method","title":"Create fractal raster — fractalRast,GRaster-method","text":"fractalRast() creates raster fractal pattern.","code":""},{"path":"/reference/fractalRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create fractal raster — fractalRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' fractalRast(x, n = 1, mu = 0, sigma = 1, dimension = 2.05)"},{"path":"/reference/fractalRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create fractal raster — fractalRast,GRaster-method","text":"x GRaster. output extent dimensions raster. n numeric integer: Number rasters generate. mu, sigma Numeric: Mean sample standard deviation output. dimension Numeric: Fractal dimension. Must 2 3.","code":""},{"path":"/reference/fractalRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create fractal raster — fractalRast,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/fractalRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create fractal raster — fractalRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Create a raster with values drawn from a uniform distribution: unif <- runifRast(elev) plot(unif)  ### Create a raster with values drawn from a normal distribution: norms <- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1)) plot(norms) hist(norms, bins = 100)  # Create a raster with random, seemingly normally-distributed values: rand <- rSpatialDepRast(elev, dist = 1000) plot(rand)  # Values appear normal on first inspection: hist(rand)  # ... but actually are patterned: hist(rand, bins = 100)  # Create a fractal raster: fractal <- fractalRast(elev, n = 2, dimension = c(2.1, 2.8)) plot(fractal) hist(fractal)  }"},{"path":"/reference/fragmentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"Riitters et al. (2020) propose classification scheme forest fragmentation (can applied habitat type). scheme relies calculating density (e.g., number forested cells window around focal cell) connectivity (number cases neighboring cells forested). function calculates classes GRaster SpatRaster focal habitat type cell values 1, non-focal habitat type cell values 0 NA. Note default, SpatRaster GRaster versions create different results around border raster. SpatRaster version uses terra::focal() function, return NA value window overlaps raster border na.rm argument TRUE. However, GRaster version uses GRASS module r.neighbors, return NA values cases. fragmentation classes : Value provided none: None (.e., forest; default NA). 1: Patch 2: Transitional 3: Perforated 4: Edge 5: Undetermined (possible obtain w = 3) 6: Interior","code":""},{"path":"/reference/fragmentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"","code":"# S4 method for class 'SpatRaster' fragmentation(   x,   w = 3,   undet = \"undetermined\",   none = NA,   na.rm = TRUE,   cores = faster(\"cores\"),   verbose = TRUE )  # S4 method for class 'GRaster' fragmentation(x, w = 3, undet = \"undetermined\", none = NA, verbose = TRUE)"},{"path":"/reference/fragmentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"x SpatRaster GRaster. w odd, positive integer: Size window across fragmentation calculated (units \"rows\" \"columns\"). default 3, meaning function uses 3x3 moving window calculate fragmentation. large rasters, compute time ~O(N) + O(N * w^2), N number cells raster. , even small increase w can increase compute time lot. undet Character: assign \"undetermined\" case. Valid values \"perforated\" (default), \"edge\", \"undetermined\". Partial matching used. Pf proportional density raster cell value Pff proportional connectivity raster cell value, undetermined case occurs Pf > 0.6 Pf == Pff. none Integer NA (default): Value assign cell focal habitat. Riitters et al. use NA. forced integer actual integer. na.rm Logical: TRUE (default) x SpatRaster, cells near edge raster window overlaps edge can still assigned fragmentation class. FALSE, cells assigned value none. cores Integer: Number processor cores use processing SpatRaster. verbose Logical: TRUE (default), display progress.","code":""},{"path":"/reference/fragmentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"categorical SpatRaster GRaster. values assigned class can seen levels().","code":""},{"path":"/reference/fragmentation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"Riitters, K., J. Wickham, R. O'Neill, B. Jones, E. Smith. 2000. Global-scale patterns forest fragmentation. Conservation Ecology 4:3. URL: http://www.consecol.org/vol4/iss2/art3/. Also note errata.","code":""},{"path":"/reference/fragmentation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Landscape fragmentation class following Riitters et al. (2020) — fragmentation,SpatRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: madForest <- fastData(\"madForest2000\") # raster  ### Fragmentation classes from a SpatRaster ###########################################  fragTerra <- fragmentation(madForest) plot(fragTerra) levels(fragTerra) freq(fragTerra)  ### Fragmentation classes from a GRaster ########################################  # Convert to GRaster: forest <- fast(madForest)  # Fragmentation class: frag <- fragmentation(forest) plot(frag) levels(frag) freq(frag)  }"},{"path":"/reference/freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequencies of cell values in a raster — freq,GRaster-method","title":"Frequencies of cell values in a raster — freq,GRaster-method","text":"freq() tabulates frequency cell values raster. rasters datatype() integer factor, frequency value level reported. rasters, range values divided bins, number cells values bin reported.","code":""},{"path":"/reference/freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequencies of cell values in a raster — freq,GRaster-method","text":"","code":"# S4 method for class 'GRaster' freq(x, digits = 3, bins = 100, value = NULL)"},{"path":"/reference/freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequencies of cell values in a raster — freq,GRaster-method","text":"x GRaster. digits Numeric integer: Number digits round raster values. Ignored integer categorical rasters. bins Positive numeric integer: Number bins divide values numeric rasters. default 100. integer categorical rasters, value tallied (.e., ignored). value Numeric NULL (default): numeric, cells value counted. NULL, values counted.","code":""},{"path":"/reference/freq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequencies of cell values in a raster — freq,GRaster-method","text":"data.frame named list data.frames, one per layer x.","code":""},{"path":[]},{"path":"/reference/freq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frequencies of cell values in a raster — freq,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") # raster madCover <- fastData(\"madCover\") # categorical raster  # Convert to GRasters elev <- fast(madElev) # raster cover <- fast(madCover) # categorical raster  # Frequencies of integer raster values f <- freq(elev) print(f) # have to do this sometimes if output is a data table  # Frequencies of categorical raster values f <- freq(cover) print(f) # have to do this sometimes if output is a data table  # Frequencies of given values f <- freq(elev, value = 1) print(f) # have to do this sometimes if output is a data table  # When a GRaster has non-integer values, they will be binned: f <- freq(elev + 0.1, bins = 10) print(f)  }"},{"path":"/reference/functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Mathematical operations on two or more GRasters — mean,GRaster-method","title":"Mathematical operations on two or more GRasters — mean,GRaster-method","text":"functions can applied \"stack\" GRasters two layers. return single-layered GRaster.  want summarize across cells raster (e.g., calculate mean value cells raster), use global(). Options include: Numeration: count() (number non-NA cells), sum(). Central tendency: mean(), mmode() (mode), median(). Extremes: min(), max(), .min() (index raster minimum value), .max() (index raster maximum value) Dispersion: range(), stdev() (standard deviation), var() (sample variance), varpop() (population variance), nunique() (number unique values), quantile() (use argument probs), skewness(), kurtosis(). Regression: Assuming calculate linear regression set cells values cells, can calculate slope(), intercept(), r2(), tvalue().","code":""},{"path":"/reference/functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mathematical operations on two or more GRasters — mean,GRaster-method","text":"","code":"# S4 method for class 'GRaster' mean(x, na.rm = FALSE)  # S4 method for class 'GRaster' mmode(x, na.rm = FALSE)  # S4 method for class 'GRaster' median(x, na.rm = FALSE)  # S4 method for class 'GRaster' count(x)  # S4 method for class 'GRaster' sum(x, na.rm = FALSE)  # S4 method for class 'GRaster' min(x, na.rm = FALSE)  # S4 method for class 'GRaster' max(x, na.rm = FALSE)  # S4 method for class 'GRaster' which.min(x)  # S4 method for class 'GRaster' which.max(x)  # S4 method for class 'numeric' sdpop(x, na.rm = FALSE)  # S4 method for class 'GRaster' varpop(x, na.rm = FALSE)  # S4 method for class 'numeric' varpop(x, na.rm = FALSE)  # S4 method for class 'GRaster' stdev(x, pop = TRUE, na.rm = FALSE)  # S4 method for class 'GRaster' var(x, na.rm = FALSE)  # S4 method for class 'GRaster' nunique(x, na.rm = FALSE)  # S4 method for class 'GRaster' skewness(x, na.rm = FALSE)  # S4 method for class 'GRaster' kurtosis(x, na.rm = FALSE)  # S4 method for class 'GRaster' slope(x, na.rm = FALSE)  # S4 method for class 'GRaster' intercept(x, na.rm = FALSE)  # S4 method for class 'GRaster' r2(x, na.rm = FALSE)  # S4 method for class 'GRaster' tvalue(x, na.rm = FALSE)  # S4 method for class 'GRaster' range(x, na.rm = FALSE)  # S4 method for class 'GRaster' quantile(x, prob, na.rm = FALSE)"},{"path":"/reference/functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mathematical operations on two or more GRasters — mean,GRaster-method","text":"x GRaster. Typically, raster two layers. Values calculated within cells across rasters. na.rm Logical: FALSE (default), one cell value NA, result NA. TRUE, NAs ignored. pop Logical (stdev()): TRUE (default), calculate population standard deviation across layers. FALSE, calculate sample standard deviation. prob Numeric: Quantile calculate. Used quantile().","code":""},{"path":"/reference/functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mathematical operations on two or more GRasters — mean,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mathematical operations on two or more GRasters — mean,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev) elevs <- c(elev, elev, log10(elev) - 1, sqrt(elev)) names(elevs) <- c(\"elev1\", \"elev2\", \"log_elev\", \"sqrt_elev\")  elev elevs  # do some math elev + 100 elev - 100 elev * 100 elev / 100 elev ^ 2 elev %/% 100 # divide then round down elev %% 100 # modulus  100 + elev 100 %/% elev 100 %% elev  elevs + 100 100 + elevs  # math with logicals elev + TRUE elev - TRUE elev * TRUE elev / TRUE elev ^ TRUE elev %/% TRUE # divide then round down elev %% TRUE # modulus  elevs + TRUE TRUE + elevs  # Raster interacting with raster(s): elev + elev elev - elev elev * elev elev / elev elev ^ log(elev) elev %/% sqrt(elev) # divide then round down elev %% sqrt(elev) # modulus  elevs + elev elev * elevs  # sign abs(-1 * elev) abs(elevs)  # powers sqrt(elevs)  # trigonometry sin(elev) cos(elev) tan(elev)  asin(elev) acos(elev) atan(elev)  atan(elevs) atan2(elev, elev^1.2) atan2(elevs, elev^1.2) atan2(elev, elevs^1.2) atan2(elevs, elevs^1.2)  # logarithms exp(elev) log(elev) ln(elev) log2(elev) log1p(elev) log10(elev) log10p(elev) log(elev, 3)  log(elevs)  # rounding round(elev + 0.5) floor(elev + 0.5) ceiling(elev + 0.5) trunc(elev + 0.5)  # comparison elev < 100 elev <= 100 elev == 100 elev != 100 elev > 100 elev >= 100  elev + 100 < 2 * elev  elevs > 10 10 > elevs  # logic elev < 10 | elev > 200 elev < 10 | cos(elev) > 0.9  elev < 10 | TRUE TRUE | elev > 200  elev < 10 | FALSE FALSE | elev > 200  elev < 10 & cos(elev) > 0.9  elev < 10 & TRUE TRUE & elev > 200  elev < 10 & FALSE FALSE & elev > 200  # Mathematical functions on GRasters with >= 2 layers: mean(elevs) mmode(elevs) median(elevs) nunique(elevs)  sum(elevs) count(elevs) min(elevs) max(elevs) range(elevs) skewness(elevs) kurtosis(elevs)  which.min(elevs) which.max(elevs)  slope(elevs) intercept(elevs) r2(elevs) tvalue(elevs)  stdev(elevs) stdev(elevs, pop = FALSE) var(elevs) varpop(elevs)  # Note: To get quantiles for each layer, use # global(x, \"quantile\", probs = 0.2). quantile(elevs, 0.1)  }"},{"path":"/reference/geomorphons.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify terrain feature types — geomorphons,GRaster-method","title":"Identify terrain feature types — geomorphons,GRaster-method","text":"Geomorphons idealized terrain types calculated elevator raster based moving window given size. window torus (can inner radius 0, can also circle), allows identify geomorphons given size ignoring ones larger smaller. 10 basic geomorphons. Consult GRASS module r.geomorphon details diagrams type geomorphon. include: Flat areas: Focal area approximately elevation surrounding areas Pits: area lower surrounding areas Valley: Focal area elevation similar two opposing side window lower two opposing sides Footslope: Focal region \"bottom\" slope Hollow: small valley/indention crest hill Slope: Cells window form approximately uniform slope Spur: extrusion foot hill (.e.,, small hill extending foot slope) Shoulder: crest slope Ridge: Opposite valley; focal area higher two opposing sides approximately elevation two opposing sides Peak: Focal area higher window","code":""},{"path":"/reference/geomorphons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify terrain feature types — geomorphons,GRaster-method","text":"","code":"# S4 method for class 'GRaster' geomorphons(   x,   inner = 0,   outer = 3,   unit = \"cells\",   flat = 1,   flatDist = 0,   mode = \"1\" )"},{"path":"/reference/geomorphons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify terrain feature types — geomorphons,GRaster-method","text":"x single-layer GRaster, typically representing elevation. inner, outer Integer: Inner outer radii torus used identify geomorphons, cells meters (set argument unit). inner default value 0 outer default value 3. outer radius sets maximum size geomorphon can identified, inner sets smallest size. unit \"meters\", value outer must larger smaller dimension cell east-west north-south directions. unit Character: Units inner outer; can either \"cells\" (default) \"meters\". Partial matching used. flat Numeric value >= 0: Minimum difference (degrees) focal area areas around geomorphon considered \"flat\". Larger cells (.e., ~1 km resolution larger) require smaller values (<<1) correctly identify flat areas. Higher values result areas classified \"flat\" geomorphons. default value 1. flatDist Numeric: Distance (meters) correct effect large distances diminished capacity identify \"flat\" geomorphons. distance focal area surrounding area surpasses distance, effective value flat reduced mode Character: Method implementing zenith/line--site search. Partial matching used: \"1\" (default): \"original\" geomorphon mode (GRASS module r.geomorphon, \"anglev1\" method) \"2\": Better handling cases equal zenith/nadir angles (\"anglev2\" method) \"2d\": \"2\", takes account zenith/nadir distance (\"anglev2_distance\" method)","code":""},{"path":"/reference/geomorphons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify terrain feature types — geomorphons,GRaster-method","text":"categorical GRaster geomorphon category.","code":""},{"path":[]},{"path":"/reference/geomorphons.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify terrain feature types — geomorphons,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Geomorphons: geos <- geomorphons(elev) geos levels(geos) # levels freq(geos) # frequencies  col <- c(\"gray90\", \"red\", \"orange\", \"blue\", \"green\", \"pink\", \"firebrick\",   \"purple\", \"gray50\", \"black\") plot(geos, col = col)  }"},{"path":"/reference/geomtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","title":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","text":"geomtype() reports whether GVector represents points, lines, polygons. \".*\" functions test whether GVector represents points, lines, polygons.","code":""},{"path":"/reference/geomtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","text":"","code":"# S4 method for class 'GVector' geomtype(x, grass = FALSE)  # S4 method for class 'GVector' is.points(x)  # S4 method for class 'GVector' is.lines(x)  # S4 method for class 'GVector' is.polygons(x)"},{"path":"/reference/geomtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","text":"x GVector. grass Logical: FALSE (default), return terra-like geometry types (\"points\", \"lines\", \"polygons\"). TRUE, return GRASS-like geometry types (\"point\", \"line\", \"area\"–note subset available types may \"true\" GRASS type).","code":""},{"path":"/reference/geomtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","text":"geomtype() returns either \"points\", \"lines\", \"polygons\" grass arguments FALSE, \"point\", \"line\", \"area\" grass TRUE. \".*\" functions return TRUE FALSE.","code":""},{"path":[]},{"path":"/reference/geomtype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geometry of a GVector (points, lines, or polygons) — geomtype,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/global.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary statistics for GRasters — global,GRaster-method","title":"Summary statistics for GRasters — global,GRaster-method","text":"global() calculates summary statistic across cells GRaster. returns single value layer raster.","code":""},{"path":"/reference/global.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary statistics for GRasters — global,GRaster-method","text":"","code":"# S4 method for class 'GRaster' global(x, fun = \"mean\", probs = seq(0, 1, 0.25), ...)  # S4 method for class 'missing' global(x, ...)"},{"path":"/reference/global.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary statistics for GRasters — global,GRaster-method","text":"x GRaster missing.  missing, vector accepted function names returned. fun Character vector: name function(s): \"*\": functions . \"cv\": Sample coefficient variation (expressed proportion mean). \"cvpop\": Population coefficient variation (expressed proportion mean). \"max\" \"min\": Highest lowest values across non-NA cells. NB: minmax() faster. \"mean\" (default): Average. \"meanAbs\": Mean absolute values. \"median\": Median. \"quantile\": Quantile (see also argument probs). \"range\": Range. Note following terra::global(), minimum maximum reported, actual range. \"sd\": Sample standard deviation (stats::sd()). \"sdpop\": Population standard deviation. \"sum\": Sum. \"var\": Sample variance (stats::var()). \"varpop\": Population variance. probs Numeric within range 0 1: Quantile(s) calculate quantile. ... arguments (unused).","code":""},{"path":"/reference/global.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary statistics for GRasters — global,GRaster-method","text":"x missing, function returns character vector accepted function names. x GRaster, data frame specified statistics returned.","code":""},{"path":[]},{"path":"/reference/global.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary statistics for GRasters — global,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Calculate global statistics: global(elev, fun = c(\"mean\", \"var\", \"varpop\")) global(elev, \"quantile\", probs = c(0.25, 0.5, 0.75))  global(elev, \"*\") # calculate all available functions  global() # vector of all functions  }"},{"path":"/reference/grassInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"GRASS citation, version, and copyright information — grassInfo","title":"GRASS citation, version, and copyright information — grassInfo","text":"Report GRASS citation, version/release year, version number, copyright information.","code":""},{"path":"/reference/grassInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GRASS citation, version, and copyright information — grassInfo","text":"","code":"grassInfo(x = \"citation\")"},{"path":"/reference/grassInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GRASS citation, version, and copyright information — grassInfo","text":"x Character: return. : \"citation\" (default) \"copyright\": Copyright information \"version\": Version number release year \"versionNumber\": Version number numeric, major minor (e.g., 8.3) Partial matching used case ignored.","code":""},{"path":"/reference/grassInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GRASS citation, version, and copyright information — grassInfo","text":"Character.","code":""},{"path":"/reference/grassInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GRASS citation, version, and copyright information — grassInfo","text":"","code":"if (grassStarted()) {  # Citation grassInfo()  # Version number grassInfo(\"version\")  # Version number grassInfo(\"versionNumber\")  # Version number grassInfo(\"versionNumber\")  # Copyright grassInfo(\"copyright\")  }"},{"path":"/reference/grassStarted.html","id":null,"dir":"Reference","previous_headings":"","what":"Has ","title":"Has ","text":"Returns TRUE FALSE, depending whether GRASS connection made within current R session. Usually used developers.","code":""},{"path":"/reference/grassStarted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Has ","text":"","code":"grassStarted()"},{"path":"/reference/grassStarted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Has ","text":"Logical.","code":""},{"path":"/reference/grassStarted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Has ","text":"","code":"grassStarted() #> [1] FALSE"},{"path":"/reference/grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a grid GVector — grid,GRaster-method","title":"Create a grid GVector — grid,GRaster-method","text":"function creates GVector \"wall--wall\" cells (like lattice). input can GVector GRaster, provides extent output.","code":""},{"path":"/reference/grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a grid GVector — grid,GRaster-method","text":"","code":"# S4 method for class 'GRaster' grid(x, nx = NULL, ny = NULL, use = \"number\", angle = 0)  # S4 method for class 'GVector' grid(x, nx = NULL, ny = NULL, use = \"number\", angle = 0)"},{"path":"/reference/grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a grid GVector — grid,GRaster-method","text":"x GRaster GVector. nx, ny Integer numeric: use \"number\", values represent number rows columns grid. use size, values represent size cells x- y-dimensions. use Character: generate grid. number (default), nx ny taken number grid cells. size, nx ny taken size grid cells. angle Numeric: Degrees rotate grid (north, clockwise).","code":""},{"path":"/reference/grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a grid GVector — grid,GRaster-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a grid GVector — grid,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Points vector of specimens of species in the plant genus Dypsis madCoast0 <- fastData(\"madCoast0\")  # Convert sf to a GVector: coast <- fast(madCoast0)  ### grid ########  # grid specified by number of cells in x-dimension g1 <- grid(coast, nx = 10) plot(coast, col = \"cornflowerblue\") plot(g1, add = TRUE)  # grid specified by number of cells in x- and y-dimension g2 <- grid(coast, nx = 10, ny = 5) plot(coast, col = \"cornflowerblue\") plot(g2, add = TRUE)  # grid specified by size of cells in both dimensions g3 <- grid(coast, nx = 1250, ny = 2000, use = \"size\") plot(coast, col = \"cornflowerblue\") plot(g3, add = TRUE)  ### hexagons ############  hexes <- hexagons(coast, ny = 10) plot(hexes) plot(coast, lwd = 2, add = TRUE)  hexes <- hexagons(coast, ny = 10, expand = c(0.3, 0.1)) plot(hexes) plot(coast, lwd = 2, add = TRUE)  }"},{"path":"/reference/head.html","id":null,"dir":"Reference","previous_headings":"","what":"Return first or last part of the data frame of a GVector — head,GVector-method","title":"Return first or last part of the data frame of a GVector — head,GVector-method","text":"Return first last part GVector's data table.","code":""},{"path":"/reference/head.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return first or last part of the data frame of a GVector — head,GVector-method","text":"","code":"# S4 method for class 'GVector' head(x, n = 6L, keepnums = TRUE, ...)  # S4 method for class 'GVector' tail(x, n = 6L, keepnums = TRUE, ...)"},{"path":"/reference/head.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return first or last part of the data frame of a GVector — head,GVector-method","text":"x GVector. n Integer: Number rows display. keepnums Logical: rownames present, create . Default TRUE. ... arguments.","code":""},{"path":"/reference/head.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return first or last part of the data frame of a GVector — head,GVector-method","text":"data.table data.frame.","code":""},{"path":[]},{"path":"/reference/head.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return first or last part of the data frame of a GVector — head,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/hexagons.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a hexagonal grid — hexagons,GRaster-method","title":"Create a hexagonal grid — hexagons,GRaster-method","text":"function creates GVector \"wall--wall\" hexagons. input can GVector GRaster, provides extent output.","code":""},{"path":"/reference/hexagons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a hexagonal grid — hexagons,GRaster-method","text":"","code":"# S4 method for class 'GRaster' hexagons(x, ny = 10, expand = 0, angle = 0)  # S4 method for class 'GVector' hexagons(x, ny = 10, expand = 0, angle = 0)"},{"path":"/reference/hexagons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a hexagonal grid — hexagons,GRaster-method","text":"x GRaster GVector. ny Integer numeric integer: Number rows hexagons span extent object x. expand One two numeric values: Expand region proportion directions (single value) x- y-dimensions separately. Expanding region can helpful ensure entire area interest covered polygons, can otherwise leave gaps edges. number rows columns increased, number hexagons span x still ny. angle Numeric: Degrees rotate grid (north, clockwise).","code":""},{"path":"/reference/hexagons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a hexagonal grid — hexagons,GRaster-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/hexagons.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a hexagonal grid — hexagons,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Points vector of specimens of species in the plant genus Dypsis madCoast0 <- fastData(\"madCoast0\")  # Convert sf to a GVector: coast <- fast(madCoast0)  ### grid ########  # grid specified by number of cells in x-dimension g1 <- grid(coast, nx = 10) plot(coast, col = \"cornflowerblue\") plot(g1, add = TRUE)  # grid specified by number of cells in x- and y-dimension g2 <- grid(coast, nx = 10, ny = 5) plot(coast, col = \"cornflowerblue\") plot(g2, add = TRUE)  # grid specified by size of cells in both dimensions g3 <- grid(coast, nx = 1250, ny = 2000, use = \"size\") plot(coast, col = \"cornflowerblue\") plot(g3, add = TRUE)  ### hexagons ############  hexes <- hexagons(coast, ny = 10) plot(hexes) plot(coast, lwd = 2, add = TRUE)  hexes <- hexagons(coast, ny = 10, expand = c(0.3, 0.1)) plot(hexes) plot(coast, lwd = 2, add = TRUE)  }"},{"path":"/reference/hillshade.html","id":null,"dir":"Reference","previous_headings":"","what":"Hillshading — hillshade,GRaster-method","title":"Hillshading — hillshade,GRaster-method","text":"Hillshade rasters often used display purposes make topographical relief look \"real\" eye.","code":""},{"path":"/reference/hillshade.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hillshading — hillshade,GRaster-method","text":"","code":"# S4 method for class 'GRaster' hillshade(x, angle = 45, direction = 0, zscale = 1)"},{"path":"/reference/hillshade.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hillshading — hillshade,GRaster-method","text":"x GRaster (typically representing elevation). angle Numeric: altitude sun horizon degrees. Valid values range [0, 90], default value 45 (half way horizon overhead). direction direction (azimuth) sun shining degrees. Valid values range 0 360. default 0, meaning sun due south (180 degrees) shining due north (0 degrees). Note function, 0 corresponds north 180 south, GRASS module r.relief, \"east orientation\" used (0 east, 90 north, etc.). zscale Numeric: Value exaggerate terrain. default 1.  Numbers greater increase apparent relief, less (even negative) diminish .","code":""},{"path":"/reference/hillshade.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hillshading — hillshade,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/hillshade.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hillshading — hillshade,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  # Calculate all topographic metrics topos <- terrain(elev, v = \"*\") topos  plot(topos) # NB Aspect has values of NA when it cannot be defined  # Calculate a hillshade raster hs <- hillshade(elev) plot(hs)  }"},{"path":"/reference/hist.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a histogram of raster values — hist,GRaster-method","title":"Plot a histogram of raster values — hist,GRaster-method","text":"function creates histogram values GRaster. function modeled graphics::hist(), actually uses graphics::barplot().","code":""},{"path":"/reference/hist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a histogram of raster values — hist,GRaster-method","text":"","code":"# S4 method for class 'GRaster' hist(x, layer, maxnl = 16, bins = 30, freq = TRUE, ...)"},{"path":"/reference/hist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a histogram of raster values — hist,GRaster-method","text":"x GRaster. layer Character, numeric, integer: Indicates layer multi-layer GRaster plot histogram. layer can identified using name() (character) index (numeric integer). missing, maxnl layers plotted. maxnl Maximum number layers create histograms. 16 default, ignored layer defined. bins Positive numeric integer: Number bins divide values raster continuous values. integer categorical rasters, value tallied. freq Logical: TRUE (default), plot frequency values. FALSE, plot density values (.e., number bin divided total number cells non-NA values). ... Arguments pass graphics::barplot().","code":""},{"path":"/reference/hist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a histogram of raster values — hist,GRaster-method","text":"named list data.frames (invisibly), one per layer plotted, creates graph.","code":""},{"path":"/reference/hist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a histogram of raster values — hist,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") # elevation raster madLANDSAT <- fastData(\"madLANDSAT\") # multi-layer raster madRivers <- fastData(\"madRivers\") # lines vector  # Convert SpatRaster to GRaster and SpatVector to GVector elev <- fast(madElev) rivers <- fast(madRivers) landsat <- fast(madLANDSAT)  # Plot: plot(elev) plot(rivers, add = TRUE)  # Histograms: hist(elev) hist(landsat)  # Plot surface reflectance in RGB: plotRGB(landsat, 3, 2, 1) # \"natural\" color plotRGB(landsat, 4, 1, 2, stretch = \"lin\") # emphasize near-infrared (vegetation)  # Make composite map from RGB layers and plot in grayscale: comp <- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]]) grays <- paste0(\"gray\", 0:100) plot(comp, col = grays)  }"},{"path":"/reference/horizonHeight.html","id":null,"dir":"Reference","previous_headings":"","what":"Horizon height — horizonHeight,GRaster-method","title":"Horizon height — horizonHeight,GRaster-method","text":"horizonHeight() uses raster representing elevation calculate height horizon particular direction cell raster. Height expressed radians degrees horizontal.","code":""},{"path":"/reference/horizonHeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Horizon height — horizonHeight,GRaster-method","text":"","code":"# S4 method for class 'GRaster' horizonHeight(   x,   units = \"radians\",   step = 90,   northIs0 = TRUE,   bufferZone = 0,   distance = 1,   maxDist = NULL )"},{"path":"/reference/horizonHeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Horizon height — horizonHeight,GRaster-method","text":"x GRaster. units Character: Units height. Either radians (default) degrees. Partial matching used. step Numeric integer 0 360, inclusive: Angle step size (degrees) calculating horizon height. direction horizon height calculated incremented 0 360, last value excluded. northIs0 Logical: TRUE (default), horizon height calculated 0-degree direction facing north,  proceed clockwise , \"north orientation\", 0 north, 90 east, 180 south, 270 west. FALSE, angles \"east orientation\", proceed counterclockwise east. , east 0, north 90, west 180, south 270. North orientation default function R, east orientation default GRASS module r.horizon. Note: sun() function requires aspect east orientation. bufferZone Numeric >= 0 (default 0): buffer specified width generated around raster calculation horizon angle. coordinate system longitude/latitude (e.g., WGS84 NAD83), specified degrees. Otherwise units map units (usually meters). distance Numeric 0.5 1.5, inclusive (default 1): determines step size searching horizon given point. default value 1 goes cell--cell (.e., search distance step size one cell width). maxDist Either NULL (default) numeric >= 0: Maximum distance consider finding horizon height meters. NULL, maximum distance full extent raster. Smaller values can decrease run time also reduce accuracy.","code":""},{"path":"/reference/horizonHeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Horizon height — horizonHeight,GRaster-method","text":"GRaster one layers. layers named height_xyz, xyz degrees north east, depending whether north east orientation used.","code":""},{"path":[]},{"path":"/reference/horizonHeight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Horizon height — horizonHeight,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # convert a SpatRaster to a GRaster elev <- fast(madElev)  # calculate horizon height in north and east directions hhNorth <- horizonHeight(elev) hhNorth plot(hhNorth)  # calculate horizon height in east and north directions hhEast <- horizonHeight(elev, northIs0 = FALSE) hhEast plot(hhEast)  }"},{"path":"/reference/interpIDW.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate values at points to a GRaster using inverse-distance weighting — interpIDW,GVector,GRaster-method","title":"Interpolate values at points to a GRaster using inverse-distance weighting — interpIDW,GVector,GRaster-method","text":"function interpolates values set points raster using inverse distance weighting (IDW).","code":""},{"path":"/reference/interpIDW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate values at points to a GRaster using inverse-distance weighting — interpIDW,GVector,GRaster-method","text":"","code":"# S4 method for class 'GVector,GRaster' interpIDW(x, y, field, nPoints = Inf, power = 2)"},{"path":"/reference/interpIDW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate values at points to a GRaster using inverse-distance weighting — interpIDW,GVector,GRaster-method","text":"x \"points\" GVector. y GRaster serve template interpolation: points x fall inside extent raster used interpolation. can increase extent GRaster using extend(). field Character, integer, numeric integer: Name index column x values interpolate. NULL x 3-dimensional \"points\" GVector, interpolation act z-coordinate point. nPoints Integer numeric integer: Number nearest points use interpolation. default use points (Inf). power Numeric value > 0: Power take distance interpolating. default value two, value point used interpolation \\(1 / d^2\\) d distance.","code":""},{"path":"/reference/interpIDW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate values at points to a GRaster using inverse-distance weighting — interpIDW,GVector,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/interpSplines.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","title":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","text":"function interpolates values data table \"points\" GVector GRaster using splines Tykhonov regularization avoid overfitting.","code":""},{"path":"/reference/interpSplines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","text":"","code":"# S4 method for class 'GVector,GRaster' interpSplines(   x,   y,   field,   method = \"bilinear\",   lambda = NULL,   solver = \"Cholesky\",   xlength = NULL,   ylength = NULL,   interpolate = TRUE,   verbose = is.null(lambda) )"},{"path":"/reference/interpSplines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","text":"x \"points\" GVector. y GRaster: output extent resolution raster. field Character integer numeric integer: Name index column x values interpolate. NULL x 3-dimensional \"points\" GVector, interpolation act z-coordinate point. method Character: method use interpolation can either \"bilinear\" (default) \"bicubic\". Partial matching used. lambda Either NULL (default) numeric value > 0: Tykhonov regularization parameter. NULL, cross-validation used determine optimal parameter value. Cross-validation can take quite . use cross-validation, output either GRaster data.frame, depending value interpolate. solver Character: Type solver use. Can either \"Cholesky\" \"cg\". Partial matching used case ignored. xlength, ylength Either NULL (default), numeric > 0: Length spline step x- y-directions. NULL, set 4 times length extent respective direction. interpolate Logical: TRUE (default), create GRaster interpolated values. FALSE, return table lambda values cross-validation. argument ignored lambda numeric value. verbose Logical: TRUE, display progress.","code":""},{"path":"/reference/interpSplines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","text":"Output depends values lambda interpolate: lambda NULL interpolate TRUE: GRaster attribute named lambdas. data.frame values lambda assessed, plus mean (mean residual value) rms (root mean square error). can see table using attr(output_raster, \"lambdas\", exact = TRUE). lambda NULL interpolate FALSE: data.frame values lambdas assessed, plus mean (mean residual value) rms (root mean square error). can see table using attr(output_raster, \"lambdas\", exact = TRUE). lambda number (interpolate ignored): GRaster.","code":""},{"path":"/reference/interpSplines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpolate values at points to a GRaster using splines — interpSplines,GVector,GRaster-method","text":"receive error, \"data within subregion. Consider increasing spline step values, try increasing values xlength ylength. cross-validation takes long, warnings/errors persist, can randomly subsample x ~100 points get optimum value lambda (using interpolate = FALSE), use value function without cross-validation (setting lambda equal value interpolate = TRUE).","code":""},{"path":[]},{"path":"/reference/intersect.html","id":null,"dir":"Reference","previous_headings":"","what":"Intersection of two GVectors — intersect,GVector,GVector-method","title":"Intersection of two GVectors — intersect,GVector,GVector-method","text":"intersect() function selects area overlap two GVectors type (points, lines polygons). can also use * operator (e.g., vect1 * vect2).","code":""},{"path":"/reference/intersect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Intersection of two GVectors — intersect,GVector,GVector-method","text":"","code":"# S4 method for class 'GVector,GVector' intersect(x, y)"},{"path":"/reference/intersect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Intersection of two GVectors — intersect,GVector,GVector-method","text":"x, y GVectors.","code":""},{"path":"/reference/intersect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Intersection of two GVectors — intersect,GVector,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/intersect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Intersection of two GVectors — intersect,GVector,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Polygon of coastal Madagascar and Dypsis specimens madCoast4 <- fastData(\"madCoast4\") # polygons madDypsis <- fastData(\"madDypsis\") # points  # Convert vectors: coast4 <- fast(madCoast4) dypsis <- fast(madDypsis)  # Create another polygons vector from a convex hull around Dypsis points hull <- convHull(dypsis)  ### union() ###########  unioned <- union(coast4, hull) plot(unioned)  plus <- coast4 + hull # same as union()  ### intersect #############  inter <- intersect(coast4, hull) plot(coast4) plot(hull, border = \"red\", add = TRUE) plot(inter, border = \"blue\", add = TRUE)  ### xor #######  xr <- xor(coast4, hull) plot(coast4) plot(xr, border = \"blue\", add = TRUE)  ### erase #########  erased <- erase(coast4, hull) plot(coast4) plot(erased, border = \"blue\", add = TRUE)  minus <- coast4 - hull # same as erase()  }"},{"path":"/reference/is.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","title":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","text":"Test whether GRaster GVector 2- 3-dimensional.","code":""},{"path":"/reference/is.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","text":"","code":"# S4 method for class 'GSpatial' is.2d(x)  # S4 method for class 'GSpatial' is.3d(x)"},{"path":"/reference/is.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","text":"x object inherits GSpatial class (.e., GRaster GVector).","code":""},{"path":"/reference/is.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","text":"Logical.","code":""},{"path":[]},{"path":"/reference/is.2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if a GRaster or GVector is 2- or 3-dimensional — is.2d,GSpatial-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/is.int.html","id":null,"dir":"Reference","previous_headings":"","what":"Data type of a raster — is.int,GRaster-method","title":"Data type of a raster — is.int,GRaster-method","text":"fasterRaster, rasters can three data types: \"factor\" (categorical rasters), \"integer\" (integers), \"float\" (floating point values, accurate 6th 9th decimal places), \"double\" (double-precision values, accurate 15th 17th decimal places). type raster can checked : .factor(): raster integer values categories matched integers (see levels()). .int(): values integers? Note .int() return FALSE categorical rasters, even though cell values technically integers. .cell(): values integers (TRUE integer categorical rasters). .float(): values floating-point precision? .doub(): values double-floating point precision?","code":""},{"path":"/reference/is.int.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data type of a raster — is.int,GRaster-method","text":"","code":"# S4 method for class 'GRaster' is.int(x)  # S4 method for class 'GRaster' is.cell(x)  # S4 method for class 'GRaster' is.float(x)  # S4 method for class 'GRaster' is.doub(x)  # S4 method for class 'GRaster' is.factor(x)"},{"path":"/reference/is.int.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data type of a raster — is.int,GRaster-method","text":"x GRaster.","code":""},{"path":"/reference/is.int.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data type of a raster — is.int,GRaster-method","text":"Logical.","code":""},{"path":[]},{"path":"/reference/is.int.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data type of a raster — is.int,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/is.lonlat.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if a coordinate reference system is unprojected — is.lonlat,character-method","title":"Test if a coordinate reference system is unprojected — is.lonlat,character-method","text":".lonlat() attempst determine coordinate reference system unprojected (e.g., WGS84, NAD83, NAD27, etc.). GRasters GVectors, function always correct. WKT character strings sf vectors, looking \"CONVERSION[\" tag WKT string (object's WKT string), finds one, returns FALSE. may truthful cases.","code":""},{"path":"/reference/is.lonlat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if a coordinate reference system is unprojected — is.lonlat,character-method","text":"","code":"# S4 method for class 'character' is.lonlat(x)  # S4 method for class 'GLocation' is.lonlat(x)  # S4 method for class 'sf' is.lonlat(x)"},{"path":"/reference/is.lonlat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if a coordinate reference system is unprojected — is.lonlat,character-method","text":"x WKT coordinate reference string object can obtained (e.g., GRaster, GVector, GRegion, GLocation, SpatRaster, SpatVector, sf object).","code":""},{"path":"/reference/is.lonlat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if a coordinate reference system is unprojected — is.lonlat,character-method","text":"Logical (TRUE unprojected, FALSE otherwise).","code":""},{"path":[]},{"path":"/reference/kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel density estimator of points — kernel,GVector-method","title":"Kernel density estimator of points — kernel,GVector-method","text":"kernel() creates raster using kernel density estimator density points \"points\" GVector.","code":""},{"path":"/reference/kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel density estimator of points — kernel,GVector-method","text":"","code":"# S4 method for class 'GVector' kernel(x, y, kernel = \"Epanechnikov\", optimize = TRUE, h = NULL)"},{"path":"/reference/kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel density estimator of points — kernel,GVector-method","text":"x \"points\" GVector. y GRaster: extent resolution raster used create density raster. Otherwise, values raster ignored. kernel Character: Name kernel function use. Possible values include: \"Epanechnikov\" (default) \"Gaussian\" \"uniform\" \"triangular\" \"quartic\" \"triweight\" \"cosine\" Partial matching used, case ignored. optimize Logical: TRUE (default), attempt find optimal radius less equal radius value using \"Gaussian\" kernel. FALSE, use radius value -. h Numeric NULL (default): Smoothing bandwidth kernel estimator. NULL, Epanechnikov kernel used, optimize TRUE, Silverman's rule--thumb used estimate optimal value h: $$h = 0.9 * min(\\sigma_x / n^1/6, \\sigma_y / n^1/6)$$ Gaussian kernel used, optimize TRUE, GRASS v.kernel function attempt identify optimal bandwidth, value h, h defined. Otherwise, h NULL, value arbitrarily set 1/5th shorter distance x- y-extent points.","code":""},{"path":"/reference/kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel density estimator of points — kernel,GVector-method","text":"GRaster.","code":""},{"path":"/reference/kernel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel density estimator of points — kernel,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, plant specimen collections, rivers vector, # outline of area vector madElev <- fastData(\"madElev\") madDypsis <- fastData(\"madDypsis\")  # Convert to fasterRaster format: elev <- fast(madElev) dypsis <- fast(madDypsis)  # Kernel density estimation: kde <- kernel(dypsis, elev) plot(kde) plot(dypsis, add = TRUE, pch = 1)  }"},{"path":"/reference/layerCor.html","id":null,"dir":"Reference","previous_headings":"","what":"Correlation between GRasters — layerCor,GRaster-method","title":"Correlation between GRasters — layerCor,GRaster-method","text":"function returns correlation covariance matrix two GRaster layers. function returns sample correlation covariance (.e., denominator n - 1).","code":""},{"path":"/reference/layerCor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Correlation between GRasters — layerCor,GRaster-method","text":"","code":"# S4 method for class 'GRaster' layerCor(x, fun = \"cor\")"},{"path":"/reference/layerCor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Correlation between GRasters — layerCor,GRaster-method","text":"x GRaster two layers. fun Character: Name statistic calculate; either \"cor\" (default) \"cov\".","code":""},{"path":"/reference/layerCor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Correlation between GRasters — layerCor,GRaster-method","text":"numeric matrix.","code":""},{"path":[]},{"path":"/reference/layerCor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Correlation between GRasters — layerCor,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madChelsa <- fastData(\"madChelsa\")  # Convert a SpatRaster to a GRaster: chelsa <- fast(madChelsa)  # Correlation layerCor(chelsa, \"cor\")  # Covariance layerCor(chelsa, \"cov\")  }"},{"path":"/reference/levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Set and get categories for categorical rasters — levels,GRaster-method","title":"Set and get categories for categorical rasters — levels,GRaster-method","text":"GRasters can represent categorical data. Cell values actually integers, corresponding category, \"desert\" \"wetland.\" categorical raster associated table matches value category name. table must NULL (.e., categories–categorical raster), least two columns. first column must integers represent raster values. One subsequent columns must category labels. column labels \"active category\". levels(): Displays \"levels\" table raster (just value active category columns). cats(): Displays entire \"levels\" table raster. levels()<-: (Re)assigns \"levels\" table layer raster. Assigning \"levels\" table integer raster makes categorical raster. categories(): (Re)assigns \"levels\" table specific layer(s) raster. complete list functions relevant categorical rasters, see raster data types.","code":""},{"path":"/reference/levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set and get categories for categorical rasters — levels,GRaster-method","text":"","code":"# S4 method for class 'GRaster' levels(x)  # S4 method for class 'GRaster' cats(x, layer = 1:nlyr(x))  # S4 method for class 'GRaster' categories(x, layer = 1, value, active = 1)  # S4 method for class 'GRaster,data.frame' levels(x) <- value  # S4 method for class 'GRaster,data.table' levels(x) <- value  # S4 method for class 'GRaster,GRaster' levels(x) <- value  # S4 method for class 'GRaster,list' levels(x) <- value"},{"path":"/reference/levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set and get categories for categorical rasters — levels,GRaster-method","text":"x GRaster. layer Numeric integers, logical vector, character: cats() categories(), specifies layer(s)obtain level(s). value data.frame, data.table, list data.frames data.tables one per raster layer, categorical SpatRaster. table's first column \"value\" column must contain numeric values (class numeric character). SpatRaster supplied, categories transferred GRaster. active integer character: index column name column used category labels (\"active column\"). Following terra::activeCat(), first column \"levels\" table ignored, value 1 means use second column table labels. value 2 means use third column, .","code":""},{"path":"/reference/levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set and get categories for categorical rasters — levels,GRaster-method","text":"Values returned : levels() cats(): list data.frames data.tables, one per raster layer. levels()<- categories(): GRaster.","code":""},{"path":[]},{"path":"/reference/levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set and get categories for categorical rasters — levels,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/location.html","id":null,"dir":"Reference","previous_headings":"","what":"GRASS ","title":"GRASS ","text":"GRASS \"locations\" sets one rasters /vectors coordinate reference systems, may may represent actual location Earth. GRASS \"mapsets\" like sub-folders locations, collections rasters /vectors typically related general project. Typical users need make changes default location (called \"location\") mapset (called \"PERMANENT\"). function deletes GRASS \"location\" mapsets, rasters, vectors therein. function used cautiously mainly use developers.","code":""},{"path":"/reference/location.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GRASS ","text":"","code":"# S4 method for class 'GLocation' .location(x)  # S4 method for class 'missing' .location(x)  .locationDelete(location, mapset = NULL, workDir = NULL)"},{"path":"/reference/location.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GRASS ","text":"x Either: Missing: Reports location currently active session. GLocation object object contains GLocation class (.e., GSpatial object: GRaster GVector). location Character: Name GRASS \"location\". mapset Character NULL (default): Name mapset delete. NULL, mapsets given \"location\" deleted. workDir Character: Either NULL (default) character string directory location removed resides. NULL, working directory obtained faster(\"workDir\").","code":""},{"path":"/reference/location.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GRASS ","text":"character string. successful, TRUE (invisibly). , FALSE (also invisibly), plus warning.","code":""},{"path":[]},{"path":"/reference/location.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GRASS ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  } if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/locationCreate.html","id":null,"dir":"Reference","previous_headings":"","what":"Connect to ","title":"Connect to ","text":"function initializes GRASS \"location\". need run function (often just ) use functions fasterRaster. function use developers, users.","code":""},{"path":"/reference/locationCreate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connect to ","text":"","code":"# S4 method for class 'character' .locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)  # S4 method for class 'SpatRaster' .locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)  # S4 method for class 'SpatVector' .locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)  # S4 method for class 'sf' .locationCreate(x, location = NULL, overwrite = FALSE, warn = TRUE)"},{"path":"/reference/locationCreate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connect to ","text":"x object coordinate reference system (CRS) can acquired. Ergo, : SpatRaster, SpatVector, SpatExtent, stars, sf object crs object (.e., sf::st_crs()). CRS (coordinate reference system) WKT string. PROJ4 strings might work, . location Character NULL (default): Name location. overwrite Logical: FALSE (default), GRASS \"coordinate reference frame\" given name already created, function fail. TRUE, existing GRASS \"coordinate reference frame\" name overwritten. NOTE: remove R objects associated rasters vectors \"location\", longer work objects point overwritten. warn Logical: TRUE (default) overwrite TRUE, display warning.","code":""},{"path":"/reference/locationCreate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connect to ","text":"GLocation object (invisibly).","code":""},{"path":"/reference/locationCreate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connect to ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/locationFind.html","id":null,"dir":"Reference","previous_headings":"","what":"Match CRS of a GSpatial object and an existing ","title":"Match CRS of a GSpatial object and an existing ","text":"function searches set available GRASS \"locations\" one coordinate reference system matching GSpatial object. none found, connection GRASS yet made, returns NULL. Otherwise, returns either index name matching location.","code":""},{"path":"/reference/locationFind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match CRS of a GSpatial object and an existing ","text":"","code":"# S4 method for class 'missing' .locationFind(x, return = \"name\")  # S4 method for class 'GLocation' .locationFind(x, return = \"name\", match = \"name\")  # S4 method for class 'SpatRaster' .locationFind(x, return = \"name\", match = \"name\")  # S4 method for class 'SpatVector' .locationFind(x, return = \"name\", match = \"name\")  # S4 method for class 'sf' .locationFind(x, return = \"name\", match = \"name\")  # S4 method for class 'character' .locationFind(x, return = \"name\", match = \"name\")"},{"path":"/reference/locationFind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match CRS of a GSpatial object and an existing ","text":"x Either: Missing: Returns names coordinate reference system strings \"locations\". character representing coordinate reference system WKT format SpatRaster, SpatVector, sf vector GSpatial object (usually GRaster GVector) return Either: \"name\" (default): Returns name \"location\" coordinate reference system x. \"index\": Returns index \"location\". \"crs\": Returns coordinate reference system \"location\". match Character: Method used find location. match \"name\"\" (default), name location used. match \"crs\", coordinate reference system location checked match.","code":""},{"path":"/reference/locationFind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match CRS of a GSpatial object and an existing ","text":"Character, integer, NULL (match found).","code":""},{"path":"/reference/locationFind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match CRS of a GSpatial object and an existing ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/locationRestore.html","id":null,"dir":"Reference","previous_headings":"","what":"Revert to a previously-created ","title":"Revert to a previously-created ","text":"function resets connection previously-created GRASS \"location\". session must already created using fast() current R session. function typically use developers.","code":""},{"path":"/reference/locationRestore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Revert to a previously-created ","text":"","code":"# S4 method for class 'character' .locationRestore(x)  # S4 method for class 'integer' .locationRestore(x)  # S4 method for class 'numeric' .locationRestore(x)  # S4 method for class 'GSpatial' .locationRestore(x)"},{"path":"/reference/locationRestore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Revert to a previously-created ","text":"x Either: character: Name \"location\" GRASS. integer: Index \"location\" .fasterRaster$locations. GSpatial object (usually GRaster GVector). can found using .locationFind().","code":""},{"path":"/reference/locationRestore.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Revert to a previously-created ","text":"object class GLocation (invisibly) successful. error likely result .","code":""},{"path":"/reference/locationRestore.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Revert to a previously-created ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/locations.html","id":null,"dir":"Reference","previous_headings":"","what":"Meta-data on active GRASS locations — .locations","title":"Meta-data on active GRASS locations — .locations","text":"GRASS uses \"locations\"store sets rasters vectors coordinate reference system (CRS). rasters vectors may may actual location Earth–just CRS. function returns information GRASS \"locations\" initialized. mainly useful developers. NB: fasterRaster always uses \"PERMANENT\" mapset.","code":""},{"path":"/reference/locations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Meta-data on active GRASS locations — .locations","text":"","code":".locations(warn = TRUE)"},{"path":"/reference/locations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Meta-data on active GRASS locations — .locations","text":"warn Logical: TRUE (default), display warning GRASS \"locations\" created.","code":""},{"path":"/reference/locations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Meta-data on active GRASS locations — .locations","text":"named list. names \"location's\" names values coordinate reference strings.","code":""},{"path":"/reference/locations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Meta-data on active GRASS locations — .locations","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/longlat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create longitude/latitude rasters — longlat,GRaster-method","title":"Create longitude/latitude rasters — longlat,GRaster-method","text":"longlat() creates two rasters, one cell values equal longitude cell centers, one cell values equal latitude cell centers. Values decimal degrees, regardless projection raster.","code":""},{"path":"/reference/longlat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create longitude/latitude rasters — longlat,GRaster-method","text":"","code":"# S4 method for class 'GRaster' longlat(x)"},{"path":"/reference/longlat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create longitude/latitude rasters — longlat,GRaster-method","text":"x GRaster.","code":""},{"path":"/reference/longlat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create longitude/latitude rasters — longlat,GRaster-method","text":"GRaster stack.","code":""},{"path":"/reference/longlat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create longitude/latitude rasters — longlat,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  # Create longitude/latitude rasters ll <- longlat(elev) ll # note units of cell values!  }"},{"path":"/reference/ls.html","id":null,"dir":"Reference","previous_headings":"","what":"List objects in the active GRASS session — .ls","title":"List objects in the active GRASS session — .ls","text":"Display sources (see sources()) rasters /vectors exported created active GRASS session\"s location mapset.","code":""},{"path":"/reference/ls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List objects in the active GRASS session — .ls","text":"","code":".ls(type = c(\"rasters\", \"vectors\", \"rasters3d\", \"groups\"))"},{"path":"/reference/ls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List objects in the active GRASS session — .ls","text":"type type spatial objects display. can include \"rasters\" (rasters), \"vectors\" (spatial vectors), \"rasters3d\" (3D-rasters), /\"groups\" (groups). Partial matching supported. missing, objects displayed.","code":""},{"path":"/reference/ls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List objects in the active GRASS session — .ls","text":"Character vector names GRASS objects.","code":""},{"path":[]},{"path":"/reference/madChelsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","title":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","text":"Rasters bioclimatic variables eastern portion Madagascar CHELSA version 2.1 unprojected (WGS84) coordinates. Values represent averages across 1980-2010. BIOCLIM variables included: * bio1: Mean annual temperature (deg C) * bio7: Temperature annual range (hottest - coldest month temperature; deg C) * bio12: Total annual precipitation (mm) * bio15: Precipitation seasonality (unit-less)","code":""},{"path":"/reference/madChelsa.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","text":"object class SpatRaster unprojected (WGS84) coordinates.","code":""},{"path":"/reference/madChelsa.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","text":"doi:10.1038/sdata.2017.122","code":""},{"path":"/reference/madChelsa.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","text":"Karger, D.N., Conrad, O., Böhner, J., Kawohl, T., Kreft, H., Soria-Auza, R.W., Zimmermann, N.E., Linder, H.P., Kessler, M.  2017.  Climatologies high resolution earth's land surface areas. Scientific Data 4:170122. doi:10.1038/sdata.2017.122","code":""},{"path":"/reference/madChelsa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasters of bioclimatic variables for an eastern portion of Madagascar — madChelsa","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madCoast.html","id":null,"dir":"Reference","previous_headings":"","what":"Shapefile of a portion of the coastline of Madagascar — madCoast","title":"Shapefile of a portion of the coastline of Madagascar — madCoast","text":"Borders selected portion Madagascar","code":""},{"path":"/reference/madCoast.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Shapefile of a portion of the coastline of Madagascar — madCoast","text":"ESRI Shapefile.","code":""},{"path":"/reference/madCoast.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Shapefile of a portion of the coastline of Madagascar — madCoast","text":"Database Global Administrative Areas Version 2.8 (GADM)","code":""},{"path":"/reference/madCoast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shapefile of a portion of the coastline of Madagascar — madCoast","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madCoast0.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","text":"Borders selected portion Madagascar","code":""},{"path":"/reference/madCoast0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","text":"","code":"data(madCoast4)"},{"path":"/reference/madCoast0.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","text":"object class sf.","code":""},{"path":"/reference/madCoast0.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","text":"Database Global Administrative Areas Version 2.8 (GADM)","code":""},{"path":"/reference/madCoast0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast0","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madCoast4.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","text":"Borders selected portion Madagascar","code":""},{"path":"/reference/madCoast4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","text":"","code":"data(madCoast4)"},{"path":"/reference/madCoast4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","text":"object class sf.","code":""},{"path":"/reference/madCoast4.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","text":"Database Global Administrative Areas Version 2.8 (GADM)","code":""},{"path":"/reference/madCoast4.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial vector of a portion of the coastline of Madagascar — madCoast4","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madCover.html","id":null,"dir":"Reference","previous_headings":"","what":"Raster of land cover for an eastern portion of Madagascar — madCover","title":"Raster of land cover for an eastern portion of Madagascar — madCover","text":"Raster land cover eastern portion Madagascar. Note land cover classes simplified, raster used \"real\" analyses.","code":""},{"path":"/reference/madCover.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raster of land cover for an eastern portion of Madagascar — madCover","text":"object class SpatRaster unprojected (WGS84) coordinates.","code":""},{"path":"/reference/madCover.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Raster of land cover for an eastern portion of Madagascar — madCover","text":"http://due.esrin.esa.int","code":""},{"path":"/reference/madCover.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Raster of land cover for an eastern portion of Madagascar — madCover","text":"Arino O., P. Bicheron, F. Achard, J. Latham, R. Witt J.-L. Weber. 2008. GlobCover: detailed portrait Earth. European Space Agency Bulletin 136:25-31. http://due.esrin.esa.int.","code":""},{"path":[]},{"path":"/reference/madCover.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raster of land cover for an eastern portion of Madagascar — madCover","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madCoverCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","title":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","text":"data frame corresponds madCover raster, represents land cover eastern portion Madagascar. Note land cover classes simplified, table raster used \"real\" analyses.","code":""},{"path":"/reference/madCoverCats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","text":"object class data.frame.","code":""},{"path":"/reference/madCoverCats.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","text":"http://due.esrin.esa.int","code":""},{"path":"/reference/madCoverCats.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","text":"Arino O., P. Bicheron, F. Achard, J. Latham, R. Witt J.-L. Weber. 2008. GlobCover: detailed portrait Earth. European Space Agency Bulletin 136:25-31. http://due.esrin.esa.int.","code":""},{"path":[]},{"path":"/reference/madCoverCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table of land cover classes for an eastern portion of Madagascar — madCoverCats","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madDypsis.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","title":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","text":"Spatial points vector herbarium specimens observations plants genus Dypsis (slender, evergreen palms) portion eastern Madagascar.","code":""},{"path":"/reference/madDypsis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","text":"","code":"data(madDypsis)"},{"path":"/reference/madDypsis.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","text":"object class sf.","code":""},{"path":"/reference/madDypsis.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","text":"Global Biodiversity Information Facility (GBIF)","code":""},{"path":"/reference/madDypsis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial points vector of records of Dypsis in eastern Madagascar — madDypsis","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madElev.html","id":null,"dir":"Reference","previous_headings":"","what":"Elevation raster for an eastern portion of Madagascar — madElev","title":"Elevation raster for an eastern portion of Madagascar — madElev","text":"Elevation raster eastern portion Madagascar.","code":""},{"path":"/reference/madElev.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Elevation raster for an eastern portion of Madagascar — madElev","text":"object class SpatRaster. Values mean meters sea level.","code":""},{"path":"/reference/madElev.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Elevation raster for an eastern portion of Madagascar — madElev","text":"WorldClim Version 2.1","code":""},{"path":"/reference/madElev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elevation raster for an eastern portion of Madagascar — madElev","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madForest2000.html","id":null,"dir":"Reference","previous_headings":"","what":"Forest cover in year 2000 for a portion of Madagascar — madForest2000","title":"Forest cover in year 2000 for a portion of Madagascar — madForest2000","text":"Raster occurrence/non-occurrence forest cover portion Madagascar. Cells 30-m resolution. Values represent forest (1) non-forest (NA).","code":""},{"path":"/reference/madForest2000.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Forest cover in year 2000 for a portion of Madagascar — madForest2000","text":"object class SpatRaster.","code":""},{"path":"/reference/madForest2000.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Forest cover in year 2000 for a portion of Madagascar — madForest2000","text":"Vielledent, G., Grinand, C., Rakotomala, F.., Ranaivosoa, R., Rakotoarijaona, J-R., Allnutt, T.F., Achard, F.  2018.  Combining global tree cover loss data historical national forest cover maps look six decades deforestation forest fragmentation Madagascar. Biological Conservation 222:189-197. doi:10.1016/j.biocon.2018.04.008 .","code":""},{"path":"/reference/madForest2000.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forest cover in year 2000 for a portion of Madagascar — madForest2000","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madForest2014.html","id":null,"dir":"Reference","previous_headings":"","what":"Forest cover in year 2014 for a portion of Madagascar — madForest2014","title":"Forest cover in year 2014 for a portion of Madagascar — madForest2014","text":"Raster occurrence/non-occurrence forest cover portion Madagascar. Cells 30-m resolution. Values represent forest (1) non-forest (NA).","code":""},{"path":"/reference/madForest2014.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Forest cover in year 2014 for a portion of Madagascar — madForest2014","text":"object class SpatRaster..","code":""},{"path":"/reference/madForest2014.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Forest cover in year 2014 for a portion of Madagascar — madForest2014","text":"Vielledent, G., Grinand, C., Rakotomala, F.., Ranaivosoa, R., Rakotoarijaona, J-R., Allnutt, T.F., Achard, F.  2018.  Combining global tree cover loss data historical national forest cover maps look six decades deforestation forest fragmentation Madagascar. Biological Conservation 222:189-197. doi:10.1016/j.biocon.2018.04.008 .","code":""},{"path":"/reference/madForest2014.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forest cover in year 2014 for a portion of Madagascar — madForest2014","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madLANDSAT.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasters of surface reflectance for an eastern portion of Madagascar — madLANDSAT","title":"Rasters of surface reflectance for an eastern portion of Madagascar — madLANDSAT","text":"Raster layers surface reflectance LANDSAT 9 eastern portion Madagascar taken May 21, 2023. Four bands represented: `band2': Blue (450-510 nm) `band3': Green (530-590 nm) `band4': Red (640-670 nm) `band5': Near-infrared (850-880 nm) rasters resampled 90-m resolution reduce size, rescaled integers range 0 255.","code":""},{"path":"/reference/madLANDSAT.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rasters of surface reflectance for an eastern portion of Madagascar — madLANDSAT","text":"object class SpatRaster Universal Trans-Mercator (UTM), Zone 39 North WGS84 coordinate system, 90 m resolution.","code":""},{"path":"/reference/madLANDSAT.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rasters of surface reflectance for an eastern portion of Madagascar — madLANDSAT","text":"United States Geological Survey's EarthExplorer. Also see band definitions.","code":""},{"path":"/reference/madLANDSAT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasters of surface reflectance for an eastern portion of Madagascar — madLANDSAT","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madPpt.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","title":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","text":"Rasters precipitation eastern portion Madagascar WorldClim 2.1 ~3.33 arcminute resolution projected Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units millimeters. used formal analysis.","code":""},{"path":"/reference/madPpt.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","text":"object class SpatRaster.","code":""},{"path":"/reference/madPpt.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","text":"doi:10.1002/joc.5086","code":""},{"path":"/reference/madPpt.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","text":"Fick, S.E. Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces global land areas.  International Journal Climatology 37:4302-4315. doi:10.1002/joc.5086","code":""},{"path":"/reference/madPpt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasters of average monthly precipitation for an eastern portion of Madagascar — madPpt","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madRivers.html","id":null,"dir":"Reference","previous_headings":"","what":"Major rivers in a selected portion of Madagascar — madRivers","title":"Major rivers in a selected portion of Madagascar — madRivers","text":"Spatial lines object major rivers portion Madagascar.","code":""},{"path":"/reference/madRivers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Major rivers in a selected portion of Madagascar — madRivers","text":"","code":"data(madRivers)"},{"path":"/reference/madRivers.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Major rivers in a selected portion of Madagascar — madRivers","text":"object class sf.","code":""},{"path":"/reference/madRivers.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Major rivers in a selected portion of Madagascar — madRivers","text":"DIVA-GIS","code":""},{"path":"/reference/madRivers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Major rivers in a selected portion of Madagascar — madRivers","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madTmax.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","title":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","text":"Rasters maximum temperature eastern portion Madagascar WorldClim 2.1 ~3.3 arcminute resolution projected Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units degrees C. used formal analysis.","code":""},{"path":"/reference/madTmax.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","text":"object class SpatRaster.","code":""},{"path":"/reference/madTmax.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","text":"doi:10.1002/joc.5086","code":""},{"path":"/reference/madTmax.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","text":"Fick, S.E. Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces global land areas.  International Journal Climatology 37:4302-4315. doi:10.1002/joc.5086","code":""},{"path":"/reference/madTmax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasters of average monthly maximum temperature for an eastern portion of Madagascar — madTmax","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/madTmin.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","title":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","text":"Rasters minimum temperature eastern portion Madagascar WorldClim 2.1 ~3.33 arcminute resolution projected Tananarive (Paris)/Laborde Grid coordinate reference system. Values represent monthly averages across 1970-2000. Units degrees C. used formal analysis.","code":""},{"path":"/reference/madTmin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","text":"object class SpatRaster.","code":""},{"path":"/reference/madTmin.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","text":"doi:10.1002/joc.5086","code":""},{"path":"/reference/madTmin.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","text":"Fick, S.E. Hijmans, R.J.  2017.  WorldClim 2: New 1-km spatial resolution climate surfaces global land areas.  International Journal Climatology 37:4302-4315. doi:10.1002/joc.5086","code":""},{"path":"/reference/madTmin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasters of average monthly minimum temperature for an eastern portion of Madagascar — madTmin","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/mapset.html","id":null,"dir":"Reference","previous_headings":"","what":"GRASS ","title":"GRASS ","text":"GRASS \"locations\" sets one rasters /vectors coordinate reference systems, may may represent actual location Earth. GRASS \"mapsets\" like subfolders locations, collections rasters /vectors typically related general project. function returns mapset object current mapset. said, fasterRaster always uses \"PERMANENT\" mapset, little reason use function -.","code":""},{"path":"/reference/mapset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GRASS ","text":"","code":"# S4 method for class 'GLocation' .mapset(x)  # S4 method for class 'missing' .mapset(x)"},{"path":"/reference/mapset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GRASS ","text":"x Either: Missing: Reports mapset currently active GRASS session. GLocation object object contains GLocation class (.e., GSpatial object: GRaster GVector): Reports CRS object.","code":""},{"path":"/reference/mapset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GRASS ","text":"character string.","code":""},{"path":[]},{"path":"/reference/mapset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GRASS ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\") madChelsa1 <- madChelsa[[1]]  # Convert SpatRasters to GRasters. # Each raster has a different CRS so will be put into a different location. elev <- fast(madElev) chelsa1 <- fast(madChelsa1)  # Name of the currently active location .location() .location(elev) .location(chelsa1)  # All available GRASS locations .locations()  # Find location of an object among all active locations .locationFind(elev) .locationFind(chelsa1) .locationFind(chelsa1, return = \"index\") .locationFind(chelsa1, return = \"crs\")  # Switch between locations .locationRestore(elev) .locationRestore(chelsa1)  loc <- .location(elev) .locationRestore(loc)  # We could use .locationDelete(elev) to delete # the location where \"elev\" is stored.  # Mapsets are always \"PERMANENT\" in fasterRaster .mapset() .mapset(elev) .mapset(chelsa1)  }"},{"path":"/reference/mask.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask values in a raster — mask,GRaster,GRaster-method","title":"Mask values in a raster — mask,GRaster,GRaster-method","text":"output mask() GRaster values input raster. However, mask argument GRaster, output NA values cells mask raster NA cells. mask argument GVector, output raster NA values cells GVector cover.","code":""},{"path":"/reference/mask.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask values in a raster — mask,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' mask(x, mask, inverse = FALSE, maskvalues = NA, updatevalue = NA)  # S4 method for class 'GRaster,GVector' mask(x, mask, inverse = FALSE, updatevalue = NA)"},{"path":"/reference/mask.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask values in a raster — mask,GRaster,GRaster-method","text":"x GRaster. mask GRaster GVector. inverse Logical: TRUE, effect mask inverted. , copy input raster made, cells overlap NA mask raster covered mask vector retain values. Cells overlap NA mask raster overlap mask vector forced NA. maskvalues Numeric vector, including NA (mask GRaster): value(s) mask raster cells serve mask. default NA, case cells input raster overlap NA cells mask forced NA. updatevalue Numeric, including NA (default): values assigned masked cells.","code":""},{"path":"/reference/mask.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask values in a raster — mask,GRaster,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/mask.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask values in a raster — mask,GRaster,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") # raster madForest <- fastData(\"madForest2000\") # raster madCoast <- fastData(\"madCoast4\") # vector  # Convert to GRasters and GVectors elev <- fast(madElev) forest <- fast(madForest) coast <- fast(madCoast)  ant <- coast[coast$NAME_4 == \"Antanambe\"]  # Mask by a raster or  vector: maskByRast <- mask(elev, forest) plot(c(forest, maskByRast))  maskByVect <- mask(elev, ant) plot(maskByVect) plot(ant, add = TRUE)  # Mask by a raster or vector, but invert mask: maskByRastInvert <- mask(elev, forest, inverse = TRUE) plot(c(forest, maskByRastInvert))  maskByVectInvert <- mask(elev, ant, inverse = TRUE) plot(maskByVectInvert) plot(ant, add = TRUE)  # Mask by a raster, but use custom values for the mask: maskByRastCustomMask <- mask(elev, elev, maskvalues = 1:20) plot(c(elev <= 20, maskByRastCustomMask))  # Mask by a raster or vector, but force masked values to a custom value: byRastCustomUpdate <- mask(elev, forest, updatevalue = 7) plot(byRastCustomUpdate)  byVectCustomUpdate <- mask(elev, ant, updatevalue = 7) plot(byVectCustomUpdate)  # Mask by a raster, inverse, custom values, and custom update: byRastAll <-    mask(elev, elev, inverse = TRUE, maskvalues = 1:20, updatevalue = 7)  plot(c(elev, byRastAll))  }"},{"path":"/reference/maskNA.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask all non-NA cells or all NA cells — maskNA,GRaster-method","title":"Mask all non-NA cells or all NA cells — maskNA,GRaster-method","text":"function converts non-NA cells GRaster single user-defined value, leaving NA cells NA. Alternatively, can convert NA cells user-defined value, non-NA cells NA.","code":""},{"path":"/reference/maskNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask all non-NA cells or all NA cells — maskNA,GRaster-method","text":"","code":"# S4 method for class 'GRaster' maskNA(x, value = 1, invert = FALSE, retain = FALSE)"},{"path":"/reference/maskNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask all non-NA cells or all NA cells — maskNA,GRaster-method","text":"x GRaster. value Numeric: Value assign masked cells. default 1. invert Logical: FALSE (default), convert non-NA cells value, leave NA cells -. TRUE, convert NA cells value, non-NA cells NA. retain Logical: invert TRUE retain FALSE (default), non-NA cells retain value. argument ignored invert FALSE.","code":""},{"path":[]},{"path":"/reference/maskNA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask all non-NA cells or all NA cells — maskNA,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Convert non-NA to 1, NA cells remain NA elevMask <- maskNA(elev) elevMask plot(c(elev, elevMask))  # Convert NA to 1, non-NA cells become NA elevInvertMask <- maskNA(elev, invert = TRUE) elevInvertMask plot(c(elev, elevInvertMask))  # Convert NA to 200, non-NA cells keep their values elevInvertRetain <- maskNA(elev, value = 200, invert = TRUE, retain = TRUE) elevInvertRetain plot(c(elev, elevInvertRetain))  }"},{"path":"/reference/match.html","id":null,"dir":"Reference","previous_headings":"","what":"Find which cells of a GRaster match certain values — match,GRaster-method","title":"Find which cells of a GRaster match certain values — match,GRaster-method","text":"match() function takes GRaster numeric, integer character vector inputs returns GRaster cell values correspond index element vector matched original cell value. example, 4-cell raster values 3, NA, 5, 4, vector c(3, 4), output 4-cell raster values 1, NA, NA, 2 first value vector 3 (cell 3 assigned 1), second value vector 4 (cell 4 assigned 2). two values matches. GRaster categorical, vector can category labels instead numeric values. %% operator returns GRaster cell values 1 original values appeared vector, 0 (NA original value NA). GRaster categorical, vector can category labels instead numeric values. %notin% operator returns 1 cells values found vector, 0 otherwise. GRaster categorical, vector can category labels instead numeric values.","code":""},{"path":"/reference/match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find which cells of a GRaster match certain values — match,GRaster-method","text":"","code":"# S4 method for class 'GRaster' match(x, table, nomatch = NA)  # S4 method for class 'GRaster' x %in% table  # S4 method for class 'GRaster' x %notin% table"},{"path":"/reference/match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find which cells of a GRaster match certain values — match,GRaster-method","text":"x GRaster: Note kind GRaster acceptable (integer, float, double, categorical), matching may work intended float double rasters problems comparing floating-point values. table numeric, integer, character vector. nomatch Numeric integer: Value return match found.","code":""},{"path":"/reference/match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find which cells of a GRaster match certain values — match,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find which cells of a GRaster match certain values — match,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Elevation and land cover rasters madElev <- fastData(\"madElev\") madCover <- fastData(\"madCover\")  ### match() with an integer raster: ###################################  elev <- fast(madElev)  # Cells in elevation raster replaced with index in which they appear # in the table: table <- c(10, 20, 30, 40, 50) elevIndex <- match(elev, table) elevIndexNeg <- match(elev, table, nomatch = -100)  plot(c(elevIndex, elevIndexNeg))  ### Using %in% and %notin% on an integer GRaster: #################################################  elev <- fast(madElev) table <- c(10, 20, 30, 40, 50)  ins <- elev %in% table notins <- elev %notin% table  plot(c(ins, notins))  ### match() with a categorical raster: ######################################  cover <- fast(madCover) cover <- droplevels(cover) levels(cover)  forestLabels <- c(    \"Sparse broadleaved evergreen/semi-deciduous forest\",    \"Broadleaved deciduous forest\",    \"Grassland with mosaic forest\",    \"Flooded forest\" )  forestClasses <- match(cover, forestLabels) plot(forestClasses) levels(forestClasses)  forestNoMatch <- match(cover, forestLabels, nomatch = -100) plot(forestNoMatch) levels(forestNoMatch)  ### Using %in% and %notin% on a categorical GRaster: ####################################################  cover <- fast(madCover) cover <- droplevels(cover) levels(cover)  forestLabels <- c(    \"Sparse broadleaved evergreen/semi-deciduous forest\",    \"Broadleaved deciduous forest\",    \"Grassland with mosaic forest\",    \"Flooded forest\" )  forest <- cover %in% forestLabels plot(forest)  notForest <- cover %notin% forestLabels plot(notForest)  }"},{"path":"/reference/math.html","id":null,"dir":"Reference","previous_headings":"","what":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","title":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","text":"can apply mathematical functions layer GRaster. output GRaster number layers input. Available functions include: NAs: .na() .na() Absolute value: abs() Trigonometric functions (assumes values radians): cos() sin() tan() acos() asin() atan() atan2() Exponential logarithmic functions: exp() log() (natural log) ln() (also natural log) log2() (log, base 2) log10() (log, base 10) log1p() (log(x + 1)) log10p() (log(x + 1, base = 10)) Power functions: sqrt() x^y Rounding: round() floor() (round ) ceiling() (round ) trunc() (remove decimal portion)","code":""},{"path":"/reference/math.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","text":"","code":"# S4 method for class 'GRaster' is.na(x)  # S4 method for class 'GRaster' not.na(x, falseNA = FALSE)  # S4 method for class 'GRaster' abs(x)  # S4 method for class 'GRaster' sin(x)  # S4 method for class 'GRaster' cos(x)  # S4 method for class 'GRaster' tan(x)  # S4 method for class 'GRaster' asin(x)  # S4 method for class 'GRaster' acos(x)  # S4 method for class 'GRaster' atan(x)  # S4 method for class 'GRaster,GRaster' atan2(y, x)  # S4 method for class 'GRaster' exp(x)  # S4 method for class 'GRaster' log1p(x)  # S4 method for class 'GRaster' log10p(x)  # S4 method for class 'GRaster' log(x, base = exp(1))  # S4 method for class 'GRaster' ln(x)  # S4 method for class 'GRaster' log2(x)  # S4 method for class 'GRaster' log10(x)  # S4 method for class 'GRaster' sqrt(x)  # S4 method for class 'GRaster' round(x, digits = 0)  # S4 method for class 'GRaster' floor(x)  # S4 method for class 'GRaster' ceiling(x)  # S4 method for class 'GRaster' trunc(x)"},{"path":"/reference/math.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","text":"x, y GRasters. falseNA Logical (function .na()): FALSE (default), non-NA cells converted 1, NA cells 0. TRUE, non-NA cells converted  NA cells stay NA. base Numeric: Base logarithm. digits Numeric: Number digits round . negative, rounding nearest positive power 10. example, digits = -2, GRaster values rounded nearest 100.","code":""},{"path":"/reference/math.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/math.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mathematical operations on each layer of a GRasters — is.na,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev) elevs <- c(elev, elev, log10(elev) - 1, sqrt(elev)) names(elevs) <- c(\"elev1\", \"elev2\", \"log_elev\", \"sqrt_elev\")  elev elevs  # do some math elev + 100 elev - 100 elev * 100 elev / 100 elev ^ 2 elev %/% 100 # divide then round down elev %% 100 # modulus  100 + elev 100 %/% elev 100 %% elev  elevs + 100 100 + elevs  # math with logicals elev + TRUE elev - TRUE elev * TRUE elev / TRUE elev ^ TRUE elev %/% TRUE # divide then round down elev %% TRUE # modulus  elevs + TRUE TRUE + elevs  # Raster interacting with raster(s): elev + elev elev - elev elev * elev elev / elev elev ^ log(elev) elev %/% sqrt(elev) # divide then round down elev %% sqrt(elev) # modulus  elevs + elev elev * elevs  # sign abs(-1 * elev) abs(elevs)  # powers sqrt(elevs)  # trigonometry sin(elev) cos(elev) tan(elev)  asin(elev) acos(elev) atan(elev)  atan(elevs) atan2(elev, elev^1.2) atan2(elevs, elev^1.2) atan2(elev, elevs^1.2) atan2(elevs, elevs^1.2)  # logarithms exp(elev) log(elev) ln(elev) log2(elev) log1p(elev) log10(elev) log10p(elev) log(elev, 3)  log(elevs)  # rounding round(elev + 0.5) floor(elev + 0.5) ceiling(elev + 0.5) trunc(elev + 0.5)  # comparison elev < 100 elev <= 100 elev == 100 elev != 100 elev > 100 elev >= 100  elev + 100 < 2 * elev  elevs > 10 10 > elevs  # logic elev < 10 | elev > 200 elev < 10 | cos(elev) > 0.9  elev < 10 | TRUE TRUE | elev > 200  elev < 10 | FALSE FALSE | elev > 200  elev < 10 & cos(elev) > 0.9  elev < 10 & TRUE TRUE & elev > 200  elev < 10 & FALSE FALSE & elev > 200  # Mathematical functions on GRasters with >= 2 layers: mean(elevs) mmode(elevs) median(elevs) nunique(elevs)  sum(elevs) count(elevs) min(elevs) max(elevs) range(elevs) skewness(elevs) kurtosis(elevs)  which.min(elevs) which.max(elevs)  slope(elevs) intercept(elevs) r2(elevs) tvalue(elevs)  stdev(elevs) stdev(elevs, pop = FALSE) var(elevs) varpop(elevs)  # Note: To get quantiles for each layer, use # global(x, \"quantile\", probs = 0.2). quantile(elevs, 0.1)  }"},{"path":"/reference/merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","title":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","text":"merge() combines two GRasters, possibly different extents, single larger GRaster. cell different values raster, value first raster's cell used. NA, value second raster's cell used, .","code":""},{"path":"/reference/merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' merge(x, y, ...)"},{"path":"/reference/merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","text":"x, y, ... GRasters.","code":""},{"path":"/reference/merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine two or more rasters with different extents and fill in NAs — merge,GRaster,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madCoast4 <- fastData(\"madCoast4\") madCoast4 <- vect(madCoast4)  # For the example, crop the elevation raster to two communes madAnt <- madCoast4[madCoast4$NAME_4 == \"Antanambe\", ] madMan <- madCoast4[madCoast4$NAME_4 == \"Manompana\", ]  elevAnt <- crop(madElev, madAnt) elevMan <- crop(madElev, madMan)  plot(madElev) plot(elevAnt, col = \"red\", legend = FALSE, add = TRUE) plot(elevMan, col = \"blue\", legend = FALSE, add = TRUE)  # Convert a SpatRaster to a GRaster ant <- fast(elevAnt) man <- fast(elevMan)  # merge antMan <- merge(ant, man) plot(antMan, main = \"Antman!\")  }"},{"path":"/reference/message.html","id":null,"dir":"Reference","previous_headings":"","what":"Display warning or message — .message","title":"Display warning or message — .message","text":"Display warning message given warning displayed since fasterRaster attached given number hours passed since .","code":""},{"path":"/reference/message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display warning or message — .message","text":"","code":".message(msg, message)"},{"path":"/reference/message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display warning or message — .message","text":"msg Character: Name message (used internally). able assigned list (.e., spaces, punctuation, etc.). message Text message.","code":""},{"path":"/reference/message.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display warning or message — .message","text":"TRUE (invisibly).","code":""},{"path":"/reference/minmax.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","title":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","text":"minmax() reports minimum maximum values across non-NA cells GRaster. levels argument TRUE raster categorical, function reports \"lowest\" \"highest\" category values categorical raster.","code":""},{"path":"/reference/minmax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","text":"","code":"# S4 method for class 'GRaster' minmax(x, levels = FALSE)"},{"path":"/reference/minmax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","text":"x GRaster. levels Logical: TRUE raster categorical raster, return \"lowest\" \"highest\" categories. default FALSE.","code":""},{"path":"/reference/minmax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","text":"minmax() returns numeric matrix, minmax(..., levels = TRUE) returns data.frame category names. latter case, non-categorical rasters NA values.","code":""},{"path":[]},{"path":"/reference/minmax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum and maximum values or categories of a GRaster — minmax,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/missingCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","title":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","text":"function reports values categorical GRaster matching category label \"levels\" table. GRasters can represent categorical data. Cell values actually integers, corresponding category, \"desert\" \"wetland.\" categorical raster associated table matches value category name.","code":""},{"path":"/reference/missingCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","text":"","code":"# S4 method for class 'GRaster' missingCats(x, layer = 1:nlyr(x))"},{"path":"/reference/missingCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","text":"x GRaster. layer Numeric integers, logical vector, character: Layer(s) obtain missing categories.","code":""},{"path":"/reference/missingCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","text":"numeric vector (xis just one layer), named list numeric vectors, one per layer x.","code":""},{"path":[]},{"path":"/reference/missingCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Values in a categorical raster with no assigned category — missingCats,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/mow.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove unused rasters and vectors from the GRASS cache — mow","title":"Remove unused rasters and vectors from the GRASS cache — mow","text":"fasterRaster attempts remove intermediate rasters vectors GRASS cache needed, files can still accumulate, especially remove GRasters GVectors R working environment (e.g., using rm() simply using variable name different rasters/vectors). function ) search GRASS cache rasters/vectors ; b) remove pointed object active R environment. Note calling function inside another function's environment can dangerous, able see objects environment, thus delete rasters/vectors outside environment. Note also function clean current GRASS project/location.","code":""},{"path":"/reference/mow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove unused rasters and vectors from the GRASS cache — mow","text":"","code":"mow(x, type = NULL, verbose = TRUE, ask = TRUE)"},{"path":"/reference/mow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove unused rasters and vectors from the GRASS cache — mow","text":"x Either missing (default) environment. type Either NULL character vector. NULL, rasters vectors GRASS cache candidates deletion. Otherwise, can either \"raster\", \"vector\", . verbose Logical: TRUE (default), report progress. ask Logical: TRUE (default), prompt reassurance.","code":""},{"path":"/reference/mow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove unused rasters and vectors from the GRASS cache — mow","text":"Invisibly returns list number rasters vectors deleted.","code":""},{"path":[]},{"path":"/reference/mow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove unused rasters and vectors from the GRASS cache — mow","text":"","code":"if (grassStarted()) {  if (FALSE) mow()  }"},{"path":"/reference/nacell.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","title":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","text":"nacell() function counts number NA cells GRaster, nonnacell() reports number non-NA cells. raster 3D, cells layers counted.","code":""},{"path":"/reference/nacell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","text":"","code":"# S4 method for class 'GRaster' nacell(x, warn = TRUE)  # S4 method for class 'GRaster' nonnacell(x, warn = TRUE)"},{"path":"/reference/nacell.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","text":"x GRaster. warn Logical: TRUE (default), display warning much time computation take.","code":""},{"path":"/reference/nacell.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","text":"numeric value, one per raster layer input.","code":""},{"path":[]},{"path":"/reference/nacell.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of NA or non-NA cells in a raster — nacell,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/names.html","id":null,"dir":"Reference","previous_headings":"","what":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"names() returns names(s) GRaster columns GVector's data table'.","code":""},{"path":"/reference/names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"","code":"# S4 method for class 'GRaster' names(x)  # S4 method for class 'GRaster' names(x) <- value  # S4 method for class 'GVector' names(x)  # S4 method for class 'GVector' names(x) <- value"},{"path":"/reference/names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"x GRaster GVector. value Character: Name(s) assign raster(s).","code":""},{"path":"/reference/names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"Character vector.","code":""},{"path":"/reference/names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"names(value) <- assigns new name GRaster columns GVector's data table.","code":""},{"path":[]},{"path":"/reference/names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name(s) of a GRaster or columns of a GVector's data table — names,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/ngeom.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","title":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","text":"GVectors represent two types \"geometries\". \"singlepart\" geometries, point, set connected line segments, polygon treated like feature row attribute table. example, province might composed islands. case, island represented feature row attribute indicating, say, name area island. \"multipart\" geometries, features collected together thu manipulated single feature singe line attribute table. multipart feature can contain one singlepart features. example, islands comprising  province collated together single row attribute table indicating name province area entire province. ngeom() returns number geometries. Singlepart features treated one geometry , multipart features treated one geometry . nsubgeom() Returns number subgeometries. Singlepart geometries represent single subgeometry. Multipart geometries represent one subgeometries. number subgeometries thus always number geometries.","code":""},{"path":"/reference/ngeom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","text":"","code":"# S4 method for class 'GVector' ngeom(x)  # S4 method for class 'GVector' nsubgeom(x)"},{"path":"/reference/ngeom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","text":"x GVector.","code":""},{"path":"/reference/ngeom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","text":"integer.","code":""},{"path":[]},{"path":"/reference/ngeom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of geometries and subgeometries in a vector — ngeom,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/nlevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of categories in a categorical raster — nlevels,GRaster-method","title":"Number of categories in a categorical raster — nlevels,GRaster-method","text":"function reports number categories (levels) categorical GRaster.","code":""},{"path":"/reference/nlevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of categories in a categorical raster — nlevels,GRaster-method","text":"","code":"# S4 method for class 'GRaster' nlevels(x)"},{"path":"/reference/nlevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of categories in a categorical raster — nlevels,GRaster-method","text":"x GRaster.","code":""},{"path":"/reference/nlevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of categories in a categorical raster — nlevels,GRaster-method","text":"named, numeric vector integers. values represent number categories (rows) appear raster's levels table.","code":""},{"path":[]},{"path":"/reference/nlevels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of categories in a categorical raster — nlevels,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Land cover raster madCover <- fastData(\"madCover\")  # Convert categorical SpatRaster to categorical GRaster: cover <- fast(madCover)  ### Properties of categorical rasters #####################################  cover # note categories is.factor(cover) # Is the raster categorical? nlevels(cover) # number of levels levels(cover) # just the value and active column cats(cover) # all columns minmax(cover) # min/max values minmax(cover, levels = TRUE) # min/max categories catNames(cover) # column names of the levels table missingCats(cover) # categories in table with no values in raster freq(cover) # frequency of each category (number of cells) zonalGeog(cover) # geometric statistics  ### Active column #################  # Which column sets the category labels? activeCat(cover) activeCat(cover, names = TRUE)  activeCats(c(cover, cover))  # Choose a different column for category labels: levels(cover) activeCat(cover) <- 2 levels(cover)  ### Managing levels tables ##########################  # Remove unused levels: nlevels(cover) cover <- droplevels(cover) nlevels(cover)  # Re-assign levels: value <- c(20, 30, 40, 50, 120, 130, 140, 170) label <- c(\"Cropland\", \"Cropland\", \"Forest\", \"Forest\",  \"Grassland\", \"Shrubland\", \"Herbaceous\", \"Flooded\")  newCats <- data.frame(value = value, label = label)  cover <- categories(cover, layer = 1, value = newCats) cats(cover)  # This is the same as: levels(cover) <- newCats cats(cover)  # Are there any values not assigned a category? missingCats(cover)  # Let's assign a category for value 210 (water): water <- data.frame(value = 210, label = \"Water\") addCats(cover) <- water levels(cover)  # Add more information to the levels table using merge(): landType <- data.frame(      Value = c(20, 30, 40, 50, 120),      Type = c(\"Irrigated\", \"Rainfed\", \"Broadleaf evergreen\",      \"Broadleaf deciduous\", \"Mosaic with forest\") ) cats(cover) cover <- addCats(cover, landType, merge = TRUE) cats(cover)  ### Logical operations on categorical rasters #############################################  cover < \"Forest\" # 1 for cells with a value < 40, 0 otherwise cover <= \"Forest\" # 1 for cells with a value < 120, 0 otherwise cover == \"Forest\" # 1 for cells with value of 40-120, 0 otherwise cover != \"Forest\" # 1 for cells with value that is not 40-120, 0 otherwise cover > \"Forest\" # 1 for cells with a value > 120, 0 otherwise cover >= \"Forest\" # 1 for cells with a value >= 120, 0 otherwise  cover %in% c(\"Cropland\", \"Forest\") # 1 for cropland/forest cells, 0 otherwise  ### Combine categories from different rasters #############################################  # NB We only have one categorical raster ships with fasterRaster, so we # will create a second one from the elevation raster.  # Divide elevation raster into \"low/medium/high\" levels: madElev <- fastData(\"madElev\") elev <- fast(madElev) elev <- project(elev, cover, method = \"near\") # convert to same CRS fun <- \"= if(madElev < 100, 0, if(madElev < 400, 1, 2))\" elevCat <- app(elev, fun)  levs <- data.frame(      value = c(0, 1, 2),      elevation = c(\"low\", \"medium\", \"high\") ) levels(elevCat) <- list(levs)  # Combine levels: combined <- combineCats(cover, elevCat) combined levels(combined)  # Combine levels, treating value/NA combinations as new categories: combinedNA <- combineCats(cover, elevCat, na.rm = FALSE) combinedNA levels(combinedNA)  }"},{"path":"/reference/pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","title":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","text":"pairs() generates scatterplot values cells layer GRaster layers.","code":""},{"path":"/reference/pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","text":"","code":"# S4 method for class 'GRaster' pairs(x, n = NULL, ...)"},{"path":"/reference/pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","text":"x GRaster two layers. n numeric integer, integer, NULL (default): Number cells sample. NULL, 50% total number cells used. ... Arguments send graphics::pairs() (typically sends graphics::plot()). Special arguments affecting certain panels include: Correlation panels – cor.cex: Size values correlation coefficients. Histogram panels – hist.col: Histogram color. Dot-plot panels – colramp: Function taking integer n input returning n names colors. default : colorRampPalette(c(\"white\", blues9)).","code":""},{"path":"/reference/pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","text":"Nothing (creates plot).","code":""},{"path":"/reference/pairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scatterplot of values in each GRaster layer against the others — pairs,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","title":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","text":"function applies principal component analysis layers GRaster.","code":""},{"path":"/reference/pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","text":"","code":"# S4 method for class 'GRaster' pca(x, scale = TRUE, scores = FALSE)"},{"path":"/reference/pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","text":"x GRaster two layers. scale Logical: TRUE (default), input layers rescaled dividing layer overall population standard deviation. Rasters always centered (mean subtracted values). Centering scaling recommended rasters values different units. scores Logical: TRUE, prcomp object scores attached . can greatly increase size object memory input raster many cells. also take time. FALSE (default), skip returning scores.","code":""},{"path":"/reference/pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","text":"multi-layer GRaster one layer per principal component axis. pcs() function can used output raster retrieve prcomp object raster, includes rotations (loadings) proportions variance explained.","code":""},{"path":[]},{"path":"/reference/pca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a principal component analysis (PCA) to layers of a GRaster — pca,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Climate raster: madChelsa <- fastData(\"madChelsa\")  # Convert a SpatRaster to a GRaster: chelsa <- fast(madChelsa)  # Generate raster with layers representing principal component predictions: pcRast <- pca(chelsa, scale = TRUE) plot(pcRast)  # Get information on the PCA: prinComp <- pcs(pcRast)  prinComp summary(prinComp) plot(prinComp)  }"},{"path":"/reference/pcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve a principal components model from a PCA GRaster — pcs","title":"Retrieve a principal components model from a PCA GRaster — pcs","text":"Retrieve principal components model PCA GRaster","code":""},{"path":"/reference/pcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve a principal components model from a PCA GRaster — pcs","text":"","code":"pcs(x)"},{"path":"/reference/pcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve a principal components model from a PCA GRaster — pcs","text":"x GRaster created pca()","code":""},{"path":"/reference/pcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve a principal components model from a PCA GRaster — pcs","text":"object class prcomp.","code":""},{"path":[]},{"path":"/reference/pcs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve a principal components model from a PCA GRaster — pcs","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Climate raster: madChelsa <- fastData(\"madChelsa\")  # Convert a SpatRaster to a GRaster: chelsa <- fast(madChelsa)  # Generate raster with layers representing principal component predictions: pcRast <- pca(chelsa, scale = TRUE) plot(pcRast)  # Get information on the PCA: prinComp <- pcs(pcRast)  prinComp summary(prinComp) plot(prinComp)  }"},{"path":"/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Display a raster or vector — plot,GRaster,missing-method","title":"Display a raster or vector — plot,GRaster,missing-method","text":"plot() displays GRaster GVector. function essentially hack, possible dependably call appropriate GRASS modules display raster vector without potential confusion user side. Instead, function 1) simplifies focal GRaster GVector make smaller saved disk; 2) writes object disk; 3) (internally) creates SpatRaster SpatVector object; 4) plots object using terra::plot(). Thus, interested making maps, always faster make directly terra sf.","code":""},{"path":"/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display a raster or vector — plot,GRaster,missing-method","text":"","code":"# S4 method for class 'GRaster,missing' plot(x, y, simplify = TRUE, ...)  # S4 method for class 'GVector,missing' plot(x, y, maxGeoms = 10000, ...)"},{"path":"/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display a raster or vector — plot,GRaster,missing-method","text":"x GRaster GVector. y Missing–leave empty. simplify Logical: TRUE (default) raster x- /y-resolution greater screen resolution, aggregate() applied raster saved reduce time takes save raster. ... arguments send terra::plot(). maxGeoms Positive integer (vectors ): Maximum number features vector simplification applied saving disk creating SpatVector plotting. default 10000.","code":""},{"path":"/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display a raster or vector — plot,GRaster,missing-method","text":"Nothing (displays raster vector).","code":""},{"path":[]},{"path":"/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display a raster or vector — plot,GRaster,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") # elevation raster madLANDSAT <- fastData(\"madLANDSAT\") # multi-layer raster madRivers <- fastData(\"madRivers\") # lines vector  # Convert SpatRaster to GRaster and SpatVector to GVector elev <- fast(madElev) rivers <- fast(madRivers) landsat <- fast(madLANDSAT)  # Plot: plot(elev) plot(rivers, add = TRUE)  # Histograms: hist(elev) hist(landsat)  # Plot surface reflectance in RGB: plotRGB(landsat, 3, 2, 1) # \"natural\" color plotRGB(landsat, 4, 1, 2, stretch = \"lin\") # emphasize near-infrared (vegetation)  # Make composite map from RGB layers and plot in grayscale: comp <- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]]) grays <- paste0(\"gray\", 0:100) plot(comp, col = grays)  }"},{"path":"/reference/plotRGB.html","id":null,"dir":"Reference","previous_headings":"","what":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","title":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","text":"function takes main argument GRaster least three layers typically representing red, green, blue components (plus possibly \"alpha\", transparency layer). plot(), function somewhat hack downsamples layers coarser resolution using aggregate(), saves raster disk, uses terra::plotRGB() actual plotting.","code":""},{"path":"/reference/plotRGB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","text":"","code":"# S4 method for class 'GRaster' plotRGB(x, r = 1, g = 2, b = 3, a = NULL, simplify = TRUE, ...)"},{"path":"/reference/plotRGB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","text":"x GRaster. Values must range 0 255. r, g, b Either numeric integer names() layers representing red, green, blue components. Either NULL (default), numeric integer names() layer representing transparency. simplify Logical: TRUE (default), downsample GRaster plotting. can save time dense rasters. ... Arguments pass terra::plotRGB().","code":""},{"path":"/reference/plotRGB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","text":"Nothing (makes plot).","code":""},{"path":[]},{"path":"/reference/plotRGB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create red-green-blue plot from a raster with RGB layers — plotRGB,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") # elevation raster madLANDSAT <- fastData(\"madLANDSAT\") # multi-layer raster madRivers <- fastData(\"madRivers\") # lines vector  # Convert SpatRaster to GRaster and SpatVector to GVector elev <- fast(madElev) rivers <- fast(madRivers) landsat <- fast(madLANDSAT)  # Plot: plot(elev) plot(rivers, add = TRUE)  # Histograms: hist(elev) hist(landsat)  # Plot surface reflectance in RGB: plotRGB(landsat, 3, 2, 1) # \"natural\" color plotRGB(landsat, 4, 1, 2, stretch = \"lin\") # emphasize near-infrared (vegetation)  # Make composite map from RGB layers and plot in grayscale: comp <- compositeRGB(r = landsat[[3]], g = landsat[[2]], b = landsat[[1]]) grays <- paste0(\"gray\", 0:100) plot(comp, col = grays)  }"},{"path":"/reference/predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","title":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","text":"version predict() function make predictions set GRasters model object. model must either linear model, class lm typically created using stats::lm() function generalized linear model (GLM), class glm typically created using stats::glm(). packages can also create lm glm objects, may work function. example, generalized additive models, can created using gam() function mgcv package, inherit glm class, used function, ones created speedglm package can. predict() function can handle: Linear predictors intercepts like y ~ 1 + x; Quadratic terms like y ~ x^2 (, R formular notation, y ~ (x^2)); Two-way interaction terms scalars like y ~ x1:x2 y ~ x1 * x2; Categorical predictors (.e., categorical rasters); Two-way interactions categorical predictor scalar predictor; Two-way interactions categorical predictors.","code":""},{"path":"/reference/predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","text":"","code":"# S4 method for class 'GRaster' predict(object, model, type = \"response\")"},{"path":"/reference/predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","text":"object GRaster one layers. model lm glm model object. type Character: Type prediction make. can either link (default; predictions made scale link function) response (predictions made scale response variable). function can make predictions scale response identity, logit, log, cloglog (complementary log-log) link functions.","code":""},{"path":"/reference/predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make predictions from a linear or generalized linear model to a GRaster — predict,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  ### This example creates a simple model of Dypsis distribution using # elevation, distance to forest, land cover class, and nearness to rivers.  # Elevation raster, forest cover in year 2000, land cover class, and # points where Dypsis plants have been collected madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCover <- fastData(\"madCover\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert SpatRasters to GRasters and sf vector to GVector: elev <- fast(madElev) forest <- fast(madForest2000) cover <- fast(madCover) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Distance to forest distToForest <- distance(forest, unit = \"m\") distToForest <- log1p(distToForest) # log(x + 1) of distance names(distToForest) <- \"distToForest\"  # \"Stack\" elevation and forest cover continuous <- c(elev, distToForest)  # Scale continuous predictors to mean of 0 and sd of 1 continuousScaled <- scale(continuous) names(continuousScaled) <- c(\"elevation\", \"distToForest\")  # Project land cover raster coverProj <- project(cover, continuousScaled)  # Near a river? riverBuffer <- buffer(rivers, 5000) nearRiver <- rasterize(riverBuffer, elev, background = 0) names(nearRiver) <- \"nearRiver\" levels(nearRiver) <- data.frame(value = 0:1, label = c(\"far\", \"near\"))  # Combine continuous/categorical data covariateRasters <- c(continuousScaled, coverProj, nearRiver) plot(covariateRasters)  # Extract environmental values at Dypsis locations: presEnv <- extract(covariateRasters, dypsis, cats = TRUE) presEnv$presBg <- 1 head(presEnv)  # Extract elevation and forest cover at background 2000 sites: bgEnv <- spatSample(covariateRasters, size = 3000, values = TRUE, cats = TRUE) bgEnv <- bgEnv[stats::complete.cases(bgEnv), ] bgEnv <- bgEnv[1:2000, ] bgEnv$presBg <- 0 head(bgEnv)  # Combine presence and background data: env <- rbind(presEnv, bgEnv)  # Calibrate model: form <- presBg ~ elevation + distToForest + I(distToForest^2) + elevation * distToForest + madCover + nearRiver  model <- stats::glm(form, data = env, family = stats::binomial) summary(model)  # Make predictions and map: prediction <- predict(covariateRasters, model, type = \"response\") prediction  # Not a great model! plot(prediction) plot(dypsis, pch = 1, add = TRUE)  }"},{"path":"/reference/project.html","id":null,"dir":"Reference","previous_headings":"","what":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"project() changes coordinate reference system (CRS) GRaster GVector. three use cases: x GRaster y GRaster: x projected CRS y resampled resolution y. argument align FALSE, also cropped extent y. x GRaster y GVector CRS string (typically Well-Known Text format): x projected CRS specified y resampled cropped. x GVector y GRaster, GVector, CRS string: vector projected CRS y.","code":""},{"path":"/reference/project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"","code":"# S4 method for class 'GRaster' project(   x,   y,   align = FALSE,   method = NULL,   fallback = TRUE,   res = \"fallback\",   wrap = FALSE,   verbose = FALSE )  # S4 method for class 'GVector' project(x, y, wrap = FALSE)"},{"path":"/reference/project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"x GRaster GVector projected. y character GLocation object (.e., typically GRaster GVector): Used set focal GRaster GVector's new CRS (resolution possibly extent, GRasters). align Logical: FALSE (default), x y GRasters, extent x cropped extent y. TRUE, cropping performed. method Character NULL (GRasters ): Method use conduct transformation (rasters ). Partial matching used. NULL (default): Automatically choose based raster properties (near categorical data, bilinear continuous data). \"near\": Nearest neighbor. Best categorical data, often poor choice continuous data.  datatype() integer, method used default. \"bilinear\": Bilinear interpolation (default non-categorical data; uses weighted values 4 cells). \"bicubic\": Bicubic interpolation (uses weighted values 16 cells). \"lanczos\": Lanczos interpolation (uses weighted values 25 cells). Note #1: x y GRasters, res = \"terra\", method used resample x resolution y projecting x. Note #2: Methods use multiple cells cause focal cell become NA least one cell NA cells draws . NA cells can often filled using fallback argument. fallback Logical (projecting GRasters ): TRUE (default), use \"lower\" resampling methods fill NA cells \"higher\" resampling method used. example, method = \"bicubic\", NA cells filled using bilinear method, except results NAs, case near method used. Fallback causes fewer cells revert NA values, may better capturing complex \"edges\" (e.g., coastlines). Fallback increase processing time \"lower\" method must applied, results merged. Fallback used method = \"near\". res Character (projecting GRasters ): Method used set resolution GRaster new CRS. can one three options.  Partial matching used case ignored: \"terra\": method creates output raster close possible values resolution one terra::project() create. However, large rasters (.e., many cells), can fail terra::project() encounters memory limits (used internally create template). method resamples focal raster starting CRS, projects destination CRS. \"template\": method can used y GRaster. output resolution y possibly extent (depending value align). However, unlike \"terra\" method, cell values necessarily close possible terra::project() generate (unless method = \"near\"). Unlike \"terra\" method, method resample focal raster starting CRS projecting. large rasters faster \"terra\" method (especially \"method = \"near\"), less likely fail memory limits. Two numeric values: Values new resolution (x- y-dimensions). \"center\": method locates centroid raster projected (CRS original raster). creates four points north, south, east, west centroid, spaced one cell's width centroid. set points projected new CRS. new cell size x-dimension average distance east west points centroid, y-dimension average centroid north south points. \"fallback\" (default): applies terra method first, fails, tries template, center. process can take long time large rasters. wrap Logical: GRasters: projecting rasters \"wrap around\" (.e., whole-world rasters rasters edges actually circle around meet globe), wrap TRUE avoid removing rows columns \"edge\" map. default FALSE. GVectors: projecting vectors span international date line 180E/W, wrap TRUE avoid issue coordinates incorrectly mapped range -180 180. verbose Logical (projecting GRasters ): TRUE, display progress. Default FALSE.","code":""},{"path":"/reference/project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"GRaster GVector.","code":""},{"path":"/reference/project.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"projecting raster, \"fallback\" methods GRASS module r.import actually used, even though method argument takes strings specifying non-fallback methods. See manual page r.import GRASS module.","code":""},{"path":[]},{"path":"/reference/project.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change the coordinate reference system of a GRaster or GVector — project,GRaster-method","text":"","code":"if (grassStarted()) {  ### Setup for all examples ##########################  library(sf) library(terra)  # Climate raster, elevation raster, rivers vector madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\") madChelsa <- fastData(\"madChelsa\")  # Convert objects into fasterRaster formats chelsa <- fast(madChelsa) elev <- fast(madElev) rivers <- fast(madRivers)  ### Project raster without resampling elevWGS84 <- project(elev, crs(chelsa)) elevWGS84  ### Project raster and resample to resolution of another raster elevWGS84Resamp <- project(elev, chelsa) elevWGS84Resamp  res(elevWGS84) res(elevWGS84Resamp) res(chelsa)  ### Project vector riversWGS84 <- project(rivers, chelsa) riversWGS84 cat(crs(rivers)) # using \"cat()\" to make it look nice cat(crs(riversWGS84))  }"},{"path":"/reference/quiet.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns .quiet() or NULL for ","title":"Returns .quiet() or NULL for ","text":"function developers used setting \"quiet' argument flags arguments passed rgrass::execGRASS(). faster(\"verbose\") TRUE, string \"quiet\" returned. FALSE, NULL returned.","code":""},{"path":"/reference/quiet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns .quiet() or NULL for ","text":"","code":".quiet()"},{"path":"/reference/quiet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns .quiet() or NULL for ","text":"string (.quiet()) NULL.","code":""},{"path":"/reference/quiet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns .quiet() or NULL for ","text":"","code":"if (grassStarted()) {  faster(\"verbose\") .quiet()  }"},{"path":"/reference/rSpatialDepRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","title":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","text":"rSpatialDepRast() creates raster random values cells. Across raster, values approximately normally distributed, though raster \"true\" normal distribution can made rnormRast(). Spatial dependence can introduced, though together values still approximately normally distributed.","code":""},{"path":"/reference/rSpatialDepRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' rSpatialDepRast(   x,   n = 1,   mu = 0,   sigma = 1,   dist = 0,   exponent = 1,   delay = 0,   seed = NULL )"},{"path":"/reference/rSpatialDepRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","text":"x GRaster: output extent dimensions raster. n integer: Number rasters generate. mu, sigma Numeric: Mean sample standard deviation output. creating one raster, can provide one value per raster. fewer, recycled. dist Numeric: Maximum distance spatial autocorrelation (map units–typically meters). Default 0 (spatial autocorrelation). creating one raster, can provide one value per raster. fewer, values recycled. exponent Numeric > 0: Distance decay exponent. creating one raster, can provide one value per raster. fewer, values recycled. delay Numeric >= 0: Values >0 force distance decay similarity remain constant distance. Beyond distance, decay exponent takes effect. Default 0. creating one raster, can provide one value per raster. fewer, values recycled. seed Numeric integer NULL: Random seed. NULL, random seed used raster. provided, one seed value per raster.","code":""},{"path":"/reference/rSpatialDepRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/rSpatialDepRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a random raster with or without spatial dependence — rSpatialDepRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Create a raster with values drawn from a uniform distribution: unif <- runifRast(elev) plot(unif)  ### Create a raster with values drawn from a normal distribution: norms <- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1)) plot(norms) hist(norms, bins = 100)  # Create a raster with random, seemingly normally-distributed values: rand <- rSpatialDepRast(elev, dist = 1000) plot(rand)  # Values appear normal on first inspection: hist(rand)  # ... but actually are patterned: hist(rand, bins = 100)  # Create a fractal raster: fractal <- fractalRast(elev, n = 2, dimension = c(2.1, 2.8)) plot(fractal) hist(fractal)  }"},{"path":"/reference/rast.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a GRaster to a SpatRaster — rast,GRaster-method","title":"Convert a GRaster to a SpatRaster — rast,GRaster-method","text":"fasterRaster version rast() function converts GRaster SpatRaster (terra package).","code":""},{"path":"/reference/rast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a GRaster to a SpatRaster — rast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' rast(x, mm = FALSE, ...)"},{"path":"/reference/rast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a GRaster to a SpatRaster — rast,GRaster-method","text":"x GRaster. mm Logical: TRUE, call terra::setMinMax() raster ensure metadata minimum maximum values. large rasters, can take long time, default value mm FALSE. ... Additional arguments send writeRaster(). typically unneeded, though bigTiff may use raster large, supplying datatype can speed conversion large rasters. See writeRaster().","code":""},{"path":"/reference/rast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a GRaster to a SpatRaster — rast,GRaster-method","text":"SpatRaster (terra package).","code":""},{"path":[]},{"path":"/reference/rast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a GRaster to a SpatRaster — rast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/rasterize.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","title":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","text":"rasterize() function converts GVector GRaster.","code":""},{"path":"/reference/rasterize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","text":"","code":"# S4 method for class 'GVector,GRaster' rasterize(x, y, field = \"\", background = NA, by = NULL, verbose = TRUE)"},{"path":"/reference/rasterize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","text":"x GVector. y GRaster: new raster extent resolution raster. field Character: Name column data table y \"burn\" raster. \"\" (default), output categorical raster. field \"\", geometries \"burned\" raster value. background Numeric NA (default): Value put cells covered GVector. Note NA integer, output categorical raster (.e., \"levels\" table associated ). Either NULL (default) character: NULL, GVector subset values field named . output multi-layer raster, one layer per unique value . verbose Logical: NULL, display progress.","code":""},{"path":"/reference/rasterize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/rasterize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a GVector to a GRaster — rasterize,GVector,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster, outline of a part of Madagascar, and rivers vector: madElev <- fastData(\"madElev\") # raster madDypsis <- fastData(\"madDypsis\") # points vector madRivers <- fastData(\"madRivers\") # lines vector madCoast4 <- fastData(\"madCoast4\") # polygons vector  # Convert to GRaster and GVectors: elev <- fast(madElev) dypsis <- fast(madDypsis) coast4 <- fast(madCoast4) rivers <- fast(madRivers)  # Convert points, line, and polygons vectors to rasters: points <- rasterize(dypsis, elev) plot(points)  lines <- rasterize(rivers, elev) plot(lines)  polys <- rasterize(coast4, elev) plot(polys)  communes <- rasterize(coast4, elev, field = \"NAME_4\") plot(communes)  # Change background value: polysNeg1 <- rasterize(coast4, elev, background = -1) plot(polysNeg1)  # Make one layer per river: byRiver <- rasterize(rivers, elev, field = \"NAM\", by = \"NAM\") plot(byRiver)  }"},{"path":"/reference/rbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine one or more GVectors — rbind,GVector-method","title":"Combine one or more GVectors — rbind,GVector-method","text":"rbind() combines two GVectors type (points, lines, polygons) coordinate reference system. can speed operations putting vector largest memory first rbind(...). GVectors data tables, also combined using rbind() column names data types match.","code":""},{"path":"/reference/rbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine one or more GVectors — rbind,GVector-method","text":"","code":"# S4 method for class 'GVector' rbind(..., deparse.level = 1)"},{"path":"/reference/rbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine one or more GVectors — rbind,GVector-method","text":"... One GVectors. deparse.level See rbind().","code":""},{"path":"/reference/rbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine one or more GVectors — rbind,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/rbind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine one or more GVectors — rbind,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Rivers vector madRivers <- fastData(\"madRivers\")  # Convert sf to a GVector rivers <- fast(madRivers)  # Convert GVector to data.frame or data.table as.data.frame(rivers) as.data.table(rivers)  # Subset rivers vector rivers1 <- rivers[1:2] rivers2 <- rivers[10:11]  # Concatenate rivers riversCombo <- rbind(rivers1, rivers2) riversCombo  # Add columns newCol <- data.frame(new = 1:11) riversCol <- colbind(rivers, newCol) riversCol  # Remove table riversCopy <- rivers riversCopy # has data table riversCopy <- dropTable(riversCopy) riversCopy # no data table  # Add a new table newTable <- data.frame(num = 1:11, letters = letters[1:11]) addTable(riversCopy) <- newTable riversCopy  }"},{"path":"/reference/region.html","id":null,"dir":"Reference","previous_headings":"","what":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"functions either change extent, dimensions, /resolution GRASS \".region\" report current region\"s extent, dimensions, /resolution. functions mostly used internally rarely interest users. .region(): 2D 3D aspects region. .regionDim(): x- y-dimensions. .regionExt(): x- y-extent. .regionRes(): x- y-resolution.","code":""},{"path":"/reference/region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"","code":"# S4 method for class 'missing' .region(x)  # S4 method for class 'SpatRaster' .region(x)  # S4 method for class 'GRegion' .region(x)  # S4 method for class 'GRaster' .region(x, trim = NULL)  # S4 method for class 'GVector' .region(x)  # S4 method for class 'missing' .regionExt(x)  # S4 method for class 'numeric' .regionExt(x, respect)  # S4 method for class 'GSpatial' .regionExt(x, respect)  # S4 method for class 'missing' .regionDim(x)  # S4 method for class 'numeric' .regionDim(x, respect)  # S4 method for class 'GRegion' .regionDim(x, respect)  # S4 method for class 'missing' .regionRes(x)  # S4 method for class 'numeric' .regionRes(x, respect)  # S4 method for class 'GRegion' .regionRes(x, respect)"},{"path":"/reference/region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"x : Missing (default): Reports extent, resolution, dimensions current region. arguments ignored. can also use ext(), dim(), res() related functions missing arguments. GSpatial, GRegion, GRaster, GVector object: Sets region\"s extent, dimensions, /resolution object. numeric vector. resize region's extent, resample region's resolution/dimensions, , ensure desired dimensions resolution retained: * 2 values .regionDim(): Number rows columns * 4 values .regionExt(): Westernmost easternmost easting (longitude), southernmost northernmost northing (latitude) * 2 values .regionRes(): Size cells x- y-dimensions trim GRaster NULL (default). GRaster, region trimmed non-NA cells raster. trim can non-NULL x GRaster. Ignored NULL. respect Character GRaster: Indicates aspect(s) current region retain. Different functions allow different aspect retained. Partial matching used. .regionDim(): \"extent\" \"resolution\". .regionExt(): \"dimensions\" \"resolution\". .regionRes(): \"extent\" \"dimensions\". Alternatively, GRaster can supplied: .regionDim(): New region extent resolution. .regionExt(): New region dimensions resolution. .regionRes(): New region extent dimensions. case, new region\"s registration raster, cell resolution Note: cases extent retained exactly resolution changed. resolution changed, actual extent user-supplied extent expanded zero one rows zero one columns accommodate integer number cells desired size. western northern limits extent retained, eastern southern limits extent moved accommodate integer number columns rows.","code":""},{"path":"/reference/region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"value returned depends function used: used arguments, .region() returns GRegion object. used arguments, .regionDim(), .regionExt(), .regionRes() return numeric integer vectors. function used change reshape/resample region, returns GRegion object reflecting region changed. allows users revert original region desired.","code":""},{"path":"/reference/region.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"resizing extent, terra keeps xmin (west) ymax (north) fixed shifts xmax (east) ymin (south) needed. retain much fidelity fasterRaster terra possible, functions region.","code":""},{"path":"/reference/region.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report or change the extent, dimensions, and/or resolution of a region GRASS — .region,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\")  # Report information on current region: dim3d() nrow() ncol() ndepth() ncell() ncell3d()  ext() W() E() S() N()  res() res3d() xres() yres() zres()   }"},{"path":"/reference/reorient.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","title":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","text":"function converts facing \"north orientation\" \"east orientation\". \"north orientation\" systems, 0-degree facing north, angle facing proceeds clockwise. example, 90 degree facing faces east, 180 south, 270 west. \"east orientation\", 0-degree facing east, facing angle proceeds counter-clockwise. example, 90 north, 180 west, 270 south.","code":""},{"path":"/reference/reorient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","text":"","code":"# S4 method for class 'GRaster' reorient(x, units = \"degrees\")  # S4 method for class 'numeric' reorient(x, units = \"degrees\")"},{"path":"/reference/reorient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","text":"x numeric vector GRaster cell values equal facing (degrees). units Character: \"Units\" values x: either \"degrees\" degrees (default) \"radians\". Partial matching used.","code":""},{"path":"/reference/reorient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","text":"GRaster numeric vector. Values range 0 360 represents facing system \"opposing\" input's system. example, input north orientation, output east orientation. input east orientation, output north orientation.","code":""},{"path":"/reference/reorient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert degrees between 'north-orientation' and 'east orientation' — reorient,GRaster-method","text":"","code":"### Re-orient numeric values: facings <- c(0, 90, 180, 270, 360) reorient(facings) #> [1]  90   0 270 180  90  # Re-reorienting returns the same values: reorient(reorient(facings)) #> [1]   0  90 180 270   0  if (grassStarted()) {  ### Re-orient a GRaster:  # Setup library(terra) madElev <- fastData(\"madElev\") elev <- fast(madElev)  # Calculate aspect in degrees, using north orientation: aspectNorth <- terrain(elev, \"aspect\")  # Re-orient to east-facing: aspectEast <- reorient(aspectNorth)  # Re-reorienting is the same, to within rounding error: aspectNorth - reorient(reorient(aspectNorth))  # Plot: aspects <- c(aspectNorth, aspectEast) names(aspects) <- c(\"north_orientation\", \"east_orientation\") plot(aspects)   }"},{"path":"/reference/replaceNAs.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","title":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","text":"function replaces NAs one data.table, data.frame, matrix columns, vectors, user-defined value.","code":""},{"path":"/reference/replaceNAs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","text":"","code":"# S4 method for class 'data.frame' replaceNAs(x, replace, cols = NULL)  # S4 method for class 'matrix' replaceNAs(x, replace, cols = NULL)  # S4 method for class 'data.table' replaceNAs(x, replace, cols = NULL)  # S4 method for class 'numeric' replaceNAs(x, replace)  # S4 method for class 'integer' replaceNAs(x, replace)  # S4 method for class 'logical' replaceNAs(x, replace)  # S4 method for class 'character' replaceNAs(x, replace)"},{"path":"/reference/replaceNAs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","text":"x data.table data.frame matrix, vector numeric, integer, logical, character values. replace value atomic class (numeric, integer, character, Date, etc.): Value replace NAs. cols NULL, character, numeric, integer, logical vector: Indicates columns replace NAs. NULL, columns NAs replaced. character, column name(s). numeric integer, columns' indices. logical, columns TRUE NAs replaced. logical vector fewer total number columns, recycled.","code":""},{"path":"/reference/replaceNAs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","text":"data.table, data.frame, matrix, vector.","code":""},{"path":"/reference/replaceNAs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace NAs in a data.table or data.frame column, or in a vector — replaceNAs,data.frame-method","text":"","code":"library(data.table)  dt <- data.table(    x = 1:10,    y = letters[1:10],    z = rnorm(10) )  # make some values NA dt[x == 4 | x == 8, y := NA_character_] #>         x      y           z #>     <int> <char>       <num> #>  1:     1      a -0.55369938 #>  2:     2      b  0.62898204 #>  3:     3      c  2.06502490 #>  4:     4   <NA> -1.63098940 #>  5:     5      e  0.51242695 #>  6:     6      f -1.86301149 #>  7:     7      g -0.52201251 #>  8:     8   <NA> -0.05260191 #>  9:     9      i  0.54299634 #> 10:    10      j -0.91407483 dt #>         x      y           z #>     <int> <char>       <num> #>  1:     1      a -0.55369938 #>  2:     2      b  0.62898204 #>  3:     3      c  2.06502490 #>  4:     4   <NA> -1.63098940 #>  5:     5      e  0.51242695 #>  6:     6      f -1.86301149 #>  7:     7      g -0.52201251 #>  8:     8   <NA> -0.05260191 #>  9:     9      i  0.54299634 #> 10:    10      j -0.91407483  # Replace NAs: replaceNAs(dt, replace = -99, cols = \"y\") #>         x      y           z #>     <int> <char>       <num> #>  1:     1      a -0.55369938 #>  2:     2      b  0.62898204 #>  3:     3      c  2.06502490 #>  4:     4    -99 -1.63098940 #>  5:     5      e  0.51242695 #>  6:     6      f -1.86301149 #>  7:     7      g -0.52201251 #>  8:     8    -99 -0.05260191 #>  9:     9      i  0.54299634 #> 10:    10      j -0.91407483 dt #>         x      y           z #>     <int> <char>       <num> #>  1:     1      a -0.55369938 #>  2:     2      b  0.62898204 #>  3:     3      c  2.06502490 #>  4:     4    -99 -1.63098940 #>  5:     5      e  0.51242695 #>  6:     6      f -1.86301149 #>  7:     7      g -0.52201251 #>  8:     8    -99 -0.05260191 #>  9:     9      i  0.54299634 #> 10:    10      j -0.91407483  # Drop rows: dropped <- dropRows(dt, 8:10) dropped #>        x      y          z #>    <int> <char>      <num> #> 1:     1      a -0.5536994 #> 2:     2      b  0.6289820 #> 3:     3      c  2.0650249 #> 4:     4    -99 -1.6309894 #> 5:     5      e  0.5124269 #> 6:     6      f -1.8630115 #> 7:     7      g -0.5220125  # NB May not print... in that case, use: print(dropped) #>        x      y          z #>    <int> <char>      <num> #> 1:     1      a -0.5536994 #> 2:     2      b  0.6289820 #> 3:     3      c  2.0650249 #> 4:     4    -99 -1.6309894 #> 5:     5      e  0.5124269 #> 6:     6      f -1.8630115 #> 7:     7      g -0.5220125  # We can also use replaceNAs() on vectors: y <- 1:10 y[c(2, 10)] <- NA replaceNAs(y, -99) #>  [1]   1 -99   3   4   5   6   7   8   9 -99  # Same as: y <- 1:10 y[c(2, 10)] <- NA y[is.na(y)] <- -99"},{"path":"/reference/replace_dollar.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace a raster layer or a column from a vector's data table — $<-","title":"Replace a raster layer or a column from a vector's data table — $<-","text":"$<- notation can used replace specific layer multi-layer GRaster, replace specific column GVector's data table.","code":""},{"path":"/reference/replace_dollar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace a raster layer or a column from a vector's data table — $<-","text":"","code":"# S4 method for class 'GRaster' x$name <- value  # S4 method for class 'GVector' x$name <- value"},{"path":"/reference/replace_dollar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace a raster layer or a column from a vector's data table — $<-","text":"x GRaster GVector. name Character: Name GRaster layer replace, name GVector column replace. value Character: name GRaster layer name column GVector's data table. Names rasters vector tables' columns cab obtained using names().","code":""},{"path":"/reference/replace_dollar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace a raster layer or a column from a vector's data table — $<-","text":"GRaster column GVector.","code":""},{"path":[]},{"path":"/reference/replace_dollar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace a raster layer or a column from a vector's data table — $<-","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/replace_double_square_brackets.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace layers of a GRaster — [[<-","title":"Replace layers of a GRaster — [[<-","text":"[[<- operator can used replace layer multi-layer GRaster.","code":""},{"path":"/reference/replace_double_square_brackets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace layers of a GRaster — [[<-","text":"","code":"# S4 method for class 'GRaster,ANY' x[[i]] <- value"},{"path":"/reference/replace_double_square_brackets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace layers of a GRaster — [[<-","text":"x GRaster. numeric integer, integer, logical, character: Indicates layer replace. logical vector, vector must length layers x. value Either GRaster NULL: NULL, layer indicated removed.","code":""},{"path":"/reference/replace_double_square_brackets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace layers of a GRaster — [[<-","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/replace_single_square_bracket.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace values of a GRaster — [<-","title":"Replace values of a GRaster — [<-","text":"[<- operator can used replace values GRaster, specific values depending expression . example, use rast[] <- 10 assign 10 cells, rast[rast > 0] <- 10 assign cells values >0 10.","code":""},{"path":"/reference/replace_single_square_bracket.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace values of a GRaster — [<-","text":"","code":"# S4 method for class 'GRaster,missing,ANY' x[i, j] <- value  # S4 method for class 'GRaster,GRaster,ANY' x[i, j] <- value"},{"path":"/reference/replace_single_square_bracket.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace values of a GRaster — [<-","text":"x GRaster. Either missing conditional statement resolves GRaster. j used value numeric, integer, logical value, NA. single value can used.","code":""},{"path":"/reference/replace_single_square_bracket.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace values of a GRaster — [<-","text":"GRaster.","code":""},{"path":"/reference/replace_single_square_bracket.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace values of a GRaster — [<-","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/res.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial resolution — res,missing-method","title":"Spatial resolution — res,missing-method","text":"Spatial resolution GRaster: res(): 2-dimensional resolution (x y). res3d(): 3-dimensinal resolution (z, y, z). xres(), yres(), zres(): East-west resolution, north-south resolution, top-bottom resolution.","code":""},{"path":"/reference/res.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial resolution — res,missing-method","text":"","code":"# S4 method for class 'missing' res(x)  # S4 method for class 'GRegion' res(x)  # S4 method for class 'missing' xres(x)  # S4 method for class 'GRegion' xres(x)  # S4 method for class 'missing' yres(x)  # S4 method for class 'GRegion' yres(x)  # S4 method for class 'missing' zres(x)  # S4 method for class 'GRegion' zres(x)  # S4 method for class 'missing' res3d(x)  # S4 method for class 'GRegion' res3d(x)"},{"path":"/reference/res.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial resolution — res,missing-method","text":"x GRaster, GRegion, missing. missing, resolution currently active region returned.","code":""},{"path":"/reference/res.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial resolution — res,missing-method","text":"numeric vector. res() res3d(), first value length cells x-direction second length cells y-direction. res3d() third value height voxel (z-direction). xres(), yres(), zres() return single value.","code":""},{"path":[]},{"path":"/reference/res.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial resolution — res,missing-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/resample.html","id":null,"dir":"Reference","previous_headings":"","what":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","title":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","text":"resample() changes cell size (resolution) GRaster using either another raster template user-defined resolution. Note extent output raster may expanded accommodate integer number cells. function guaranteed recreate output terra::resample(), even resampling method used.","code":""},{"path":"/reference/resample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","text":"","code":"# S4 method for class 'GRaster,GRaster' resample(x, y, method = NULL, fallback = TRUE)  # S4 method for class 'GRaster,numeric' resample(x, y, method = NULL, fallback = TRUE)"},{"path":"/reference/resample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","text":"x GRaster resample. y Either GRaster serve template, numeric vector two three values. numeric vector, values represent east-west north-south resolution 2D rasters, east-west, north-south, top-bottom resolution 3D rasters. method Character NULL: Method use assign values cells. Partial matching used. NULL (default): Automatically choose based raster properties (near categorical integer rasters, bilinear continuous data). \"near\": Nearest neighbor. Best categorical data, often poor choice continuous data.  nlevels() >0, method used regardless value method. still want use different method, coerce raster different type using .int(), .float(), .doub(). \"bilinear\": Bilinear interpolation (default non-categorical data; uses weighted values 4 cells). \"bicubic\": Bicubic interpolation (uses weighted values 16 cells). \"lanczos\": Lanczos interpolation (uses weighted values 25 cells). Note methods use multiple cells cause focal cell become NA least one cell NA cells draws . NA cells can filled using fallback option. fallback Logical: TRUE (default), use \"lower\" methods fill NA cells \"higher\" method used. example, method = \"bicubic\", NA cells filled using bilinear method, except results NAs, case near method used. Fallback causes fewer cells revert NA values, can better resampling edges rasters. However, fallback increase processing time \"lower\" method must applied, results merged.","code":""},{"path":"/reference/resample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/resample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change the cell size of a GRaster — resample,GRaster,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\") elev <- fast(madElev)  ### Resample raster to 120 x 120 m elev120 <- resample(elev, c(120, 120), method=\"bilinear\") elev elev120  ### Resample using another raster as a template ###############################################  template <- aggregate(elev, 4)  nearest <- resample(elev, template, method = \"nearest\")  bilinear <- resample(elev, template, method = \"bilinear\") bilinearNoFB <- resample(elev, template, method = \"bilinear\", fallback = FALSE)  bicubic <- resample(elev, template, method = \"bicubic\") bicubicNoFB <- resample(elev, template, method = \"bicubic\", fallback = FALSE)  lanczos <- resample(elev, template, method = \"lanczos\") lanczosNoFB <- resample(elev, template, method = \"lanczos\", fallback = FALSE)  # rasters resampled without fallback have fewer non-NA cells resampled <- c(nearest, bilinear, bilinearNoFB, bicubic, bicubicNoFB, lanczos,     lanczosNoFB) names(resampled) <- c(\"nearest\", \"bilinear\", \"bilinearNoFB\", \"bicubic\",     \"bicubicNoFB\", \"lanczos\", \"lanczosNoFB\") ones <- resampled * 0 + 1 global(ones, \"sum\") # number of non-NA cells global(resampled, c(\"mean\", \"sd\", \"min\", \"max\")) # other statistics  # Compare fallback to no fallback frLanczos <- rast(lanczos) frLanczosNoFB <- rast(lanczosNoFB)  plot(frLanczos, col = \"red\",     main = \"Red: Cells in fallback not non-fallback\", legend = FALSE) plot(frLanczosNoFB, add=TRUE)  # Compare fasterRaster with terra coarserTerra <- aggregate(madElev, 4) terraLanczos <- resample(madElev, coarserTerra, method = \"lanczos\")  frLanczos <- extend(frLanczos, terraLanczos) frLanczosNoFB <- extend(frLanczosNoFB, terraLanczos)  frLanczos - terraLanczos frLanczosNoFB - terraLanczos  plot(frLanczos - terraLanczos, main = \"Difference\") plot(frLanczosNoFB - terraLanczos, main = \"Difference\")  plot(terraLanczos, col = \"red\",     main = \"Red: Cells in terra not in FR\", legend = FALSE) plot(frLanczos, add=TRUE)  plot(frLanczos, col = \"red\",     main = \"Red: Cells in FR not in terra\", legend = FALSE) plot(terraLanczos, add=TRUE)  }"},{"path":"/reference/rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete objects in the active GRASS session — .rm","title":"Delete objects in the active GRASS session — .rm","text":"Delete names rasters /vectors exported created active GRASS session's location mapset.","code":""},{"path":"/reference/rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete objects in the active GRASS session — .rm","text":"","code":".rm(x, type = NULL, warn = TRUE, verify = TRUE)"},{"path":"/reference/rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete objects in the active GRASS session — .rm","text":"x Character, GSpatial object, missing (default): Character: \"rasters\" (rasters), \"vectors\" (spatial vectors), \"rasters3d\" (3D-rasters), /\"groups\" (groups), types deleted. Partial matching supported. sources object deleted. Argument type must specified. GSpatial object (.e., GRaster GVector): Delete object. Missing: Delete everything active GRASS session. type type spatial objects delete. can include \"rasters\" (rasters), \"vectors\" (spatial vectors), \"rasters3d\" (3D-rasters), /\"groups\" (groups). Partial matching supported. missing, objects candidates deletion match x. warn Logical: TRUE (default), display warning matches everything GRASS deleted. verify Logical: TRUE (default), function search item(s) deleted first verify exist. FALSE, x MUST specified type must 'raster' 'vector' (one value per value x). effect x GSpatial object. main use save bit time.","code":""},{"path":"/reference/rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete objects in the active GRASS session — .rm","text":"TRUE (invisibly).","code":""},{"path":[]},{"path":"/reference/rnormRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","title":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","text":"rnormRast() creates raster values drawn normal distribution.","code":""},{"path":"/reference/rnormRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' rnormRast(x, n = 1, mu = 0, sigma = 1, seed = NULL)"},{"path":"/reference/rnormRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","text":"x GRaster: output extent dimensions raster. n integer: Number rasters generate. mu, sigma Numeric: Mean sample standard deviation output. creating one raster, can provide one value per raster. fewer, recycled. seed Numeric integer NULL: Random seed. NULL, random seed used raster. provided, one seed value per raster.","code":""},{"path":"/reference/rnormRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/rnormRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a raster with random values drawn from a normal distribution — rnormRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Create a raster with values drawn from a uniform distribution: unif <- runifRast(elev) plot(unif)  ### Create a raster with values drawn from a normal distribution: norms <- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1)) plot(norms) hist(norms, bins = 100)  # Create a raster with random, seemingly normally-distributed values: rand <- rSpatialDepRast(elev, dist = 1000) plot(rand)  # Values appear normal on first inspection: hist(rand)  # ... but actually are patterned: hist(rand, bins = 100)  # Create a fractal raster: fractal <- fractalRast(elev, n = 2, dimension = c(2.1, 2.8)) plot(fractal) hist(fractal)  }"},{"path":"/reference/ruggedness.html","id":null,"dir":"Reference","previous_headings":"","what":"Terrain ruggedness index — ruggedness,GRaster-method","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"given focal grid cell, terrain ruggedness index (TRI) calculated taking square root average squared difference focal cell's elevation elevations 8 surrounding cells, $$\\sqrt(\\sum_{= 1}^{8}(m_i - m_0)^2 / 8)$$ \\(m_0\\) elevation focal cell \\(m_i\\) elevation ith grid cell.","code":""},{"path":"/reference/ruggedness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"","code":"# S4 method for class 'GRaster' ruggedness(x)"},{"path":"/reference/ruggedness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"x GRaster.","code":""},{"path":"/reference/ruggedness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/ruggedness.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"Riley, S.J., DeGloria, S.D., Elliot, R. 1999. terrain ruggedness index quantifies topographic heterogeneity. Intermountain Journal Sciences 5:23-27.","code":""},{"path":[]},{"path":"/reference/ruggedness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Terrain ruggedness index — ruggedness,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert to GRaster: elev <- fast(madElev)  # Terrain ruggedness index: tri <- ruggedness(elev) plot(c(elev, tri))  # Topographic wetness index: twi <- wetness(elev) plot(c(elev, twi))  }"},{"path":"/reference/runifRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","title":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","text":"runifRast() creates raster values drawn uniform (flat) distribution.","code":""},{"path":"/reference/runifRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' runifRast(x, n = 1, low = 0, high = 1, seed = NULL)"},{"path":"/reference/runifRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","text":"x GRaster. output extent dimensions raster. n numeric integer: Number rasters generate. low, high Numeric: Minimum maximum values select. seed Numeric integer vector NULL: Random seed. NULL, different seed generated GRASS. Defining useful want recreate rasters.  provided, one seed value per raster.","code":""},{"path":"/reference/runifRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/runifRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a raster with random values drawn from a uniform distribution — runifRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Create a raster with values drawn from a uniform distribution: unif <- runifRast(elev) plot(unif)  ### Create a raster with values drawn from a normal distribution: norms <- rnormRast(elev, n = 2, mu = c(5, 10), sigma = c(2, 1)) plot(norms) hist(norms, bins = 100)  # Create a raster with random, seemingly normally-distributed values: rand <- rSpatialDepRast(elev, dist = 1000) plot(rand)  # Values appear normal on first inspection: hist(rand)  # ... but actually are patterned: hist(rand, bins = 100)  # Create a fractal raster: fractal <- fractalRast(elev, n = 2, dimension = c(2.1, 2.8)) plot(fractal) hist(fractal)  }"},{"path":"/reference/rvoronoi.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","title":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","text":"function partitions region Voronoi polygons completely overlap . polygon random center. function essentially wrapper spatSample() voronoi().","code":""},{"path":"/reference/rvoronoi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","text":"","code":"# S4 method for class 'GRaster' rvoronoi(x, size = 100, seed = NULL)  # S4 method for class 'GVector' rvoronoi(x, size = 100, seed = NULL)"},{"path":"/reference/rvoronoi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","text":"x GRaster GVector used constrain location random points used create tesselation. size Numeric integer integer: Number polygons. seed Numeric integer, integer, NULL (default): Value used random seed. NULL, random seed generated GRASS.","code":""},{"path":"/reference/rvoronoi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","text":"GVector.","code":""},{"path":"/reference/rvoronoi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a randomly-positioned tesselation — rvoronoi,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example vectors madDypsis <- fastData(\"madDypsis\") # points madCoast4 <- fastData(\"madCoast4\") # polygons  # Convert sf vectors to GVectors dypsis <- fast(madDypsis) coast4 <- fast(madCoast4) ant <- coast4[coast4$NAME_4 == \"Antanambe\"]  # Delaunay triangulation dypsisDel <- delaunay(dypsis) plot(dypsisDel) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Voronoi tessellation vor <- voronoi(dypsis) plot(vor) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Random Voronoi tessellation rand <- rvoronoi(coast4, size = 100) plot(rand)  }"},{"path":"/reference/sampleRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","title":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","text":"sampleRast() randomly samples cells non-NA cells raster. output raster selected non-NA cells, cells set NA. generate random points, see spatSample().","code":""},{"path":"/reference/sampleRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' sampleRast(   x,   size,   prop = FALSE,   maskvalues = NA,   updatevalue = NULL,   test = FALSE,   seed = NULL )"},{"path":"/reference/sampleRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","text":"x GRaster. size Numeric: Number cells proportion cells select. prop Logical: TRUE, value size interpreted proportion cells. default FALSE (size interpreted number cells select). maskvalues Numeric vector, including NA, NULL (default): Values raster select . others ignored. NULL, non-NA cells selected retention. updatevalue Numeric NULL (default): Value assign masked cells. NULL, values input raster retained. test Logical: TRUE, size greater number non-NA cells x, fail. Testing can take long time large rasters. default FALSE. seed NULL (default) numeric: NULL, random seed generated random number generator. Otherwise seed can provided.","code":""},{"path":"/reference/sampleRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/sampleRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Randomly sample cells from a GRaster — sampleRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") # raster  # Convert to GRasters and GVectors elev <- fast(madElev)  ### spatSample() ################  # Random points as data.frame or data.table: randVals <- spatSample(elev, size = 20, values = TRUE) randVals  # Random points as a points GVector: randPoints <- spatSample(elev, size = 20, as.points = TRUE) randPoints plot(elev) plot(randPoints, add = TRUE)  # Random points in a select area: madCoast <- fastData(\"madCoast4\") # vector coast <- fast(madCoast) ant <- coast[coast$NAME_4 == \"Antanambe\"] # subset  restrictedPoints <- spatSample(elev, size = 20, as.points = TRUE,    strata = ant)  plot(elev) plot(ant, add = TRUE) plot(restrictedPoints, add = TRUE) # note 20 points for entire geometry  # Random points, one set per subgeometry: stratifiedPoints <- spatSample(elev, size = 20, as.points = TRUE,    strata = ant, byStratum = TRUE)  plot(elev) plot(ant, add = TRUE) plot(stratifiedPoints, pch = 21, bg = \"red\", add = TRUE) # note 20 points per subgeometry  # Random categories: madCover <- fastData(\"madCover\") # raster cover <- fast(madCover)  randCover <- spatSample(cover, size = 20, values = TRUE,      cat = TRUE, xy = TRUE) randCover  ### sampleRast() ################  # Random cells in non-NA cells: rand <- sampleRast(elev, 10000) plot(rand) nonnacell(rand)  # Use custom values for the mask: randCustomMask <- sampleRast(elev, 10000, maskvalues = 1:20) plot(randCustomMask)  # Force selected values to a custom value: randCustomUpdate <- sampleRast(elev, 10000, updatevalue = 7) plot(randCustomUpdate)  # Custom values for mask and set selected cells to custom value: randAll <- sampleRast(elev, 10000, maskvalues = 1:20, updatevalue = 7) plot(randAll)  }"},{"path":"/reference/scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Center and scale a GRaster, or the opposite — scale,GRaster-method","title":"Center and scale a GRaster, or the opposite — scale,GRaster-method","text":"scale() scalepop() center scale layers GRaster subtracting raster mean value (centering), dividing standard deviation (scaling). useful using raster linear model, example, unscaled predictors can lead numerical instability. scale() function uses sample standard deviation, scalepop() function uses population standard deviation. even moderately-sized rasters, difference two negligible, scalepop() function can much faster scale() function. unscale() function opposite scale() scalepop(): multiples layer value (presumably, standard deviation), adds another value (presumably, mean).","code":""},{"path":"/reference/scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Center and scale a GRaster, or the opposite — scale,GRaster-method","text":"","code":"# S4 method for class 'GRaster' scale(x, center = TRUE, scale = TRUE)  # S4 method for class 'GRaster' scalepop(x, center = TRUE, scale = TRUE)  # S4 method for class 'GRaster' unscale(x, center = NULL, scale = NULL)"},{"path":"/reference/scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Center and scale a GRaster, or the opposite — scale,GRaster-method","text":"x GRaster. center Value depends function: scale(): Logical: TRUE (default), subtract raster layer mean. unscale(): Numeric vector NULL (default): can single value, recycled one layer raster, one value per raster layer. value NA, un-centering performed relevant raster layer. NULL, un-centering done. scale Value depends function: scale(): Logical: TRUE (default), divide layer standard deviation. unscale(): Numeric vector NULL (default): can single value, recycled one layer raster, one value per raster layer. value NA, unscaling done relevant raster layer. NULL, un-scaling done.","code":""},{"path":"/reference/scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Center and scale a GRaster, or the opposite — scale,GRaster-method","text":"functions return GRaster. output scale() scalepop() two attributes, \"center\" \"scale\", means standard deviations original rasters (center scale TRUE, otherwise, NA). can obtained using attributes(output_raster)$center attributes(output_raster)$scale.","code":""},{"path":"/reference/scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Center and scale a GRaster, or the opposite — scale,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Climate rasters: madChelsa <- fastData(\"madChelsa\")  # Convert to GRasters: chelsa <- fast(madChelsa)  ### Center and scale rasters # Scale with using sample SD: chScaled <- scale(chelsa) chScaled  # Scale with using sample SD: chScaledPop <- scalepop(chelsa) chScaledPop  # Means are very close to 0 and SDs to 1: global(chScaled, c(\"mean\", \"sd\", \"min\", \"max\")) global(chScaledPop, c(\"mean\", \"sd\", \"min\", \"max\"))  # Get original means and sd's: centers <- attributes(chScaled)$center scales <- attributes(chScaled)$scale centers scales  ### Unscale rasters: chUnscaled <- unscale(chScaled, center = centers, scale = scales)  # Means and SD are returned to original values: global(chUnscaled, c(\"mean\", \"sd\", \"min\", \"max\")) # unscaled global(chelsa, c(\"mean\", \"sd\", \"min\", \"max\")) # original  }"},{"path":"/reference/selectRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","title":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","text":"selectRange() selects values GRasters \"stack\" based values another \"selection\" raster. example, stack three layers (call , B, C), \"selection\" raster values 1, 2, 3 cell. raster returned values wherever selection raster 1, B 2, C 3.","code":""},{"path":"/reference/selectRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","text":"","code":"# S4 method for class 'GRaster' selectRange(x, y)"},{"path":"/reference/selectRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","text":"x GRaster, typically one layer. y GRaster integer values. raster rounded . values typically 1 number layers x, wherever outside range, returned raster NA values.","code":""},{"path":"/reference/selectRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/selectRange.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select values from rasters in a stack based on values in another raster — selectRange,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  # Make a stack of various versions of \"elev\" from which to select from: x <- c(elev, 10 * elev, ln(elev), -1 * elev) x  # Make a layer with random numbers between 1 and 4: fun <- \"= round(rand(0.5, 4.5))\" y <- app(elev, fun = fun)  selected <- selectRange(x, y)  }"},{"path":"/reference/seqToSQL.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a numeric series into an SQL value call — seqToSQL","title":"Format a numeric series into an SQL value call — seqToSQL","text":"function takes argument vector integers numeric values, converts sequential runs range keeping non-sequential values -. example, c(1, 5, 6, 7, 8, 9, 15, 16, 20) becomes \"1,5-9,15-16,20\". reduces number characters necessary supply SQL condition. function mainly use developers.","code":""},{"path":"/reference/seqToSQL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a numeric series into an SQL value call — seqToSQL","text":"","code":"seqToSQL(x, maxChar = 29900, sort = TRUE)"},{"path":"/reference/seqToSQL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format a numeric series into an SQL value call — seqToSQL","text":"x vector numerical values. vector sorted  lowers highest efficient \"compression\" sequential ranges. Values coerced class integer. maxChar Integer numeric: Maximum number characters include output. output number characters, remainder dropped, trim attribute output set TRUE. default 29900, maximum length SQL statement GRASS seems able handle (minus safety margin). sort Logical: TRUE (default), sort x converting SQL. can reduce length output.","code":""},{"path":"/reference/seqToSQL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format a numeric series into an SQL value call — seqToSQL","text":"character string. string three attributes. trim attribute TRUE FALSE, depending whether maxChar reached (subsequent numbers dropped string). lastIndex attribute last index x processed (.e., index last value output), number values represented output.","code":""},{"path":"/reference/seqToSQL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format a numeric series into an SQL value call — seqToSQL","text":"","code":"x <- 1:5 seqToSQL(x) #> [1] \"1-5\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 5  x <- c(1:5, 7) seqToSQL(x) #> [1] \"1-5,7\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 6  x <- c(1:5, 7, 15:16) y <- c(1:5, 7, 15:16, 20) seqToSQL(x) #> [1] \"1-5,7,15-16\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 8 seqToSQL(y) #> [1] \"1-5,7,15-16,20\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 9  seqToSQL(x, maxChar = 5) #> [1] \"1-5,7\" #> attr(,\"trim\") #> [1] TRUE #> attr(,\"lastIndex\") #> [1] 6 seqToSQL(y, maxChar = 8) #> [1] \"1-5,7,15-16\" #> attr(,\"trim\") #> [1] TRUE #> attr(,\"lastIndex\") #> [1] 8  seqToSQL(10:1, sort = FALSE) #> [1] \"10,9,8,7,6,5,4,3,2,1\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 10 seqToSQL(10:1, sort = TRUE) #> [1] \"1-10\" #> attr(,\"trim\") #> [1] FALSE #> attr(,\"lastIndex\") #> [1] 10"},{"path":"/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Display a fasterRaster object — print.rastInfo","title":"Display a fasterRaster object — print.rastInfo","text":"Display GLocation, GSpatial, GRegion, GRaster, GVector object.","code":""},{"path":"/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display a fasterRaster object — print.rastInfo","text":"","code":"# S3 method for class 'rastInfo' print(x, ...)  show.rastInfo(x)  # S3 method for class 'vectInfo' print(x, ...)  # S3 method for class 'vectInfo' show(x)  # S4 method for class 'GLocation' show(object)  # S3 method for class 'GLocation' print(x, ...)  # S4 method for class 'GLocation' summary(object)  # S4 method for class 'GSpatial' show(object)  # S3 method for class 'GSpatial' print(x, ...)  # S4 method for class 'GSpatial' summary(object)  # S4 method for class 'GRegion' show(object)  # S3 method for class 'GRegion' print(x, ...)  # S4 method for class 'GRegion' summary(object)  # S4 method for class 'GRaster' show(object)  # S3 method for class 'GRaster' print(x, ...)  # S4 method for class 'GRaster' summary(object)  # S4 method for class 'GVector' show(object)  # S3 method for class 'GVector' print(x, ...)  # S4 method for class 'GVector' summary(object)"},{"path":"/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display a fasterRaster object — print.rastInfo","text":"... arguments. object, x object class GLocation, GSpatial, GRegion, GRaster, GVector.","code":""},{"path":"/reference/show.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display a fasterRaster object — print.rastInfo","text":"Nothing (side effect display metadata given object).","code":""},{"path":"/reference/show.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display a fasterRaster object — print.rastInfo","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/simplifyGeom.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify the geometry of a vector — simplifyGeom,GVector-method","title":"Simplify the geometry of a vector — simplifyGeom,GVector-method","text":"simplifyGeom() reduces number vertices used represent vector (.e., save memory disk space). several methods available.","code":""},{"path":"/reference/simplifyGeom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify the geometry of a vector — simplifyGeom,GVector-method","text":"","code":"# S4 method for class 'GVector' simplifyGeom(x, tolerance = NULL, method = \"VR\", prop = 0.5)"},{"path":"/reference/simplifyGeom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify the geometry of a vector — simplifyGeom,GVector-method","text":"x GVector. tolerance Numeric >= 0: Threshold distance map units (degrees unprojected, usually meters projected). NULL, 2% minimum x-, y-, z-extent used. method Character: Method used reduce number vertices. Partial matching used, case matter: \"VR\": Vertex reduction (default, simplest): two points p1 p2 line closer threshold, remove p2. tolerance argument represents threshold distance. \"DP\": Douglas-Peucker (AKA Ramer-Douglas-Peucker) algorithm: Simply stated, points p1, p2, p3 line, method constructs line segment p1 p3. p2 closer threshold line segment, removed. example, tolerance argument refers maximum distance p2 line segment. \"DPR\": Douglas-Peucker algorithm reduction: Douglas-Pueker method, geometry thinned end given proportion starting number points. prop argument refers proportion remaining points. \"RW: Reumann-Witkam algorithm: points p1, p2, p3, p4 line, constructs two line segments parallel line segment defined p1 p4. placed tolerance distance one either side p1-p4 line segment. line segment p1-p2 p3-p4 falls entirely within bounds two outer parallel segments, p2 p3 removed, leaving just p1 p4. prop Positive value 0 1: Proportion points retained geometry Douglas-Peucker algorithm reduction applied (ignored otherwise). Default 0.5 (retain 50% vertices).","code":""},{"path":"/reference/simplifyGeom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify the geometry of a vector — simplifyGeom,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/simplifyGeom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify the geometry of a vector — simplifyGeom,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers) soam <- rivers[rivers$NAM == \"SOAMIANINA\"] # select one river for illustration  ### Simplify geometry (remove nodes) ####################################  vr <- simplifyGeom(soam, tolerance = 2000) dp <- simplifyGeom(soam, tolerance = 2000, method = \"dp\") dpr <- simplifyGeom(soam, tolerance = 2000, method = \"dpr\", prop = 0.5) rw <- simplifyGeom(soam, tolerance = 2000, method = \"rw\")  plot(soam, col = \"black\", lwd = 3) plot(vr, col = \"blue\", add = TRUE) plot(dp, col = \"red\", add = TRUE) plot(dpr, col = \"chartreuse\", add = TRUE) plot(rw, col = \"orange\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Vertex reduction\",       \"Douglas-Peucker\",       \"Douglas-Peucker reduction\",       \"Reumann-Witkam\"   ),   col = c(\"black\", \"blue\", \"red\", \"chartreuse\", \"orange\"),   lwd = c(3, 1, 1, 1, 1) )  ### Smooth geometry ###################  hermite <- smoothGeom(soam, dist = 2000, angle = 3) chaiken <- smoothGeom(soam, method = \"Chaiken\", dist = 2000)  plot(soam, col = \"black\", lwd = 2) plot(hermite, col = \"blue\", add = TRUE) plot(chaiken, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Hermite\",       \"Chaiken\"   ),   col = c(\"black\", \"blue\", \"red\"),   lwd = c(2, 1, 1, 1, 1) )  ### Clean geometry ##################  # Has no effect on this vector! noDangs <- removeDangles(soam, tolerance = 10000)  plot(soam, col = \"black\", lwd = 2) plot(noDangs, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"No dangles\"   ),   lwd = c(2, 1),   col = c(\"black\", \"red\") )  }"},{"path":"/reference/sineRast.html","id":null,"dir":"Reference","previous_headings":"","what":"Sine wave rasters — sineRast,GRaster-method","title":"Sine wave rasters — sineRast,GRaster-method","text":"function creates one rasters sine waves north-south east-west directions.","code":""},{"path":"/reference/sineRast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sine wave rasters — sineRast,GRaster-method","text":"","code":"# S4 method for class 'GRaster' sineRast(   x,   ns = 1,   ew = 1,   nsOffset = 0,   ewOffset = 0,   nsAmp = 1,   ewAmp = 1,   combos = FALSE,   mask = NULL,   verbose = FALSE )"},{"path":"/reference/sineRast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sine wave rasters — sineRast,GRaster-method","text":"x GRaster. ns, ew Numeric: Number complete sine waves (.e., wavelengths) north-south east-west directions. wavelength 1 creates \"full\" sine wave (e.g., starting 0 one end ending 0 ). wavelength 2 create two waves, . value 0 creates waves given direction (.e., row column constant values). default value 1. nsOffset, ewOffset Numeric: Offset sine waves edges raster, expressed proportion length raster. default 0, values outermost cells close 0 (exactly 0 centers cells raster edges actual edge). offset value 0.2, example, pushed \"inward\" toward middle raster 20% raster's extent. nsAmp, ewAmp Numeric: Amplitude (minimum maximum sine wave) north-south east-west directions. default 1. Note north-south east-west waves created (.e., ns ew > 0), effective amplitude halved sum equal nsAmp + ewAmp. combos Logical: TRUE (default), create sine rasters using possible combinations values ns, ew, nsOffset, ewOffset, amp. FALSE, can supply either one value per parameter, number values per parameter. latter case, one raster created per pairwise set unique parameters. example, specify 3 values ns either one three values parameters, three rasters created. mask Either NULL (default), GRaster GVector: Used mask output. GVector, cells NA mask values. GVector, cells overlap vector values assigned. values NA. verbose Logical: TRUE, display progress.","code":""},{"path":"/reference/sineRast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sine wave rasters — sineRast,GRaster-method","text":"GRaster.","code":""},{"path":"/reference/sineRast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sine wave rasters — sineRast,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert to GRaster: elev <- fast(madElev)  ### Simple sine waves: waves <- sineRast(elev, ns = 2, ew = 1) plot(waves)  ### Sine waves with different amplitudes: amps <- sineRast(elev, nsAmp = c(1, 5), ewAmp = c(1, 5)) amps  ### Sine waves with and without north-south offset: noOffsets <- sineRast(elev, ns = 1, ew = 1) offsets <- sineRast(elev, ns = 1, ew = 1, nsOffset = 0.25) offs <- c(noOffsets, offsets) names(offs) <- c(\"no offset\", \"offset\") plot(offs)  ### Masking: madCoast4 <- fastData(\"madCoast4\") coast4 <- fast(madCoast4, verbose = FALSE)  masked <- sineRast(elev, mask = coast4) plot(masked)  ### Multiple sine waves (multiple rasters): mults <- sineRast(elev, ns = 1:2, ew = 1:2) combos <- sineRast(elev, ns = 1:2, ew = 1:2, combos = TRUE) plot(mults) plot(combos)  }"},{"path":"/reference/smoothGeom.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth the geometry of a vector — smoothGeom,GVector-method","title":"Smooth the geometry of a vector — smoothGeom,GVector-method","text":"smoothGeom() makes line segments vector appear less angular.","code":""},{"path":"/reference/smoothGeom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth the geometry of a vector — smoothGeom,GVector-method","text":"","code":"# S4 method for class 'GVector' smoothGeom(x, method = \"Hermite\", dist = NULL, angle = 3)"},{"path":"/reference/smoothGeom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth the geometry of a vector — smoothGeom,GVector-method","text":"x GVector. method Character: Method used smooth line segments. Partial matching used, case matter: \"Hermite\": Hermite interpolation (default): Guarantees output vector always passes original points. method adds points (possibly many) constructing cubic splines points approximately dist apart. number points can reduced specifying smaller value angle, specifies minimum angle two successive line segments. \"Chaiken\": Chaiken's algorithm: Guarantees new vector always touches midpoint original line segment. points new line least dist apart. dist Numeric > 0 NULL (default): Minimum distance (see method). Units map units. NULL, 2% minimum x-, y-, z-extent used. angle Numeric > 0: Maximum angle Hermite algorithm. Default 3.","code":""},{"path":"/reference/smoothGeom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooth the geometry of a vector — smoothGeom,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/smoothGeom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooth the geometry of a vector — smoothGeom,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers) soam <- rivers[rivers$NAM == \"SOAMIANINA\"] # select one river for illustration  ### Simplify geometry (remove nodes) ####################################  vr <- simplifyGeom(soam, tolerance = 2000) dp <- simplifyGeom(soam, tolerance = 2000, method = \"dp\") dpr <- simplifyGeom(soam, tolerance = 2000, method = \"dpr\", prop = 0.5) rw <- simplifyGeom(soam, tolerance = 2000, method = \"rw\")  plot(soam, col = \"black\", lwd = 3) plot(vr, col = \"blue\", add = TRUE) plot(dp, col = \"red\", add = TRUE) plot(dpr, col = \"chartreuse\", add = TRUE) plot(rw, col = \"orange\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Vertex reduction\",       \"Douglas-Peucker\",       \"Douglas-Peucker reduction\",       \"Reumann-Witkam\"   ),   col = c(\"black\", \"blue\", \"red\", \"chartreuse\", \"orange\"),   lwd = c(3, 1, 1, 1, 1) )  ### Smooth geometry ###################  hermite <- smoothGeom(soam, dist = 2000, angle = 3) chaiken <- smoothGeom(soam, method = \"Chaiken\", dist = 2000)  plot(soam, col = \"black\", lwd = 2) plot(hermite, col = \"blue\", add = TRUE) plot(chaiken, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"Hermite\",       \"Chaiken\"   ),   col = c(\"black\", \"blue\", \"red\"),   lwd = c(2, 1, 1, 1, 1) )  ### Clean geometry ##################  # Has no effect on this vector! noDangs <- removeDangles(soam, tolerance = 10000)  plot(soam, col = \"black\", lwd = 2) plot(noDangs, col = \"red\", add = TRUE)  legend(\"bottom\",    xpd = NA,    legend = c(     \"Original\",       \"No dangles\"   ),   lwd = c(2, 1),   col = c(\"black\", \"red\") )  }"},{"path":"/reference/sources.html","id":null,"dir":"Reference","previous_headings":"","what":"Name of a raster or vector in a GRASS session — sources,GRaster-method","title":"Name of a raster or vector in a GRASS session — sources,GRaster-method","text":"sources() retrieves name raster vector GRASS. GRasters GVectors actually pointers objects stored GRASS database. using fasterRaster functions rasters vectors, commands translated GRASS commands executed objects named pointers. objects use \"source\" (really filename) refer GRASS objects. function mostly use developers.","code":""},{"path":"/reference/sources.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name of a raster or vector in a GRASS session — sources,GRaster-method","text":"","code":"# S4 method for class 'GRaster' sources(x)  # S4 method for class 'GVector' sources(x)  # S4 method for class 'character' sources(x)"},{"path":"/reference/sources.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name of a raster or vector in a GRASS session — sources,GRaster-method","text":"x Either GSpatial object one inherits (.e., GRaster GVector), character. character, character returned.","code":""},{"path":"/reference/sources.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Name of a raster or vector in a GRASS session — sources,GRaster-method","text":"Character.","code":""},{"path":"/reference/sources.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Name of a raster or vector in a GRASS session — sources,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/spatSample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","title":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","text":"spatSample() randomly locates points across GRaster GVector. can return GVector, coordinates, values associated points, . want generate raster randomly-sampled cells, see sampleRast().","code":""},{"path":"/reference/spatSample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","text":"","code":"# S4 method for class 'GRaster' spatSample(   x,   size,   as.points = FALSE,   values = TRUE,   cats = TRUE,   xy = FALSE,   strata = NULL,   byStratum = FALSE,   zlim = NULL,   seed = NULL,   verbose = FALSE )  # S4 method for class 'GVector' spatSample(   x,   size,   as.points = FALSE,   values = TRUE,   xy = FALSE,   byStratum = FALSE,   zlim = NULL,   seed = NULL )"},{"path":"/reference/spatSample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","text":"x GRaster GVector. size Numeric value > 0: Number points create. .points Logical: FALSE (default), output data.frame data.table. TRUE, output \"points\" GVector. values Logical: TRUE (default), values GRaster points returned. cats Logical: TRUE (default) GRaster categorical, return category label cell. values also TRUE, cell value also returned. xy Logical: TRUE, return longitude latitude point. Default FALSE. strata Either NULL (default), GVector defining strata. supplied, size argument interpreted number points place per geometry strata. Note using strata can dramatically slow process. byStratum Logical: FALSE (default), size number points placed within entire area delineated strata. TRUE, size points placed within subgeometry strata. zlim Either NULL (default), vector two numbers defining lower upper altitudinal bounds coordinates. combined values = TRUE cats = TRUE. seed Either NULL (default) integer: Random number seed. NULL, seed set randomly. Values rounded nearest integer. verbose Logical: TRUE, display progress. Default FALSE.","code":""},{"path":"/reference/spatSample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","text":"data.frame, data.table, GVector.","code":""},{"path":[]},{"path":"/reference/spatSample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample random points from a GRaster or GVector — spatSample,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") # raster  # Convert to GRasters and GVectors elev <- fast(madElev)  ### spatSample() ################  # Random points as data.frame or data.table: randVals <- spatSample(elev, size = 20, values = TRUE) randVals  # Random points as a points GVector: randPoints <- spatSample(elev, size = 20, as.points = TRUE) randPoints plot(elev) plot(randPoints, add = TRUE)  # Random points in a select area: madCoast <- fastData(\"madCoast4\") # vector coast <- fast(madCoast) ant <- coast[coast$NAME_4 == \"Antanambe\"] # subset  restrictedPoints <- spatSample(elev, size = 20, as.points = TRUE,    strata = ant)  plot(elev) plot(ant, add = TRUE) plot(restrictedPoints, add = TRUE) # note 20 points for entire geometry  # Random points, one set per subgeometry: stratifiedPoints <- spatSample(elev, size = 20, as.points = TRUE,    strata = ant, byStratum = TRUE)  plot(elev) plot(ant, add = TRUE) plot(stratifiedPoints, pch = 21, bg = \"red\", add = TRUE) # note 20 points per subgeometry  # Random categories: madCover <- fastData(\"madCover\") # raster cover <- fast(madCover)  randCover <- spatSample(cover, size = 20, values = TRUE,      cat = TRUE, xy = TRUE) randCover  ### sampleRast() ################  # Random cells in non-NA cells: rand <- sampleRast(elev, 10000) plot(rand) nonnacell(rand)  # Use custom values for the mask: randCustomMask <- sampleRast(elev, 10000, maskvalues = 1:20) plot(randCustomMask)  # Force selected values to a custom value: randCustomUpdate <- sampleRast(elev, 10000, updatevalue = 7) plot(randCustomUpdate)  # Custom values for mask and set selected cells to custom value: randAll <- sampleRast(elev, 10000, maskvalues = 1:20, updatevalue = 7) plot(randAll)  }"},{"path":"/reference/streams.html","id":null,"dir":"Reference","previous_headings":"","what":"Create stream network — streams,GRaster-method","title":"Create stream network — streams,GRaster-method","text":"function estimates course streams rivers elevation raster. based GRASS module \\href{https://grass.osgeo.org/grass84/manuals/r.stream.extract.html}{r.stream.extract}, details can found.","code":""},{"path":"/reference/streams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create stream network — streams,GRaster-method","text":"","code":"# S4 method for class 'GRaster' streams(   x,   accumulation = NULL,   depression = NULL,   flowThreshold = 1,   dirThreshold = 1,   montgomery = 0,   minLength = 1 )"},{"path":"/reference/streams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create stream network — streams,GRaster-method","text":"x GRaster representing elevation. accumulation Either NULL (default) raster representing flow accumulation. supplied, accumulation created internally. can generate accumulation raster using flow(). depression Either NULL (default) GRaster representing depressions (areas streams flow ). flowThreshold Numeric > 0: Minimum threshold stream generated. default 1, necessarily reasonable value. dirThreshold Numeric (default Inf): flow exceeds threshold, direction estimated using single-flow direction algorithm. threshold, multi-direction flow model used. d8cut parameter r.stream.extract, used accumulation NULL.  default 1, necessarily reasonable value. montgomery Numeric: \"Montgomery\" exponent slope, multiplied accumulation per accumulation * slope^montgomery. value compared threshold determine sufficient. default 0 (.e., slope scaling). minLength Numeric: First-order streams less length removed (units cells). Default 0 (removal).","code":""},{"path":"/reference/streams.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create stream network — streams,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/streams.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create stream network — streams,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  # Calculate stream channels streams <- streams(elev) plot(streams)  }"},{"path":"/reference/stretch.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale values in a raster — stretch,GRaster-method","title":"Rescale values in a raster — stretch,GRaster-method","text":"stretch() rescales values GRaster. values can rescaled, just values user-defined range. range can given specifying either lower upper bounds range using smin smax, /quantiles (across cells raster) using minq maxq.","code":""},{"path":"/reference/stretch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale values in a raster — stretch,GRaster-method","text":"","code":"# S4 method for class 'GRaster' stretch(x, minv = 0, maxv = 255, minq = 0, maxq = 1, smin = NA, smax = NA)"},{"path":"/reference/stretch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rescale values in a raster — stretch,GRaster-method","text":"x GRaster. minv, maxv Numeric: Minimum maximum values rescale values. minq, maxq Numeric: Specifies range values rescale, given quantiles. default stretch values (0th 100th quantiles). One  ignored smin /smax provided. smin, smax Numeric NA: Specifies range values rescale. NA (default), values rescaled.","code":""},{"path":"/reference/stretch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rescale values in a raster — stretch,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/stretch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rescale values in a raster — stretch,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  ### Stretch based on user-defined range #######################################  #  fasterRaster fr <- stretch(elev, smin=1, smax=100) fr  # terra tr <- stretch(madElev, smin = 1, smax = 100) tr  # Compare fasterRaster to terra output fr <- rast(fr) fr <- extend(fr, tr) fr - tr  ### Stretch values in a certain quantile range ##############################################  #  fasterRaster fr <- stretch(elev, minq = 0.25, maxq = 0.75) fr  # terra tr <- stretch(madElev, minq = 0.25, maxq = 0.75) tr  # Compare fasterRaster to terra output fr <- rast(fr) fr <- extend(fr, tr) fr - tr  }"},{"path":"/reference/subset_dollar.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset a GRaster layer, or return values from a column of a GVector's table — $","title":"Subset a GRaster layer, or return values from a column of a GVector's table — $","text":"dollar notation can used get single layer multi-layer GRaster values column GVector's data table.","code":""},{"path":"/reference/subset_dollar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset a GRaster layer, or return values from a column of a GVector's table — $","text":"","code":"# S4 method for class 'GRaster' x$name  # S4 method for class 'GVector' x$name"},{"path":"/reference/subset_dollar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset a GRaster layer, or return values from a column of a GVector's table — $","text":"x GRaster GVector. name Character: name GRaster column GVector's data table. Names rasters vectors can found using names().","code":""},{"path":"/reference/subset_dollar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset a GRaster layer, or return values from a column of a GVector's table — $","text":"GRaster vector type GVector's column.","code":""},{"path":[]},{"path":"/reference/subset_dollar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset a GRaster layer, or return values from a column of a GVector's table — $","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/subset_double_square_brackets.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset layers from a GRaster, or specific columns from a GVector — [[","title":"Subset layers from a GRaster, or specific columns from a GVector — [[","text":"[[ operator can used subset remove one layers GRaster. can also used subset remove columns GVector data table.","code":""},{"path":"/reference/subset_double_square_brackets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset layers from a GRaster, or specific columns from a GVector — [[","text":"","code":"# S4 method for class 'GRaster,ANY,ANY' x[[i, j]]  # S4 method for class 'GVector,ANY,ANY' x[[i, j]]"},{"path":"/reference/subset_double_square_brackets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset layers from a GRaster, or specific columns from a GVector — [[","text":"x GRaster GVector. Numeric integer, integer, logical, character: Indicates layer(s) GRaster subset, column(s) GVector return. negative numeric integer values supplied, layers columns removed output. j Ignored [[.","code":""},{"path":"/reference/subset_double_square_brackets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset layers from a GRaster, or specific columns from a GVector — [[","text":"GRaster GVector.","code":""},{"path":"/reference/subset_double_square_brackets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset layers from a GRaster, or specific columns from a GVector — [[","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/subset_single_bracket.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset geometries of a GVector — [","title":"Subset geometries of a GVector — [","text":"[ operator returns subset remove specific geometries GVector. can get number geometries using ngeom(). Note use function change \"order\" geometries associated records data table appear. example, vector[1:3] vector[3:1] yield exact results. Note subsetting can take long time retaining small number geometries vector many geometries. routine selects geometries removing . can write code remove fewer geometries (.e., \"inverse\" selection), may go faster.","code":""},{"path":"/reference/subset_single_bracket.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset geometries of a GVector — [","text":"","code":"# S4 method for class 'GVector,ANY,ANY' x[i, j]  # S4 method for class 'GRaster,GRaster,ANY' x[i, j]"},{"path":"/reference/subset_single_bracket.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset geometries of a GVector — [","text":"x GVector. Numeric integer, integer, logical vector: Indicates geometry(ies) obtain. Negative numeric integer values remove given geometries output. logical vector supplied length number geometries, recycled. j Numeric integer, integer, logical, character: Indices name(s) column(s) obtain. can see column names using names(). Negative numeric integer values remove given columns output. logical vector supplied length number columns, recycled.","code":""},{"path":"/reference/subset_single_bracket.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset geometries of a GVector — [","text":"GVector.","code":""},{"path":[]},{"path":"/reference/subset_single_bracket.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset geometries of a GVector — [","text":"","code":"if (grassStarted()) {  # Setup library(terra)  ### GRasters ############  # Example data madElev <- fastData(\"madElev\") # elevation raster madForest2000 <- fastData(\"madForest2000\") # forest raster madForest2014 <- fastData(\"madForest2014\") # forest raster  # Convert SpatRasters to GRasters elev <- fast(madElev) forest2000 <- fast(madForest2000) forest2014 <- fast(madForest2014)  ### Re-assigning values of a GRaster constant <- elev constant[] <- pi names(constant) <- \"pi_raster\" constant  ### Re-assigning specific values of a raster replace <- elev replace[replace == 1] <- -20 replace  ### Subsetting specific values of a raster based on another raster elevInForest <- elev[forest2000 == 1] plot(c(elev, forest2000, elevInForest), nr = 1)  ### Adding and replacing layers of a GRaster rasts <- c(elev, constant, forest2000)  # Combine with another layer: add(rasts) <- forest2014 # one way rasts  rasts <- c(rasts, forest2014) # another way  ### Subsetting GRaster layers  # Subset: rasts[[2:3]] rasts[[c(\"madForest2000\", \"madElev\")]] rasts$madForest2000  # Get every other layer: rasts[[c(FALSE, TRUE)]]  ### Replacing layers of a GRaster  # Replace a layer logElev <- log(elev) names(logElev) <- \"logElev\" rasts$madForest2014 <- logElev rasts  # Replace a layer: rasts[[3]] <- forest2000 rasts  ### GVectors ############  # example data madDypsis <- fastData(\"madDypsis\") # vector of points  # Convert SpatVector to GVector dypsis <- fast(madDypsis)  ### Retrieving GVector columns  dypsis$species # Returns the column  dypsis[[c(\"year\", \"species\")]] # Returns a GRaster with these columns dypsis[ , c(\"year\", \"species\")] # Same as above  ### Subsetting GVector geometries  # Subset first three geometries dypsis[1:3] dypsis[1:3, \"species\"]  # Get geometries by data table condition dypsis[dypsis$species == \"Dypsis betsimisarakae\"]  ### (Re)assigning GVector column values  # New column dypsis$pi <- pi  # Re-assign values dypsis$pi <- \"pie\"  # Re-assign specific values dypsis$institutionCode[dypsis$institutionCode == \"MO\"] <-    \"Missouri Botanical Garden\"  }"},{"path":"/reference/subst.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace a specific value(s) in a GRaster — subst,GRaster-method","title":"Replace a specific value(s) in a GRaster — subst,GRaster-method","text":"function replaces one user-specified values raster values. See classify() replacing ranges values.","code":""},{"path":"/reference/subst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace a specific value(s) in a GRaster — subst,GRaster-method","text":"","code":"# S4 method for class 'GRaster' subst(x, from, to, others = NULL, warn = TRUE)"},{"path":"/reference/subst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace a specific value(s) in a GRaster — subst,GRaster-method","text":"x GRaster. , Vectors numeric character values. value(s) replaced value(s) . must length, , supply single value , values converted value . Numeric/integer character vectors can used: numeric integer vectors: Values replaced corresponding value . character vectors: can use character vector . case, input raster must factor (categorical) raster integer raster. character vector, levels(catagories) replaced levels . can add levels GRaster labels match existing labels . character vector integer vector: Cells x correspond given label values replaced corresponding value , matched corresponding label. label corresponds new value, new level created. input must categorical raster. integer vector character vector: Cells x value replaced values match labels . input raster value corresponds given label y, new value created. others NULL (default), NA, numeric, character: NULL (default): Values appear unchanged. NA: Values appear set NA. Character: Cells x appear assigned level. case, x must categorical (factor) raster. warn Logical: TRUE (default), display warning new levels created.","code":""},{"path":"/reference/subst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace a specific value(s) in a GRaster — subst,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/subst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace a specific value(s) in a GRaster — subst,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madCover <- fastData(\"madCover\")  ### Substitution within an integer/numeric raster #################################################  # Simple substitution of one value, keeping all other values newElev <- elev newElev[newElev == 100] <- -100 newElev[newElev > 500] <- 500 hist(newElev)  # Simple substitution of one value, keeping all other values substituted <- subst(elev, from = 300, to = -300) substituteds <- c(elev, substituted) names(substituteds) <- c(\"original\", \"substituted\") plot(substituteds)  # Simple substitution of three values, keeping all other values substituted <- subst(elev, from = c(299, 300, 301), to = c(-699, -600, -601)) substituteds <- c(elev, substituted) names(substituteds) <- c(\"original\", \"substituted\") plot(substituteds)  # Simple substitution of three values to one other value, retaining remainder substituted <- subst(elev, from = c(299, 300, 301), to = -1000) substituteds <- c(elev, substituted) names(substituteds) <- c(\"original\", \"substituted\") plot(substituteds)  # Simple substitution of one value, setting all other values to 100 substituted <- subst(elev, from = 300, to = -300, others = 100) substituteds <- c(elev, substituted) names(substituteds) <- c(\"original\", \"substituted\") plot(substituteds)  ### Substitution within a factor/categorical raster ###################################################  # Convert a SpatRaster to a GRaster: cover <- fast(madCover)  cover <- droplevels(cover) # remove unused levels levels(cover) # levels of \"cover\"  # Substitute using level name, replace with EXISTING level label from <- \"Mosaic cropland/vegetation\" to <- \"Mosaic crops\" categ <- subst(cover, from = from, to = to) freq(cover) # original frequencies of each land cover class freq(categ) # note change in frequency of \"from\" and \"to\" categories plot(c(cover, categ))  # Substitute using level name, replace with NEW level label from <- c(\"Mosaic crops\", \"Mosaic cropland/vegetation\") to <- c(\"Mixed cropland\") categ <- subst(cover, from = from, to = to) freq(cover) # original frequencies of each land cover class freq(categ) # note change in frequency of \"from\" and \"to\" categories plot(c(cover, categ))  # Substitute using level name, replace with NEW level label from <- c(\"Mosaic crops\", \"Mosaic cropland/vegetation\") to <- c(\"Mixed cropland\", \"Mixed cropland/vegetation\") categ <- subst(cover, from = from, to = to) freq(cover) # original frequencies of each land cover class freq(categ) # note change in frequency of \"from\" and \"to\" categories plot(c(cover, categ))  # Substitute using level name, replace with VALUE of an existing label from <- c(\"Mosaic crops\", \"Mosaic cropland/vegetation\") to <- 120 categ <- subst(cover, from = from, to = to) freq(cover) # original frequencies of each land cover class freq(categ) # note change in frequency of \"from\" and \"to\" categories plot(c(cover, categ))  # Substitute using level name, replace with new level name, replace all others from <- c(\"Mosaic crops\", \"Mosaic cropland/vegetation\") to <- \"Crops\" categ <- subst(cover, from = from, to = to, others = \"Other\") freq(cover) # original frequencies of each land cover class freq(categ) # note change in frequency of \"from\" and \"to\" categories plot(c(cover, categ))  }"},{"path":"/reference/sun.html","id":null,"dir":"Reference","previous_headings":"","what":"Solar radiance and irradiance — sun","title":"Solar radiance and irradiance — sun","text":"sun() function calculates beam (direct), diffuse ground reflected solar irradiation given day set topographic atmospheric conditions. function relies GRASS module r.sun, contains detailed explanation.","code":""},{"path":"/reference/sun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solar radiance and irradiance — sun","text":"","code":"sun(   elevation,   coeff_bh,   coeff_dh,   slope,   aspect,   hh,   horizon_step = 90,   albedo = 0.2,   linke = 3,   day = 1,   step = 0.5,   declination = NULL,   solar_constant = 1367,   distance_step = 1,   npartitions = 1,   beam_rad = TRUE,   diff_rad = TRUE,   refl_rad = TRUE,   glob_rad = TRUE,   insol_time = TRUE,   lowMemory = FALSE )"},{"path":"/reference/sun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solar radiance and irradiance — sun","text":"elevation GRaster values representing elevation (typically meters). coeff_bh GRaster: raster values real-sky beam radiation coefficient. Valid values 0 1. coeff_dh GRaster: raster values real-sky diffuse radiation coefficient. Valid values 0 1. slope GRaster: raster representing topographic slope radians. can generated using terrain(). aspect GRaster: raster representing topographic aspect degrees. can generated using terrain(). generated function, \"east orientation\" must used (.e., argument northIs0 must FALSE). hh \"stack\" GRasters: represents height horizon radians particular directions. Horizon height can calculated using horizonHeight(). directions must \"east orientation\" (.e., argument northIs0 horzionHeight() must FALSE). directions must correspond sequence given horizon_step (see next argument). example, horizon_step 90, hh must contain rasters representing horizon height 0 (east), 90 (north), 180 (west), 270 (south) aspects. #' horizon_step Numeric >0: Difference angular steps horizon height measured. One horizon height raster made per value 0 360 - horizon_step degrees. albedo GRaster numeric value: either raster values ground albedo numeric value (case albedo assumed everywhere). Albedo unit-less, default value 0.2. linke GRaster numeric value: either raster values Linke atmospheric turbidity coefficient numeric value (case value assumed locations). Linke coefficient unit-less. default value 3, see also GRASS manual page module r.sun. day Positive integer 1 365, inclusive: Day year calculate ir/radiation. Default 1 (January 1st). step Positive integer 0 24, inclusive. Time step hours -day radiation sums. Decimal values OK. declination Numeric NULL (default). Declination value. NULL, calculated automatically. solar_constant Positive numeric: solar constant (solar energy hitting top atmosphere). Default 1367. Units W / m^2. distance_step Positive numeric 0.5 1.5, inclusive: Sampling distance coefficient. Default 1. npartitions Positive numeric. Number chunks read input files. Default 1. beam_rad Logical: TRUE (default), generate raster beam irradiation units Wh / m^2 / day (\"mode 2\" r.sun GRASS module). diff_rad Logical: TRUE (default), generate raster representing irradiation Wh / m^2 /day refl_rad Logical: TRUE (default), generate raster ground-reflected irradiation units Wh / m^2 / day (\"mode 2\" r.sun GRASS module). glob_rad Logical:. TRUE (default), generate raster total irradiance/irradiation units Wh / m^2 / day (\"mode 2\" r.sun GRASS module). insol_time Logical: TRUE (default), generate raster total insolation time hours (\"mode 2\" r.sun GRASS module). lowMemory Logical: TRUE, use low-memory version r.sun GRASS module. default FALSE.","code":""},{"path":"/reference/sun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solar radiance and irradiance — sun","text":"raster raster stack stack extent, resolution, coordinate reference system elevation. Assuming possible rasters generated represent: beam_rad: Beam radiation (Watt-hours/m2/day) diff_rad: Diffuse radiation (Watt-hours/m2/day) refl_rad: Reflected radiation (Watt-hours/m2/day) glob_rad: Global radiation (Watt-hours/m2/day) insol_time: Insolation duration (hours)","code":""},{"path":[]},{"path":"/reference/sun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solar radiance and irradiance — sun","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  ### Calculate input rasters ###########################  # Values below are just a guess coeff_bh <- coeff_dh <- elev coeff_bh[] <- 0.4 coeff_dh[] <- 0.6  slope <- terrain(elev, \"slope\") aspect <- terrain(elev, \"aspect\", northIs0 = FALSE)  horizon_step <- 90 hh <- horizonHeight(elev, step = horizon_step, northIs0 = FALSE)  ### calculate solar ir/radiance ###############################  solar <- sun(   elevation = elev,   coeff_bh = coeff_bh,   coeff_dh = coeff_dh,   slope = slope,   aspect = aspect,   hh = hh,   horizon_step = horizon_step,   albedo = 0.2,   linke = 1.5,   day = 1,   step = 0.5,   declination = NULL,   solar_constant = 1367,      distance_step = 1,   npartitions = 1,    beam_rad = TRUE,   diff_rad = TRUE,   refl_rad = TRUE,   glob_rad = TRUE,   insol_time = TRUE,    lowMemory = FALSE )  solar  }"},{"path":"/reference/terrain.html","id":null,"dir":"Reference","previous_headings":"","what":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","title":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","text":"terrain() calculates topographic indices, including slope, aspect, curvature, partial slopes (slopes east-west north-south directions).","code":""},{"path":"/reference/terrain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","text":"","code":"# S4 method for class 'GRaster' terrain(   x,   v = \"slope\",   units = \"degrees\",   undefinedAspect = NA,   northIs0 = TRUE )"},{"path":"/reference/terrain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","text":"x GRaster (typically representing elevation). v Name topographic metric(s) calculate. Valid values include one : \"slope\": Slope. Units given argument units. \"aspect\": Aspect. argument northIs0 TRUE (default), aspect given degrees north going clockwise (0 = north, 90 = east, 180 = south, 270 = west).  Units given argument units. \"profileCurve\": Profile curvature. \"tanCurve\": Tangential curvature. \"dx\": Slope east-west direction. \"dy\": Slope north-south direction. \"dxx\": Second partial derivative east-west direction. \"dyy\": Second partial derivative north-south direction. \"dxy\": Second partial derivative along east-west north-south direction. \"*\": . units Character: \"Units\" calculate slope aspect: either \"degrees\" degrees (default), \"radians\", \"percent\". Partial matching used. undefinedAspect Numeric NA (default): Value assign flat areas aspect calculated. northIs0 Logical: TRUE (default), aspect reported \"north orientation,\" 0 north, degrees run clockwise (90 east, 180 south, 270 west). FALSE, aspect reported \"east orientation,\" 0 east, degrees run counterclockwise (90 north, 180 west, 270 south). latter default GRASS, former default terra::terrain() function, used default. Note: sun() function requires aspect east orientation.","code":""},{"path":"/reference/terrain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","text":"GRaster one layers.","code":""},{"path":[]},{"path":"/reference/terrain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slope, aspect, curvature, and partial slopes — terrain,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster elev <- fast(madElev)  # Calculate all topographic metrics topos <- terrain(elev, v = \"*\") topos  plot(topos) # NB Aspect has values of NA when it cannot be defined  # Calculate a hillshade raster hs <- hillshade(elev) plot(hs)  }"},{"path":"/reference/thinLines.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","title":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","text":"thinLines() function attempts reduce linear features raster just 1 cell wide. may need run thinLines() multiple times raster (experiment iter argument) get acceptable output. thinLines() can helpful run raster using .lines().","code":""},{"path":"/reference/thinLines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","text":"","code":"# S4 method for class 'GRaster' thinLines(x, iter = 200)"},{"path":"/reference/thinLines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","text":"x GRaster. iter Numeric integer: Number iterations (default 200).","code":""},{"path":"/reference/thinLines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/thinLines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduce linear features on a raster so linear features are 1 cell wide — thinLines,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation madElev <- fastData(\"madElev\")  # Convert to GRaster: elev <- fast(madElev)  # Thin elevation raster. In this case, we need to run 300 thinning iterations # for the function to reduce the raster to linear features. thinned <- thinLines(elev, iter = 300) plot(thinned)  # Convert to lines: rastToLines <- as.lines(thinned) plot(rastToLines)  # We can clean this: cleanLines <- fixDangles(x = rastToLines) plot(rastToLines, col = \"red\") plot(cleanLines, add = TRUE)  }"},{"path":"/reference/thinPoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","title":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","text":"function thins \"points\" GVector n points per grid cell raster.","code":""},{"path":"/reference/thinPoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","text":"","code":"# S4 method for class 'GVector,GRaster' thinPoints(x, y, n = 1)"},{"path":"/reference/thinPoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","text":"x \"points\" GVector. y GRaster. n Integer numeric integer: Maximum number points remain cell. default 1.","code":""},{"path":"/reference/thinPoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","text":"\"points\" GVector.","code":""},{"path":"/reference/thinPoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reduce number of points in same raster cell — thinPoints,GVector,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation and points madElev <- fastData(\"madElev\") madDypsis <- fastData(\"madDypsis\")  # Convert to fasterRaster formats: elev <- fast(madElev) dypsis <- fast(madDypsis)  # Aggregate cells of the raster so they are bigger (otherwise, in this # example, we'd have no cells with > 1 point): elevAgg <- aggregate(elev, 32)  # Remove all but one or two points per cell thin1 <- thinPoints(dypsis, elevAgg, n = 1) thin2 <- thinPoints(dypsis, elevAgg, n = 2)  # Plot plot(elevAgg) plot(dypsis, add = TRUE) plot(thin2, col = \"yellow\", add = TRUE) plot(thin1, col = \"red\", add = TRUE) legend(    \"bottomright\",    legend = c(\"In original & thin 1 & 2\",      \"In just thin 1 & 2\", \"In just thin 1\"),    pch = 16,    col = c(\"black\", \"yellow\", \"red\"),    bg = \"white\",    xpd = NA )  }"},{"path":"/reference/tiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","title":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","text":"function divides raster \"tiles\" spatial subsets can used speeding raster calculations. Tiles can mutually exclusive overlap user-defined amount.","code":""},{"path":"/reference/tiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","text":"","code":"# S4 method for class 'GRaster' tiles(x, n, overlap = 0, verbose = FALSE)"},{"path":"/reference/tiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","text":"x GRaster. n Numeric vector: Number tiles create. can single number, case x divided n × n tiles, two values case divided n[1] × n[2] tiles (rows x columns). overlap Numeric vector (default 0): Number rows/columns expand size tiles overlap. can single value two values. just one provided, tiles expanded overlap rows overlaps columns. two numbers provided, tiles expanded overlap[1] rows overlap[2] columns. verbose Logical: TRUE, display progress. Default FALSE.","code":""},{"path":"/reference/tiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","text":"list one element per tile. lapply() sapply() functions can used apply functions tile list.","code":""},{"path":"/reference/tiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divide a GRaster into spatially exclusive subsets — tiles,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  # Create spatially exclusive tiles: exclusive <- tiles(elev, n = 2, verbose = TRUE)  startpar <- par(mfrow = c(2, 3)) plot(elev, main = \"Original\")  for (i in seq_along(exclusive)) {   plot(exclusive[[i]], ext = elev, main = paste(\"Tile\", i)) } par(startpar)  # Create tiles that overlap: overlaps <- tiles(elev, n = 2, overlap = 200, verbose = TRUE)  startpar <- par(mfrow = c(2, 3)) plot(elev, main = \"Original\")  for (i in seq_along(overlaps)) {   plot(overlaps[[i]], ext = elev, main = paste(\"Tile\", i)) } par(startpar)  }"},{"path":"/reference/topology-GSpatial-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","title":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","text":"GRasters GVectors can 2-dimensional 3-dimensional coordinates. function returns dimensions object.","code":""},{"path":"/reference/topology-GSpatial-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","text":"","code":"# S4 method for class 'GSpatial' topology(x)"},{"path":"/reference/topology-GSpatial-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","text":"x GSpatial object (.e., GRaster GVector).","code":""},{"path":"/reference/topology-GSpatial-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","text":"Either \"2D\" \"3D\".","code":""},{"path":[]},{"path":"/reference/topology-GSpatial-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Topology (2- or 3-dimensions) of a GRaster or GVector — topology,GSpatial-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","title":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","text":"function removes rows columns  GRaster NA. GRaster stack rasters, rasters trimmed extent none rows columns NA. words, least one raster stack non-NA cell row column, rasters retain row column.","code":""},{"path":"/reference/trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","text":"","code":"# S4 method for class 'GRaster' trim(x, pad = 0)"},{"path":"/reference/trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","text":"x GRaster. pad Numeric integer: Number NA rows columns retain. default 0.","code":""},{"path":"/reference/trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows and columns from a raster that are all NA — trim,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert SpatRaster to a GRaster: elev <- fast(madElev)  # Trim NA rows/columns: trimmedElev <- trim(elev) dim(elev) dim(trimmedElev)  # Trim a \"stack\" of rasters. We will artificially add NA rows and columns to # one raster to demonstrate how the trim() function removes only rows/columns # that are NA for *all* rasters. elevNAs <- elev  fun <- \" = if(col() > ncols() - 200, null(), madElev)\" elevNAs <- app(elevNAs, fun)  # Notice raster is \"narrower\" because we added NA columns plot(elevNAs)  elevs <- c(elev, elevNAs) trimmedElevs <- trim(elevs) trimmedElevNAs <- trim(elevNAs)  dim(elevs) dim(trimmedElevNAs) dim(trimmedElevs)  }"},{"path":"/reference/tutorial_getting_started.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting started with ","title":"Getting started with ","text":"fasterRaster interfaces GRASS GIS process rasters spatial vector data. intended add-terra sf packages, relies heavily upon . rasters vectors small medium-sized memory/disk, packages almost always faster. may also faster large objects.  , fasterRaster can step .","code":""},{"path":"/reference/tutorial_getting_started.html","id":"installing-fasterraster","dir":"Reference","previous_headings":"","what":"Installing fasterRaster","title":"Getting started with ","text":"probably already fasterRaster installed computer, , can install latest release version CRAN using:   latest development version using:   (may need install remotes package first.)","code":"install.packages(\"fasterRaster\") remotes::install_github(\"adamlilith/fasterRaster\", dependencies = TRUE)"},{"path":"/reference/tutorial_getting_started.html","id":"installing-grass-gis","dir":"Reference","previous_headings":"","what":"Installing GRASS GIS","title":"Getting started with ","text":"fasterRaster uses GRASS operations. need install GRASS using \"stand-alone\" installer, available GRASS GIS. sure use \"stand-alone\" installer, \"OSGeo4W\" installer!","code":""},{"path":"/reference/tutorial_getting_started.html","id":"starting-a-fasterraster-session","dir":"Reference","previous_headings":"","what":"Starting a fasterRaster session","title":"Getting started with ","text":"recommend attaching data.table, terra, sf packages attaching fasterRaster package avoid function conflicts. data.table package required, surely use least one two.   begin, need tell fasterRaster full file path folder GRASS installed system. well depend operating system version GRASS installed.  Three examples show might look like, may need change file path match case:   tell fasterRaster GRASS installed, use faster() function:   can also use faster() function set options affect fasterRaster functions run. includes setting amount maximum memory number computer cores allocated operations. fasterRaster, rasters called GRasters vectors called GVectors. easiest (always fastest) way start using GRaster GVector convert one already R. example , use raster comes fasterRaster package. raster represents elevation portion eastern Madagascar. first load SpatRaster using fastData(), helper function loading example data objects come fasterRaster package.   Now, conversion GRaster GVector using fast(). function can create GRaster GVector SpatRaster, SpatVector, sf vector, file representing raster vector.   Converting rasters vectors already R GRasters GVectors takes time. Instead, can load raster vector directly disk fasterRaster session using fast(). , just replace first argument fast() string representing folder path file name raster want load session. example, can :   Now, create GVector. fast() function can take SpatVector terra package, sf object sf package, string representing file path file name vector file (e.g., GeoPackage file shapefile).","code":"library(data.table) library(sf) library(terra) library(fasterRaster) grassDir <- \"C:/Program Files/GRASS GIS 8.3\" # Windows grassDir <- \"/Applications/GRASS-8.3.app/Contents/Resources\" # Mac OS grassDir <- \"/usr/local/grass\" # Linux faster(grassDir = grassDir) madElev <- fastData(\"madElev\") # example SpatRaster madElev elev <- fast(madElev) elev rastFile <- system.file(\"extdata\", \"madElev.tif\"), package = \"fasterRaster\") elev2 <- fast(rastFile) madRivers <- fastData(\"madRivers\") # sf vector madRivers  rivers <- fast(madRivers) rivers"},{"path":"/reference/tutorial_getting_started.html","id":"operations-on-grasters-and-gvectors","dir":"Reference","previous_headings":"","what":"Operations on GRasters and GVectors","title":"Getting started with ","text":"can operations objects just like SpatRasters, SpatVectors, sf objects. example, can use mathematical operators functions:   can also use many fasterRaster functions. general, functions names terra counterparts often arguments. Note even many terra fasterRaster functions name, necessarily produce exact output. Much care taken ensure , sometimes multiple ways task, choices made authors terra GRASS can lead differences. following code creates ) raster cell values reflect distance nearest river; b) creates buffer around rivers; c) plots output:   get started! Now raster vector fasterRaster \"location\", can start manipulations analyses using fasterRaster functions!  see annotated list functions, use ?fasterRaster.","code":"elev_feet <- elev * 3.28084 elev_feet  log10Elev <- log10(elev) log10Elev dist <- distance(elev, rivers) dist  riverBuff <- buffer(rivers, 10000) riversBuff  plot(dist) plot(rivers, col = 'blue', add = TRUE) plot(riversBuff, add = TRUE)"},{"path":"/reference/tutorial_getting_started.html","id":"converting-and-saving-grasters-and-gvectors","dir":"Reference","previous_headings":"","what":"Converting and saving GRasters and GVectors","title":"Getting started with ","text":"can convert GRaster SpatRaster raster using rast():   convert GVector terra package's SpatVector format sf vector, use vect() st_as_sf():   Finally, can use writeRaster() writeVector() save GRasters GVectors directly disk. always faster using rast(), vect(), st_as_sf() saving result functions.","code":"terraElev <- rast(elev) terraRivers <- vect(rivers) sfRivers <- st_as_sf(rivers) elevTempFile <- tempfile(fileext = \".tif\") # save as GeoTIFF writeRaster(elev, elevTempFile)  vectTempFile <- tempfile(fileext = \".shp\") # save as shapefile writeVector(rivers, vectTempFile)"},{"path":"/reference/tutorial_getting_started.html","id":"tips-for-masking-fasterraster-faster","dir":"Reference","previous_headings":"","what":"Tips for masking fasterRaster faster","title":"Getting started with ","text":"Loading rasters vectors directly disk using fast(), rather converting terra sf objects faster. ? object file R object points, fast() save disk first GeoTIFF GeoPackage file, load GRASS. Similarly, saving GRasters GVectors directly disk always faster converting SpatRasters SpatVectors using rast() vect(), saving . ? rast() vect() actually save object temporary file uses respective function respective package create SpatRaster/SpatVector/sf` vector, proceed save disk . Every time switch using GRaster GVector different coordinate reference system (CRS), GRASS spend second changing CRS. , can save time much work possible objects one CRS, switching work objects another CRS. default, GRASS/fasterRaster use 2 cores 2048 MB (2 GB) memory functions allow users specify values. can set higher values using faster() thus potentially speed calculations. Functions newer versions GRASS capacity use options, updating GRASS latest version can help, . obviate problems disk space filling , default fasterRaster functions delete intermediate files. However, creating lot big GRasters GVectors, can skip time-taking step setting clean option FALSE using faster(clean = FALSE). can also use mow() function remove disk cache GRASS files associated GRaster GVector memory. can helpful, say, create series objects, re-assign using, say old_name <- new_object remove using rm(old_name). removed R, files pointed still GRASS cache. name notwithstanding, fasterRaster just going fast terra sf operations, even objects big memory disk. struggling analyze object, can try respective functions packages.","code":""},{"path":"/reference/tutorial_getting_started.html","id":"further-reading","dir":"Reference","previous_headings":"","what":"Further reading","title":"Getting started with ","text":"Robert Hijman's terra package Edzer Pebesma's sf package good places start familiar GIS R. GRASS GIS website authoritative contains manual GRASS functions used package . Wiki run GRASS R R GRASS good place start want become power-user GRASS R. Roger Bivand's rgrass package allows users call GRASS function functionality, cases far beyond allowed fasterRaster.","code":""},{"path":"/reference/tutorial_hidden_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hidden functions in ","title":"Hidden functions in ","text":"fasterRaster contains set \"private\" functions users can access using fasterRaster:::functionName. functions useful power users developers. hidden functions listed . Often, method hidden function name starts period. \"period\" function intended supplied sources() name GRaster GVector functions calling function need spend time creating GRaster GVector pointer calling function. \"Period\" functions , though, often work GRasters GVectors, though error-checking region definitions conducted. .copyGSpatial(): Make copy GRASS file pointed GRaster GVector.fileExt(): Get file extension.exists(): GRASS file GRaster GVector exist?.ext(): Extent sources() name GRaster GVector.geomtype(): Geometry type (\"point\", \"line\", \"area\") sources() name GVector.layerIndex(): Gets index GRaster layers numeric, integer, character, logical vector.locationCreate() Make connection GRASS (.e., start GRASS within R) create location.locationDelete() Deletes files associated GRASS \"location\" mapset.locationFind(): Find specific GRASS \"location\" already exists.locationRestore() Reconnect GRASS previously-created GRASS \"location\".locations(): List available \"locations\".ls(): Lists sources objects active GRASS \"location\".makeGRaster() .makeGVector(): Make GRasters GVectors vector sources, pointers files GRASS.makeSourceNames(): Makes one statistically unique strings can used file names represent rasters vectors GRASS.mapset(): GRASS \"mapset\" object active session.message(): Display warning message given warning displayed since fasterRaster attached given number hours passed since .minVal() .maxVal(): Values @minVal @maxVal slots GRaster.nlevels(): Number levels SpatVector, data.frame, data.table, empty string, list data.frames, data.tables, /empty strings..plot(): Plot using sources() name GRaster GVector.projection(): Value @projection slot GRaster GVector.quiet(): Returns \"quiet\" faster(\"verbose\") TRUE.rastInfo() .vectInfo(): Metadata GRASS raster vector.region(): Change report active region's extent resolution.regionDim()]: Change report active region's resolution (also dim() related functions, arguments).regionExt(): Change report active region's extent (also ext() related functions, arguments).regionRes(): Change report active region's dimensions (also res() related functions, arguments).rename(): Rename GRASS raster vector.rm(): Delete rasters vectors GRASS.vAsDataTable(): Convert attribute table linked vector GRASS data.table. table distinct attribute table attached GVector.vAttachDatabase(): Add database table GRASS representation GVector.vCats(): Get data.table single column named cat, corresponds GRASS attribute table's cat column.vDetachDatabase(): Detach **GRASS** database **GRASS** vector\\cr .vHasDatabase(): Tests **GRASS** vector database\\cr .vIncrementCats(): Increment category values GVector\\cr .vNames(): \"**GRASS**\" vector attribute table column names\\cr .vRecat(): Change **GRASS** category indices **GRASS** vector\\cr .vValidCats()`: category values vector valid?","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":null,"dir":"Reference","previous_headings":"","what":"Locations/projects and mapsets — tutorial_locations_mapsets","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"GRASS GIS uses \"projects\" (previously called \"locations\") \"mapsets\" store files (rasters, vectors, etc.). fasterRaster uses , , invisibly users. Thus, tutorial mostly interest developers curious people.","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":"grass-locations-projects","dir":"Reference","previous_headings":"","what":"GRASS locations/projects","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"Starting GRASS Upon starting, GRASS creates (loads) location, corresponds folder user's system. Importantly, rasters vectors location must coordinate reference system (CRS). Confusingly, rasters vectors GRASS location necessarily represent place Earth. general, rasters vectors can interact one another location mapset.  GRASS can connection single location time. fasterRaster handles projects mapsets automatically, users typically need manage . Projects created -needed basis. Within given R session, projects made, calling fast() create GRaster GVector 1) make connection GRASS 2) create location CRS raster vector. raster vector stored location. fast() starts connection creates location using exported publicly undocumented function .locationCreate(). fast() called location already exists CRS raster vector, one two things happen. First, GRASS already connected location, raster vector simply imported. Second, GRASS connected location appropriate CRS, use .locationRestore() connect proper one, import raster vector. functions might also cause GRASS connect pre-existing location. Generally, function applied GRaster GVector, first check see GRASS connected location raster vector stored. , use .locationRestore() first. Creating new location switching connections pre-existing locations adds seconds processing time rasters vectors. avoid , users can work much possible sets rasters vectors CRS (.e., location).","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":"fasterraster-mapsets","dir":"Reference","previous_headings":"","what":"FasterRaster mapsets","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"GRAS \"mapsets\" sub-folders within location. Every location must mapset (thus, sub-folder) named \"PERMANENT\". Users Mapsets intended store sub-projects use rasters vectors CRS. Users GRASS can switch mapsets. However, ease--use development, fasterRaster always uses \"PERMANENT\" mapset within given location.","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":"functions-that-manage-locations-and-mapsets","dir":"Reference","previous_headings":"","what":"Functions that manage locations and mapsets","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"functions exported publicly documented. can, however, read documentation opening development file (.e., fasterRaster GitHub repository). functions take \"x\" argument. .location(x): Name location x (fasterRaster object), current location (x missing). .locations(): Names CRSs available locations (takes arguments). .locationCreate(x): Create location CRS x. .locationRestore(x): Connect pre-existing location. x can fasterRaster object, SpatRaster, SpatVector, sf object, name location. .locationFind(x, return = <option>): Given spatial object x, find name, index, CRS location matches . x missing, return list locations. <option> can \"name\" (name location), \"index\" (index), \"crs\" (coordinate reference string WKT format). .ls(): List file names rasters /vectors current location. .mapset(x): Name mapset contains object x.","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":"more-rabbit-holing","dir":"Reference","previous_headings":"","what":"More rabbit-holing","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"fasterRaster maintains package-specific environment named .fasterRaster, keeps list locations .fasterRaster$locations. named list locations, element name location, value element location's CRS. current location tracked .fasterRaster$activeLocation.","code":""},{"path":"/reference/tutorial_locations_mapsets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locations/projects and mapsets — tutorial_locations_mapsets","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/tutorial_raster_data_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Raster data types — tutorial_raster_data_types","title":"Raster data types — tutorial_raster_data_types","text":"fasterRaster GRasters can represent double-floating point numeric values, integers, categorical data.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"double-floating-point-values","dir":"Reference","previous_headings":"","what":"Double-floating point values","title":"Raster data types — tutorial_raster_data_types","text":"Double-floating point values accurate 15th 17th decimal place. called \"double\" rasters fasterRaster DCELL rasters GRASS. rasters typically take memory. \"numeric\" values R double-floating point values.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"floating-point-values","dir":"Reference","previous_headings":"","what":"Floating point values","title":"Raster data types — tutorial_raster_data_types","text":"Less common double-floating point rasters, floating point rasters accurate 7th decimal place. called \"float\" rasters fasterRaster FCELL rasters GRASS. rasters typically take less memory double-floating point rasters.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"integers","dir":"Reference","previous_headings":"","what":"Integers","title":"Raster data types — tutorial_raster_data_types","text":"Rasters represent integers called \"integer\" rasters fasterRaster CELL rasters GRASS. can force raster integer using .int(). functions app() function also return integer-type rasters. Integer rasters typically take least memory.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"categories","dir":"Reference","previous_headings":"","what":"Categories","title":"Raster data types — tutorial_raster_data_types","text":"Categorical rasters (also called \"factor\" rasters) actually integer rasters, associated attribute table maps integer value category label, \"wetland\" \"forest\". table least two columns. first integer values, (default) second category names. second column \"active\" category column used plotting functions. active column can changed using activeCat<-.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"functions-relevant-to-raster-data-types","dir":"Reference","previous_headings":"","what":"Functions relevant to raster data types","title":"Raster data types — tutorial_raster_data_types","text":"activeCat(), activeCats(), activeCat<- can used see assign column \"levels\" table associated categorical raster used category labels. addCats() adds information \"levels\" table using data.table::merge() (merge()). addCats<- add new levels \"levels\" table. .int(), .float(), .doub() coerce raster integer, float, double. catNames() reports column names \"levels\" table layer raster. cats() returns entire \"levels\" table categorical raster. combineCats() combines levels two categorical integer rasters. combineLevels(): Combine \"levels\" tables two categorical GRasters. complete.cases() finds rows levels table NAs. datatype() returns data type GRaster. droplevels() removes \"unused\" levels \"levels\" table. freq(): Frequency category across cells raster .factor() indicates raster categorical raster. .int(), .float(), .doub() indicate values raster integers, floating-point, double-floating point precision. levels() returns \"levels\" table categorical raster (just value column active column). levels<- categories() can used assign categories integer raster make categorical (.e., \"factor\" raster). match(), %%, %notin%: Find cells GRaster match match certain category labels missing.cases() finds rows levels table least one NA. missingCats() finds values categorical rasters category assigned . nlevels() returns number levels represented categorical raster. subst(): Re-assign category levels","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"saving-rasters-to-disk","dir":"Reference","previous_headings":"","what":"Saving rasters to disk","title":"Raster data types — tutorial_raster_data_types","text":"can potentially save substantial space disk setting datatype argument writeRaster() appropriate value saving raster. argument allows finer \"divisions\" just integer/float/double-float, depending range values raster, can optimize file size selecting one best matches values raster. See documentation writeRaster() information.","code":""},{"path":"/reference/tutorial_raster_data_types.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Raster data types — tutorial_raster_data_types","text":"","code":"if (grassStarted()) {  # Setup library(sf) library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCoast0 <- fastData(\"madCoast0\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  ### GRaster properties ######################  # convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  # plot plot(elev)  dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution  ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  topology(elev) # number of dimensions is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  minmax(elev) # min/max values  # name of object in GRASS sources(elev)  # \"names\" of the object names(elev)  # coordinate reference system crs(elev)  # extent (bounding box) ext(elev)  # data type datatype(elev)  # assigning copy <- elev copy[] <- pi # assign all cells to the value of pi copy  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # adding a raster \"in place\" add(rasts) <- ln(elev) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # assigning rasts[[4]] <- elev > 500  # number of layers nlyr(rasts)  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"forest\", \"ln_elev\", \"high_elevation\") rasts  ### GVector properties ######################  # convert sf vectors to GVectors coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # extent ext(rivers)  W(rivers) # western extent E(rivers) # eastern extent S(rivers) # southern extent N(rivers) # northern extent top(rivers) # top extent (NA for 2D rasters like this one) bottom(rivers) # bottom extent (NA for 2D rasters like this one)  # coordinate reference system crs(rivers) st_crs(rivers)  # column names and data types names(coast) datatype(coast)  # name of object in GRASS sources(rivers)  # points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # dimensions nrow(rivers) # how many spatial features ncol(rivers) # hay many columns in the data frame  # number of geometries and sub-geometries ngeom(coast) nsubgeom(coast)  # 2- or 3D topology(rivers) # dimensionality is.2d(elev) # is it 2D? is.3d(elev) # is it 3D?  # Update values from GRASS # (Reads values from GRASS... will not appear to do anything in this case) coast <- update(coast)  ### operations on GVectors ##########################  # convert to data frame as.data.frame(rivers) as.data.table(rivers)  # subsetting rivers[c(1:2, 5)] # select 3 rows/geometries rivers[-5:-11] # remove rows/geometries 5 through 11 rivers[ , 1] # column 1 rivers[ , \"NAM\"] # select column rivers[[\"NAM\"]] # select column rivers[1, 2:3] # row/geometry 1 and column 2 and 3 rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled) rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)  # removing data table noTable <- dropTable(rivers) noTable nrow(rivers) nrow(noTable)  # Refresh values from GRASS # (Reads values from GRASS... will not appear to do anything in this case # since the rivers object is up-to-date): rivers <- update(rivers)  # Concatenating multiple vectors rivers2 <- rbind(rivers, rivers) dim(rivers) dim(rivers2)  }"},{"path":"/reference/tutorial_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"An explanation of GRASS ","title":"An explanation of GRASS ","text":"GRASS region data structure like raster composed \"cells\", different cells contain values. Rather, resolution extent region influence rasters imported, created, processed, exported. cases, whenever raster undergoes one processes using GRASS module, raster resampled /crop/extend matches region\"s extent resolution. ignored, can cause unintended side effects region's geometry match raster processed. Generally, users fasterRaster need know regions work management handled automatically.  help page provided assist power users may wish use regions explicitly develop applications based fasterRaster. GRASS \"location\" typically one active region. extent resolution region initially set first raster imported .","code":""},{"path":"/reference/tutorial_regions.html","id":"functions-for-managing-regions-in-fasterraster","dir":"Reference","previous_headings":"","what":"Functions for managing regions in fasterRaster","title":"An explanation of GRASS ","text":"fasterRaster provides functions managing regions: `.region(): Extent dimensions/resolution region. function used many fasterRaster functions raster processing ensure raster changed (region). .regionDim(): Dimensions (number rows columns) .regionExt(): Extent .regionRes(): Resolution functions can used three different ways: arguments: function reports respective value(s) (e.g., regionExt() reports extent region). GRaster, GVector, SpatRaster, SpatVector, sf object: Resizes /resamples region extent /resolution spatial object. Note vector objects resolution, used .region*() functions resample region's resolution. numeric values (.e., representing extent, resolution, dimensions): Resize resample region dimensions. region's extent resized resolution changed, extended next-larger number rows /columns can accommodate cells desired size. Regions inherently 3-dimensional, often single depth (.e., one \"layer\" cells).","code":""},{"path":"/reference/tutorial_regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An explanation of GRASS ","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madRivers <- fastData(\"madRivers\")  # Report information on current region: dim3d() nrow() ncol() ndepth() ncell() ncell3d()  ext() W() E() S() N()  res() res3d() xres() yres() zres()   }"},{"path":"/reference/union.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine two GVectors — union,GVector,GVector-method","title":"Combine two GVectors — union,GVector,GVector-method","text":"union() function combines two \"polygons\" GVectors. output least many geometries GVectors, plus polygons one divide polygons , vice versa. can also use + operator (e.g., vect1 + vect2).","code":""},{"path":"/reference/union.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine two GVectors — union,GVector,GVector-method","text":"","code":"# S4 method for class 'GVector,GVector' union(x, y)"},{"path":"/reference/union.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine two GVectors — union,GVector,GVector-method","text":"x, y GVectors representing polygons.","code":""},{"path":"/reference/union.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine two GVectors — union,GVector,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/union.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine two GVectors — union,GVector,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Polygon of coastal Madagascar and Dypsis specimens madCoast4 <- fastData(\"madCoast4\") # polygons madDypsis <- fastData(\"madDypsis\") # points  # Convert vectors: coast4 <- fast(madCoast4) dypsis <- fast(madDypsis)  # Create another polygons vector from a convex hull around Dypsis points hull <- convHull(dypsis)  ### union() ###########  unioned <- union(coast4, hull) plot(unioned)  plus <- coast4 + hull # same as union()  ### intersect #############  inter <- intersect(coast4, hull) plot(coast4) plot(hull, border = \"red\", add = TRUE) plot(inter, border = \"blue\", add = TRUE)  ### xor #######  xr <- xor(coast4, hull) plot(coast4) plot(xr, border = \"blue\", add = TRUE)  ### erase #########  erased <- erase(coast4, hull) plot(coast4) plot(erased, border = \"blue\", add = TRUE)  minus <- coast4 - hull # same as erase()  }"},{"path":"/reference/update.html","id":null,"dir":"Reference","previous_headings":"","what":"Refresh metadata in a GRaster or GVector — update,GRaster-method","title":"Refresh metadata in a GRaster or GVector — update,GRaster-method","text":"GRasters GVectors really pointers objects GRASS. values displayed use show() print() GRaster GVector stored R. , odd chance make change GRaster GVector (e.g., using commands rgrass package), changes automatically reflected GRaster GVector. function can used update objects R reflect proper values.","code":""},{"path":"/reference/update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refresh metadata in a GRaster or GVector — update,GRaster-method","text":"","code":"# S4 method for class 'GRaster' update(object)  # S4 method for class 'GVector' update(object)"},{"path":"/reference/update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refresh metadata in a GRaster or GVector — update,GRaster-method","text":"object GRaster GVector.","code":""},{"path":"/reference/update.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refresh metadata in a GRaster or GVector — update,GRaster-method","text":"GRaster GVector.","code":""},{"path":"/reference/update.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refresh metadata in a GRaster or GVector — update,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\")  # Convert SpatRasters to GRasters elev <- fast(madElev) forest <- fast(madForest2000)  ### GRaster properties ######################  # plotting plot(elev)  # dimensions dim(elev) # rows, columns, depths, layers nrow(elev) # rows ncol(elev) # columns ndepth(elev) # depths nlyr(elev) # layers  res(elev) # resolution (2D) res3d(elev) # resolution (3D) zres(elev) # vertical resolution xres(elev) # vertical resolution yres(elev) # vertical resolution zres(elev) # vertical resolution (NA because this is a 2D GRaster)  # cell counts ncell(elev) # cells ncell3d(elev) # cells (3D rasters only)  # number of NA and non-NA cells nacell(elev) nonnacell(elev)  # topology topology(elev) # number of dimensions is.2d(elev) # is it 2-dimensional? is.3d(elev) # is it 3-dimensional?  minmax(elev) # min/max values  # \"names\" of the object names(elev)  # coordinate reference system crs(elev) st_crs(elev)  # extent (bounding box) ext(elev)  # vertical extent (not defined for this raster) zext(elev)  # data type datatype(elev) # fasterRaster type datatype(elev, \"GRASS\") # GRASS type datatype(elev, \"terra\") # terra type datatype(elev, \"GDAL\") # GDAL type  is.integer(elev) is.float(elev) is.double(elev) is.factor(elev)  # convert data type as.int(elev) # integer; note that \"elev\" is already of type \"integer\" as.float(elev) # floating-precision as.doub(elev) # double-precision  # assigning pie <- elev pie[] <- pi # assign all cells to the value of pi pie  # concatenating multiple GRasters rasts <- c(elev, forest) rasts  # subsetting rasts[[1]] rasts[[\"madForest2000\"]]  # replacing rasts[[2]] <- 2 * forest rasts  # adding layers rasts[[3]] <- elev > 500 # add a layer rasts <- c(rasts, sqrt(elev)) # add another add(rasts) <- ln(elev) rasts  # names names(rasts) names(rasts) <- c(\"elev_meters\", \"2_x_forest\", \"high_elevation\", \"sqrt_elev\", \"ln_elev\") rasts  # remove a layer rasts[[\"2_x_forest\"]] <- NULL rasts  # number of layers nlyr(rasts)  # correlation and covariance matrices madLANDSAT <- fastData(\"madLANDSAT\") landsat <- fast(madLANDSAT) # projects matrix layerCor(landsat) # correlation layerCor(landsat, fun = 'cov') # covariance  }"},{"path":"/reference/vAsDataTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","title":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","text":"GRASS vectors can linked attribute table, can exported GRASS R using function. function mostly use developers. Values cat column necessarily unique–value appears , set features index (software) called \"multipart\" features. table can columns metadata feature. function typically used developers.","code":""},{"path":"/reference/vAsDataTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","text":"","code":".vAsDataTable(x)"},{"path":"/reference/vAsDataTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","text":"x GVector name vector GRASS.","code":""},{"path":"/reference/vAsDataTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","text":"data.table NULL vector attached database.","code":""},{"path":"/reference/vAsDataTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a GRASS vector's attribute table to a data.table — .vAsDataTable","text":"","code":"if (grassStarted()) {  madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers)  .vCats(rivers) .vHasDatabase(rivers) .vAsDataTable(rivers) .vRecat(rivers) # dangerous--re-categorizes geometries! .vValidCats(rivers)  .vDetachDatabase(rivers) # dangerous--detaches database! .vAttachDatabase(rivers)  # Ensure we don't use this for other examples! .rm(rivers) # delete in GRASS rm(rivers) # delete in R  }"},{"path":"/reference/vAttachDatabase.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a database table to a GRASS attribute table — .vAttachDatabase","title":"Add a database table to a GRASS attribute table — .vAttachDatabase","text":".vAttachDatabase() adds table GRASS vector. table meant \"invisible\" users–use interact attribute tables using GVector slot `@table“. functions require tables (e.g., extract() spatSample()). function mostly use developers.","code":""},{"path":"/reference/vAttachDatabase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a database table to a GRASS attribute table — .vAttachDatabase","text":"","code":".vAttachDatabase(x, table = NULL, replace = TRUE, cats = NULL)"},{"path":"/reference/vAttachDatabase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a database table to a GRASS attribute table — .vAttachDatabase","text":"x GVector name vector GRASS. table Either NULL (default), data.frame data.table, numeric integer vector: NULL, bare minimal table created column named frid, holding sequential integer values. data.frame data.table column named frid, one created sequential integer values. table column named frid, integer (just numeric) values. vector, coerced type integer used define frid column. one row/value per geometry x. replace Logical: TRUE, replace existing database connection. cats Either NULL (default), integer vector: provided means save time passing cats function already generated calling function.","code":""},{"path":"/reference/vAttachDatabase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a database table to a GRASS attribute table — .vAttachDatabase","text":"Invisibly returns sources() name vector GRASS.","code":""},{"path":"/reference/vCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Category column values of a GRASS vector — .vCats","title":"Category column values of a GRASS vector — .vCats","text":"Returns values cat column vector GRASS.","code":""},{"path":"/reference/vCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Category column values of a GRASS vector — .vCats","text":"","code":".vCats(x, layer = 1, db = FALSE, integer = TRUE)"},{"path":"/reference/vCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Category column values of a GRASS vector — .vCats","text":"x GVector name vector GRASS. layer Integer, numeric integer, character: Layer obtain category values. db Logical: TRUE, return category numbers database table associated vector. FALSE (default), return category numbers actual vector. integer Logical: TRUE (default), return category values integers. cases, geometry can multiple categories, case NA returned. FALSE, return category values strings (thus, geometry one category, convert NA).","code":""},{"path":"/reference/vCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Category column values of a GRASS vector — .vCats","text":"vector.","code":""},{"path":"/reference/vCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Category column values of a GRASS vector — .vCats","text":"","code":"if (grassStarted()) {  madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers)  .vCats(rivers) .vHasDatabase(rivers) .vAsDataTable(rivers) .vRecat(rivers) # dangerous--re-categorizes geometries! .vValidCats(rivers)  .vDetachDatabase(rivers) # dangerous--detaches database! .vAttachDatabase(rivers)  # Ensure we don't use this for other examples! .rm(rivers) # delete in GRASS rm(rivers) # delete in R  }"},{"path":"/reference/vDetachDatabase.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a database table to a GRASS attribute table — .vDetachDatabase","title":"Add a database table to a GRASS attribute table — .vDetachDatabase","text":".vDetachDatabase() detaches database GRASS vector deletes . table meant \"invisible\" users–use interact attribute tables using GVector slot `@table“. functions require tables (e.g., extract() spatSample()). function mostly use developers.","code":""},{"path":"/reference/vDetachDatabase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a database table to a GRASS attribute table — .vDetachDatabase","text":"","code":".vDetachDatabase(x)"},{"path":"/reference/vDetachDatabase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a database table to a GRASS attribute table — .vDetachDatabase","text":"x GVector name vector GRASS.","code":""},{"path":"/reference/vDetachDatabase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a database table to a GRASS attribute table — .vDetachDatabase","text":"Invisibly returns sources() name vector GRASS.","code":""},{"path":"/reference/vHasDatabase.html","id":null,"dir":"Reference","previous_headings":"","what":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","title":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","text":"GRASS vectors can lined one attribute tables, \"databases.\". function tests see vector indeed database. function typically used developers.","code":""},{"path":"/reference/vHasDatabase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","text":"","code":".vHasDatabase(x)"},{"path":"/reference/vHasDatabase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","text":"x GVector sources() name vector GRASS.","code":""},{"path":"/reference/vHasDatabase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","text":"Logical.","code":""},{"path":"/reference/vHasDatabase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tests if a GRASS vector is linked to an attribute table — .vHasDatabase","text":"","code":"if (grassStarted()) {  madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers)  .vCats(rivers) .vHasDatabase(rivers) .vAsDataTable(rivers) .vRecat(rivers) # dangerous--re-categorizes geometries! .vValidCats(rivers)  .vDetachDatabase(rivers) # dangerous--detaches database! .vAttachDatabase(rivers)  # Ensure we don't use this for other examples! .rm(rivers) # delete in GRASS rm(rivers) # delete in R  }"},{"path":"/reference/vIncrementCats.html","id":null,"dir":"Reference","previous_headings":"","what":"Increment category values of a ","title":"Increment category values of a ","text":"Adds constant category values GRASS vector. function mostly use developers.","code":""},{"path":"/reference/vIncrementCats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increment category values of a ","text":"","code":".vIncrementCats(x, add)"},{"path":"/reference/vIncrementCats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Increment category values of a ","text":"x GVector sources() name one. add Integer: Value add category value.","code":""},{"path":"/reference/vIncrementCats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Increment category values of a ","text":"sources() name GRASS vector category values incremented.","code":""},{"path":"/reference/vIncrementCats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Increment category values of a ","text":"","code":"if (grassStarted()) {  madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers)  .vCats(rivers) .vHasDatabase(rivers) .vAsDataTable(rivers) .vRecat(rivers) # dangerous--re-categorizes geometries! .vValidCats(rivers)  .vDetachDatabase(rivers) # dangerous--detaches database! .vAttachDatabase(rivers)  # Ensure we don't use this for other examples! .rm(rivers) # delete in GRASS rm(rivers) # delete in R  }"},{"path":"/reference/vNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Names of columns of a GRASS vector's attribute table — .vNames","title":"Names of columns of a GRASS vector's attribute table — .vNames","text":"function returns column names GRASS vector's attribute table.","code":""},{"path":"/reference/vNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names of columns of a GRASS vector's attribute table — .vNames","text":"","code":".vNames(x)"},{"path":"/reference/vNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Names of columns of a GRASS vector's attribute table — .vNames","text":"x GVector name vector GRASS.","code":""},{"path":"/reference/vNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Names of columns of a GRASS vector's attribute table — .vNames","text":"Character vector.","code":""},{"path":"/reference/vNames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Names of columns of a GRASS vector's attribute table — .vNames","text":"","code":"if (grassStarted()) {  madRivers <- fastData(\"madRivers\") rivers <- fast(madRivers)  .vCats(rivers) .vHasDatabase(rivers) .vAsDataTable(rivers) .vRecat(rivers) # dangerous--re-categorizes geometries! .vValidCats(rivers)  .vDetachDatabase(rivers) # dangerous--detaches database! .vAttachDatabase(rivers)  # Ensure we don't use this for other examples! .rm(rivers) # delete in GRASS rm(rivers) # delete in R  }"},{"path":"/reference/vRecat.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-make vector ","title":"Re-make vector ","text":"geometry GRASS vector \"category\" number (abbreviated \"cat\" output modules). Geometries can different numbers, functions work intended, often need sequential category values, starting 1, skips integers. function reconstitutes category values vector GRASS 1 skips. function mostly use developers.","code":""},{"path":"/reference/vRecat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-make vector ","text":"","code":".vRecat(x, gtype, cats = NULL)"},{"path":"/reference/vRecat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-make vector ","text":"x GVector sources() name vector GRASS. gtype Character: Type vector features GRASS format (.e., either point, line, area). See geomtype(). cats NULL (default) integer character vector: Category values GRASS vector. Supplying can speed re-assignment categories. values cats used new category values. Rather, used indicate geometries belong multi-part feature.","code":""},{"path":"/reference/vRecat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-make vector ","text":"sources() name vector.","code":""},{"path":[]},{"path":"/reference/vect.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","title":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","text":"fasterRaster version vect() function converts GVector SpatVector (terra package). fasterRaster version st_as_sf() function converts GVector sf object (sf package).","code":""},{"path":"/reference/vect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","text":"","code":"# S4 method for class 'GVector' vect(x, ...)  # S4 method for class 'GVector' st_as_sf(x)"},{"path":"/reference/vect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","text":"x GVector. ... Additional arguments send writeVector().","code":""},{"path":"/reference/vect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","text":"vect() returns SpatVector (terra package), st_as_sf() returns sf vector (sf package).","code":""},{"path":[]},{"path":"/reference/vect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a GVector to a SpatVector or sf vector — vect,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example data: madCoast4 <- fastData(\"madCoast4\") madRivers <- fastData(\"madRivers\") madDypsis <- fastData(\"madDypsis\")  # Convert sf vectors to GVectors: coast <- fast(madCoast4) rivers <- fast(madRivers) dypsis <- fast(madDypsis)  # Geographic properties: ext(rivers) # extent crs(rivers) # coordinate reference system  # Column names and data types: names(coast) datatype(coast)  # Points, lines, or polygons? geomtype(dypsis) geomtype(rivers) geomtype(coast)  is.points(dypsis) is.points(coast)  is.lines(rivers) is.lines(dypsis)  is.polygons(coast) is.polygons(dypsis)  # Number of dimensions: topology(rivers) is.2d(rivers) # 2-dimensional? is.3d(rivers) # 3-dimensional?  # Just the data table: as.data.frame(rivers) as.data.table(rivers)  # Top/bottom of the data table: head(rivers) tail(rivers)  # Vector or table with just selected columns: names(rivers) rivers$NAME rivers[[c(\"NAM\", \"NAME_0\")]] rivers[[c(3, 5)]]  # Select geometries/rows of the vector: nrow(rivers) selected <- rivers[2:6] nrow(selected)  # Plot: plot(coast) plot(rivers, col = \"blue\", add = TRUE) plot(selected, col = \"red\", lwd = 2, add = TRUE)  # Vector math: hull <- convHull(dypsis)  un <- union(coast, hull) sameAsUnion <- coast + hull plot(un) plot(sameAsUnion)  inter <- intersect(coast, hull) sameAsIntersect <- coast * hull plot(inter) plot(sameAsIntersect)  er <- erase(coast, hull) sameAsErase <- coast - hull plot(er) plot(sameAsErase)  xr <- xor(coast, hull) sameAsXor <- coast / hull plot(xr) plot(sameAsXor)  # Vector area and length: expanse(coast, unit = \"km\") # polygons areas expanse(rivers, unit = \"km\") # river lengths  # Fill holes # First, we will make some holes by creating buffers around points, then # removing them from a polygons GVector. buffs <- buffer(dypsis, 500)  holes <- coast - buffs plot(holes)  filled <- fillHoles(holes, fail = FALSE)  }"},{"path":"/reference/vegIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","title":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","text":"function calculates one many types vegetation indices raster four bands representing blue (B), green (G), red (R), near infrared (NIR), plus possibly channels 5 7. function requires rasters represent surface reflectance, values fall range 0 1, unless digital number rasters (e.g., integers range 0 255). digital number format used, bits argument defined.","code":""},{"path":"/reference/vegIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","text":"","code":"# S4 method for class 'GRaster' vegIndex(   x,   index = \"NDVI\",   r = NULL,   g = NULL,   b = NULL,   nir = NULL,   b5 = NULL,   b7 = NULL,   soilSlope = NULL,   soilIntercept = NULL,   soilNR = 0.08,   bits = NULL )"},{"path":"/reference/vegIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","text":"x GRaster one layer per required band. Values 0 1. index Character character vector: vegetation index indices calculate. can find list available indices using fastData(\"vegIndices\") (also see vegIndices). first column, \"index\" provides name index, values argument accept (e.g., \"NDVI\", \"EVI2\"). Partial matching used, case ignored. can also use shortcuts: \"*\": Calculate indices \"RNIR\": Calculate indices use R NIR channels (channels). \"NotSoil\": Calculate indices use channels require soilSlope soilIntercept. Note: near-comprehensive table indices can found Index Database: Database Remote Sensing Indices. r, g, b, nir Numeric character: Index names() layers x represent red, green, blue, near infrared channels. Values must range 0 1 integers. b5, b7 Numeric character: Index names layers representing bands 5 7. used GVI PVI. Values must range 0 1 integers. soilSlope, soilIntercept, soilNR Numeric: Values soil slope, intercept, soil noise reduction factor (0.08, default). Used calculation MSAVI. bits Either NULL (default) numeric integer integer value 7, 8, 10, 16: rasters represented integers (fall range 0 1), number bits can supplied using bits. case, range 0 2^n, n 7, 8, 10, 16. bit rasters supplied, must datatype() \"integer\". raster values range 0 1, bits NULL (default).","code":""},{"path":"/reference/vegIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/vegIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vegetation indices from surface reflectance — vegIndex,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster, rivers vector madLANDSAT <- fastData(\"madLANDSAT\")  # Convert a SpatRaster to a GRaster: landsat <- fast(madLANDSAT)  # See available vegetation indices: vegIndices  # Normalized Difference Vegetation Index and Enhanced Vegetation Index: indices <- c(\"ndvi\", \"evi\") vi <- vegIndex(landsat, index = indices, r = 1, b = 3, nir = 4, bits = 8) plot(vi)  # All indices using R and NIR: rnir <- vegIndex(landsat, index = \"rnir\", r = 1, nir = 4, bits = 8)  # Note: Some values are highly skewed, likely due to cloud cover and other # anomalies that should be corrected. plot(rnir)  }"},{"path":"/reference/vegIndices.html","id":null,"dir":"Reference","previous_headings":"","what":"Table of vegetation indices that can be calculated from remote sensing surface reflectance data using vegIndex(). A near-comprehensive table of indices can be found on the Index Database: A Database for Remote Sensing Indices. — vegIndices","title":"Table of vegetation indices that can be calculated from remote sensing surface reflectance data using vegIndex(). A near-comprehensive table of indices can be found on the Index Database: A Database for Remote Sensing Indices. — vegIndices","text":"table vegetation indices ca calculated using vegIndex(). Columns include: `index“: Abbreviation index. definition: Index name R, G, B, NIR, channel5, channel7: Whether index uses red, green, blue, near-infrared channels, channels 5 7. soilLineslope, soilIntercept, soilNR: Whether index requires soil line slope, soil intercept, soil noise reduction factor.","code":""},{"path":"/reference/vegIndices.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Table of vegetation indices that can be calculated from remote sensing surface reflectance data using vegIndex(). A near-comprehensive table of indices can be found on the Index Database: A Database for Remote Sensing Indices. — vegIndices","text":"object class data.frame.","code":""},{"path":[]},{"path":"/reference/vegIndices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table of vegetation indices that can be calculated from remote sensing surface reflectance data using vegIndex(). A near-comprehensive table of indices can be found on the Index Database: A Database for Remote Sensing Indices. — vegIndices","text":"","code":"### vector data ###############  library(sf)  # For vector data, we can use data(*) or fastData(*): data(madCoast0) # same as next line madCoast0 <- fastData(\"madCoast0\") # same as previous madCoast0 #> Simple feature collection with 1 feature and 68 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731581.6 ymin: 1024473 xmax: 768721.2 ymax: 1085686 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>   OBJECTID ID_0 ISO NAME_ENGLISH   NAME_ISO   NAME_FAO NAME_LOCAL NAME_OBSOLETE #> 1        1  134 MDG   Madagascar MADAGASCAR Madagascar Madagascar               #>       NAME_VARIANTS NAME_NONLATIN NAME_FRENCH NAME_SPANISH NAME_RUSSIAN #> 1 Malagasy Republic               Madagascar   Madagascar    Мадагаскар #>   NAME_ARABIC NAME_CHINESE WASPARTOF CONTAINS  SOVEREIGN ISO2 WWW FIPS ISON #> 1      مدغشقر  马达加斯加                     Madagascar   MG       MA  450 #>    VALIDFR VALIDTO  POP2000       SQKM            POPSQKM      UNREGION1 #> 1 19581014 Present 15970364 594856.375 26.847428507427527 Eastern Africa #>   UNREGION2 DEVELOPING CIS Transition OECD           WBREGION   WBINCOME #> 1    Africa          1                     Sub-Saharan Africa Low income #>                WBDEBT WBOTHER CEEAC CEMAC CEPLG COMESA EAC ECOWAS IGAD IOC MRU #> 1 Moderately indebted    HIPC                        1                   1     #>   SACU UEMOA UMA PALOP PARTA CACM EurAsEC Agadir SAARC ASEAN NAFTA GCC CSN #> 1                                                                          #>   CARICOM EU CAN ACP Landlocked AOSIS SIDS Islands LDC #> 1                  1                             1   1 #>                         geometry #> 1 MULTIPOLYGON (((755432.2 10... plot(st_geometry(madCoast0))  madCoast4 <- fastData(\"madCoast4\") madCoast4 #> Simple feature collection with 2 features and 17 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 731811.7 ymin: 1024542 xmax: 768726.5 ymax: 1085485 #> Projected CRS: Tananarive (Paris) / Laborde Grid #>      OBJECTID ID_0 ISO     NAME_0 ID_1    NAME_1 ID_2       NAME_2 ID_3 #> 1070     1070  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   79 #> 1098     1098  134 MDG Madagascar    5 Toamasina   17 Analanjirofo   82 #>                 NAME_3 ID_4    NAME_4 VARNAME_4 CCN_4 CCA_4    TYPE_4 ENGTYPE_4 #> 1070          Mananara 1070 Antanambe              NA       Fokontany   Commune #> 1098 Soanierana-Ivongo 1098 Manompana              NA       Fokontany   Commune #>                            geometry #> 1070 MULTIPOLYGON (((760305.9 10... #> 1098 MULTIPOLYGON (((754786.8 10... plot(st_geometry(madCoast4), add = TRUE)  madRivers <- fastData(\"madRivers\") madRivers #> Simple feature collection with 11 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 731627.1 ymin: 1024541 xmax: 762990.1 ymax: 1085580 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        F_CODE_DES          HYC_DESCRI      NAM ISO     NAME_0 #> 1180 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1185 River/Stream Perennial/Permanent MANANARA MDG Madagascar #> 1197 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1216 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1248 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1256 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1257 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1264 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1300 River/Stream Perennial/Permanent      UNK MDG Madagascar #> 1312 River/Stream Perennial/Permanent      UNK MDG Madagascar #>                            geometry #> 1180 LINESTRING (739818.2 108005... #> 1185 LINESTRING (739818.2 108005... #> 1197 LINESTRING (747857.8 108558... #> 1216 LINESTRING (739818.2 108005... #> 1248 LINESTRING (762990.1 105737... #> 1256 LINESTRING (742334.2 106858... #> 1257 LINESTRING (731803.7 105391... #> 1264 LINESTRING (755911.6 104957... #> 1300 LINESTRING (731871 1044531,... #> 1312 LINESTRING (750186.1 103441... plot(st_geometry(madRivers), col = \"blue\", add = TRUE)  madDypsis <- fastData(\"madDypsis\") madDypsis #> Simple feature collection with 42 features and 9 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 735228.4 ymin: 1026056 xmax: 762442 ymax: 1085002 #> Projected CRS: Tananarive (Paris) / Laborde Grid #> First 10 features: #>        gbifID      license                  rightsHolder institutionCode year #> 1  2397516155 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 2  2397516017 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 3  2397515145 CC_BY_NC_4_0                  vononarbgkew     iNaturalist 2019 #> 4  2268865622    CC_BY_4_0     Missouri Botanical Garden              MO 2006 #> 5  2268863965    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 6  2268862328    CC_BY_4_0     Missouri Botanical Garden              MO 1994 #> 7  2268862230    CC_BY_4_0     Missouri Botanical Garden              MO 1991 #> 8  1928075921      CC0_1_0 The New York Botanical Garden              NY 2006 #> 9  1677261542 CC_BY_NC_4_0                    Landy Rita     iNaturalist 2016 #> 10 1453257920 CC_BY_NC_4_0              mamy_andriamahay     iNaturalist 2016 #>    month day coordinateUncertaintyInMeters               species #> 1      8  11                             4       Dypsis nodifera #> 2      8  11                             3       Dypsis nodifera #> 3      8  11                             3       Dypsis nodifera #> 4      9  14                            NA Dypsis betsimisarakae #> 5     10  10                            NA       Dypsis nodifera #> 6     10  23                            NA       Dypsis nodifera #> 7     10  11                            NA       Dypsis nodifera #> 8      9  15                            NA        Dypsis integra #> 9      6  11                            17    Dypsis lastelliana #> 10    11  29                            21    Dypsis lastelliana #>                    geometry #> 1  POINT (744929.8 1028994) #> 2  POINT (745240.1 1029239) #> 3  POINT (745067.4 1029098) #> 4  POINT (737649.4 1044160) #> 5  POINT (760879.5 1071766) #> 6  POINT (748297.4 1064593) #> 7  POINT (747876.6 1038768) #> 8  POINT (737901.5 1044806) #> 9  POINT (749428.6 1033303) #> 10 POINT (745272.7 1032050) plot(st_geometry(madDypsis), col = \"red\", add = TRUE)   ### raster data ###############  library(terra)  # For raster data, we can get the file directly or using fastData(*): rastFile <- system.file(\"extdata/madElev.tif\", package=\"fasterRaster\") madElev <- terra::rast(rastFile)  madElev <- fastData(\"madElev\") # same as previous two lines madElev #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madElev.tif  #> name        : madElev  #> min value   :       1  #> max value   :     570  plot(madElev)   madForest2000 <- fastData(\"madForest2000\") madForest2000 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2000.tif  #> name        : madForest2000  #> min value   :             1  #> max value   :             1  plot(madForest2000)   madForest2014 <- fastData(\"madForest2014\") madForest2014 #> class       : SpatRaster  #> dimensions  : 512, 313, 1  (nrow, ncol, nlyr) #> resolution  : 119.7031, 119.7031  (x, y) #> extent      : 731581.6, 769048.6, 1024437, 1085725  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madForest2014.tif  #> name        : madForest2014  #> min value   :             1  #> max value   :             1  plot(madForest2014)   # multi-layer rasters madChelsa <- fastData(\"madChelsa\") madChelsa #> class       : SpatRaster  #> dimensions  : 67, 42, 4  (nrow, ncol, nlyr) #> resolution  : 0.008333333, 0.008333333  (x, y) #> extent      : 49.54153, 49.89153, -16.85014, -16.29181  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madChelsa.tif  #> names       :  bio1, bio7,  bio12, bio15  #> min values  : 20.85,  6.2, 3230.9,  32.2  #> max values  : 24.45, 11.9, 4608.9,  43.2  plot(madChelsa)   madPpt <- fastData(\"madPpt\") madTmin <- fastData(\"madTmin\") madTmax <- fastData(\"madTmax\") madPpt #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madPpt.tif  #> names       : ppt01, ppt02, ppt03, ppt04, ppt05, ppt06, ...  #> min values  :   344,   343,   343,   246,   146,   161, ...  #> max values  :   379,   401,   442,   395,   265,   261, ...  madTmin #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmin.tif  #> names       : tmin01, tmin02, tmin03, tmin04, tmin05, tmin06, ...  #> min values  :     21,     21,     20,     19,     17,     16, ...  #> max values  :     23,     23,     23,     22,     20,     19, ...  madTmax #> class       : SpatRaster  #> dimensions  : 9, 6, 12  (nrow, ncol, nlyr) #> resolution  : 6082.837, 6082.837  (x, y) #> extent      : 726346.3, 762843.4, 1026783, 1081528  (xmin, xmax, ymin, ymax) #> coord. ref. : Tananarive (Paris) / Laborde Grid  #> source      : madTmax.tif  #> names       : tmax01, tmax02, tmax03, tmax04, tmax05, tmax06, ...  #> min values  :     29,     29,     29,     28,     27,     25, ...  #> max values  :     31,     31,     30,     30,     28,     27, ...    # RGB raster madLANDSAT <- fastData(\"madLANDSAT\") madLANDSAT #> class       : SpatRaster  #> dimensions  : 344, 209, 4  (nrow, ncol, nlyr) #> resolution  : 180, 180  (x, y) #> extent      : 344055, 381675, -1863345, -1801425  (xmin, xmax, ymin, ymax) #> coord. ref. : WGS 84 / UTM zone 39N (EPSG:32639)  #> source      : madLANDSAT.tif  #> names       : band2, band3, band4, band5  #> min values  :    15,    23,    22,    25  #> max values  :   157,   154,   158,   166  plotRGB(madLANDSAT, 4, 1, 2, stretch = \"lin\")   # categorical raster madCover <- fastData(\"madCover\") madCover #> class       : SpatRaster  #> dimensions  : 201, 126, 1  (nrow, ncol, nlyr) #> resolution  : 0.002777778, 0.002777778  (x, y) #> extent      : 49.54028, 49.89028, -16.85139, -16.29306  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84 (EPSG:4326)  #> source      : madCover.tif  #> categories  : Short, Long  #> name        :        Short  #> min value   : Mosaic crops  #> max value   :        Water  madCover <- droplevels(madCover) levels(madCover) # levels in the raster #> [[1]] #>   Value                                              Short #> 1    20                                       Mosaic crops #> 2    30                         Mosaic cropland/vegetation #> 3    40 Sparse broadleaved evergreen/semi-deciduous forest #> 4    50                       Broadleaved deciduous forest #> 5   120                       Grassland with mosaic forest #> 6   130                                          Shrubland #> 7   140                           Grassland/savanna/lichen #> 8   170                                     Flooded forest #> 9   210                                              Water #>  nlevels(madCover) # number of categories #> [1] 0 catNames(madCover) # names of categories table #> [[1]] #> [1] \"Value\" \"Short\" \"Long\"  #>   plot(madCover)"},{"path":"/reference/voronoi.html","id":null,"dir":"Reference","previous_headings":"","what":"Voronoi tessellation — voronoi,GVector-method","title":"Voronoi tessellation — voronoi,GVector-method","text":"function creates Voronoi tessellation set spatial points polygons.","code":""},{"path":"/reference/voronoi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Voronoi tessellation — voronoi,GVector-method","text":"","code":"# S4 method for class 'GVector' voronoi(x, buffer = 0)"},{"path":"/reference/voronoi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Voronoi tessellation — voronoi,GVector-method","text":"x GVector \"points\" object. buffer Numeric: default, function creates vector extent exactly input data. However, apparent extent can changed setting value value different 0. Negative values reduce size extent, positive extend .  Units map units.","code":""},{"path":"/reference/voronoi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Voronoi tessellation — voronoi,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/voronoi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Voronoi tessellation — voronoi,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Example vectors madDypsis <- fastData(\"madDypsis\") # points madCoast4 <- fastData(\"madCoast4\") # polygons  # Convert sf vectors to GVectors dypsis <- fast(madDypsis) coast4 <- fast(madCoast4) ant <- coast4[coast4$NAME_4 == \"Antanambe\"]  # Delaunay triangulation dypsisDel <- delaunay(dypsis) plot(dypsisDel) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Voronoi tessellation vor <- voronoi(dypsis) plot(vor) plot(dypsis, pch = 1, col = \"red\", add = TRUE)  # Random Voronoi tessellation rand <- rvoronoi(coast4, size = 100) plot(rand)  }"},{"path":"/reference/wetness.html","id":null,"dir":"Reference","previous_headings":"","what":"Topographic wetness index — wetness,GRaster-method","title":"Topographic wetness index — wetness,GRaster-method","text":"function creates raster map values equal topographic wetness index (TWI), measure much overland water flow tends accumulate flow away location.","code":""},{"path":"/reference/wetness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topographic wetness index — wetness,GRaster-method","text":"","code":"# S4 method for class 'GRaster' wetness(x)"},{"path":"/reference/wetness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topographic wetness index — wetness,GRaster-method","text":"x GRaster (typically representing elevation). raster must projected (.e., WGS84, NAD83, et cetera).","code":""},{"path":"/reference/wetness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topographic wetness index — wetness,GRaster-method","text":"GRaster.","code":""},{"path":[]},{"path":"/reference/wetness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Topographic wetness index — wetness,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation raster madElev <- fastData(\"madElev\")  # Convert to GRaster: elev <- fast(madElev)  # Terrain ruggedness index: tri <- ruggedness(elev) plot(c(elev, tri))  # Topographic wetness index: twi <- wetness(elev) plot(c(elev, twi))  }"},{"path":"/reference/workDir.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a GLocation's working directory — workDir,GLocation-method","title":"Get a GLocation's working directory — workDir,GLocation-method","text":"function returns working directory GLocation object.","code":""},{"path":"/reference/workDir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a GLocation's working directory — workDir,GLocation-method","text":"","code":"# S4 method for class 'GLocation' workDir(x)"},{"path":"/reference/workDir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a GLocation's working directory — workDir,GLocation-method","text":"x GLocation object.","code":""},{"path":"/reference/workDir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a GLocation's working directory — workDir,GLocation-method","text":"Character.","code":""},{"path":"/reference/writeRaster.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a GRaster to disk — writeRaster,GRaster,character-method","title":"Save a GRaster to disk — writeRaster,GRaster,character-method","text":"function saves GRaster disk directly GRASS session. faster using rast(), saving output disk (rast() actually save raster disk, anyway). function attempt ascertain file type ascertained file extension, can specify format using format argument (see entry ...). can see list supported formats simply using function arguments, writeRaster(), consulting online help page GRASS module r..gdal. GeoTIFF file format guaranteed work multi-layered rasters. function attempt optimize datatype argument, can take long time. can speed setting datatype manually. Note saving \"stack\" GRasters different datatypes, one highest information density used (e.g., low-bit integer < high-bit integer < floating-point < double-floating point). can make rasters lower datatypes much larger disk. cases, make best save rasters similar datatypes together.","code":""},{"path":"/reference/writeRaster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a GRaster to disk — writeRaster,GRaster,character-method","text":"","code":"# S4 method for class 'GRaster,character' writeRaster(   x,   filename,   overwrite = FALSE,   datatype = NULL,   byLayer = FALSE,   levelsExt = NULL,   compress = \"LZW\",   warn = TRUE,   ... )  # S4 method for class 'missing,missing' writeRaster(x, filename)"},{"path":"/reference/writeRaster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save a GRaster to disk — writeRaster,GRaster,character-method","text":"x GRaster missing: missing, table supported file types reported. filename Character: Path file name. overwrite Logical: FALSE (default), save existing file(s). datatype NULL (default) character: datatype values stored non-ASCII rasters. NULL, ascertained raster, function usually good job . However, can force manually, note cases, trying save GRaster using inappropriate datatype values can result error function exiting without error also without written raster disk. argument can take shown first four columns, whatever used, converted GDAL version. * Depends integers (signed/unsigned, range values). Categorical rasters associated file saved category values labels. file name raster's file name, end extension given levelsExt (.csv default). byLayer Logical: FALSE (default), multi-layer rasters saved one file. TRUE, layer saved separate file. filename filename amended ends _<name> (file extension), <name> give names(). Note characters raster names work file name, function fail (e.g., backslash question mark). levelsExt Character, logical, NULL (default): Name file extension \"levels\" file accompanies categorical raster. saving categorical rasters, raster file accompanied \"levels\" file contain information levels raster. file filename, except different extension. Valid values depend many raster layers saved time (case ignored): DefaultOne raster layer: \".csv\" Two layers, least one categorical raster: \".rds\", \".rda\", \".rdat\", \".rdata\" : NULL TRUE automatically selects either \".csv\" (one raster layer) \".rds (two ) : FALSE disables saving levels file. compress Character: Type compression use GeoTIFF files: \"LZW\" (default) \"DEFLATE\" \"PACKBITS\" \"LZMA\" NULL: compression used, file can still reduced size using zip, gzip, compressions. warn Logical: TRUE (default), display warning datatype argument match value given datatype(x, \"GDAL\"), fileExt argument work given raster automatically changed. ... Additional arguments. can include: bigTiff: Logical: TRUE, file format GeoTIFF larger 4 GB (regardless compression), file saved BIGTIFF format. format: Character, indicating file format. usually ascertained file extension, case fails, can stated explicitly. using formats, may specify createopts argument, (see help page GRASS module r..gdal). Two common formats include: \"GTiff\" (default): GeoTIFF filename ends .tif. \"ASC\": ASCII filename ends .asc Additional arguments send GRASS modules r..gdal r..ascii. precision: Numeric: ASCII files, may need state number significant digits. 32-bit values 7 digits 64-bit values 16. cases argument precision=7 precision=16.","code":""},{"path":"/reference/writeRaster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save a GRaster to disk — writeRaster,GRaster,character-method","text":"GRaster (invisibly). raster also saved disk.","code":""},{"path":[]},{"path":"/reference/writeRaster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save a GRaster to disk — writeRaster,GRaster,character-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madElev <- fastData(\"madElev\") madChelsa <- fastData(\"madChelsa\")  ### What raster formats can we attempt to write? writeRaster()  ### Save GRaster to disk (using temporary file) elev <- fast(madElev) filename <- tempfile(fileext = \".tif\") writeRaster(elev, filename)  # Load raster from disk elev2 <- fast(filename) elev2  ### Save multi-layer GRaster to disk in one file (using temporary file) chelsa <- fast(madChelsa) filename <- tempfile(fileext = \".tif\") writeRaster(chelsa, filename)  # Load raster from disk chelsa2 <- fast(filename) chelsa2  ### Save multi-layer GRaster to disk layer-by-layer (using temporary file) chelsa <- fast(madChelsa) filename <- tempfile(fileext = \".tif\") writeRaster(chelsa, filename, byLayer = TRUE)  # Load one of the rasters from disk filename2 <- sub(filename, pattern = \".tif\", replacement = \"_bio1.tif\") chelsaBio1 <- fast(filename2) chelsaBio1  }"},{"path":"/reference/writeVector.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a GVector to disk — writeVector,GVector,character-method","title":"Save a GVector to disk — writeVector,GVector,character-method","text":"function saves GVector disk directly GRASS session. default, files OGC GeoPackage format (extension \".gpkg\"), can changed format argument. can see list supported formats simply using function arguments, writeVector(), consulting online help page GRASS module v..ogr. Note vector data table attached least one numeric integer column NA NaN value, function yield warning like:   Also note despite promise, warning displayed .","code":"Warning 1: Invalid value type found in record 2 for field column_with_NA_or_NaN. This warning will no longer be emitted."},{"path":"/reference/writeVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a GVector to disk — writeVector,GVector,character-method","text":"","code":"# S4 method for class 'GVector,character' writeVector(   x,   filename,   overwrite = FALSE,   format = NULL,   attachTable = TRUE,   ... )  # S4 method for class 'missing,missing' writeVector(x, filename)"},{"path":"/reference/writeVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save a GVector to disk — writeVector,GVector,character-method","text":"x GVector. filename Character: Path file name. overwrite Logical: FALSE (default), save existing files. format Character NULL: File format. NULL (default), function attempt get format file name extension. Partial matching used case ignored. can see list formats using writeVector() (arguments). common formats include: \"GPKG\": OGC GeoPackage (extension .gpkg). \"CSV\": Comma-separated value... saves data table , geometries (extension .csv). \"ESRI Shapefile\": ESRI shapefile (extension .shp). \"GeoJSON\": GeoJSON (extension GeoJSON) \"KML\": Keyhole Markup Language (extension .kml) \"netCDF\": NetCDF (extension .ncdf) \"XLSX\": MS Office Open XML spreadsheet (extension .xlsx). attachTable Logical: TRUE (default), attach attribute table vector saving . FALSE, attribute table attached. ... Additional arguments send GRASS module v..ogr GRASS.","code":""},{"path":"/reference/writeVector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save a GVector to disk — writeVector,GVector,character-method","text":"Invisibly returns GRaster (input, x). Also saves vector disk.","code":""},{"path":[]},{"path":"/reference/writeVector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save a GVector to disk — writeVector,GVector,character-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data madRivers <- fastData(\"madRivers\")  # What file formats can we attempt to write? writeVector()  # Convert SpatVector to GVector rivers <- fast(madRivers) rivers  # Save GVector to disk as GeoPackage filename <- tempfile(fileext = \".gpkg\") writeVector(rivers, filename)  # Save GVector to disk as ESRI Shapefile filename <- tempfile(fileext = \".shp\") writeVector(rivers, filename)  # Save GVector to disk as Google Earth KML filename <- tempfile(fileext = \".klm\") writeVector(rivers, filename)  # Save GVector data table to disk as comma-separated file filename <- tempfile(fileext = \".csv\") writeVector(rivers, filename)  # Save GVector data table to disk as NetCDF filename <- tempfile(fileext = \".ncdf\") writeVector(rivers, filename)  # Save GVector data table to disk as Excel file filename <- tempfile(fileext = \".xlsx\") writeVector(rivers, filename)  }"},{"path":"/reference/xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","title":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","text":"xor() function selects area overlap two \"polygon\" GVectors. can also use / operator, vect 1 / vect2.","code":""},{"path":"/reference/xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","text":"","code":"# S4 method for class 'GVector,GVector' xor(x, y)"},{"path":"/reference/xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","text":"x, y GVectors.","code":""},{"path":"/reference/xor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","text":"GVector.","code":""},{"path":[]},{"path":"/reference/xor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select parts of polygons not shared between two GVectors — xor,GVector,GVector-method","text":"","code":"if (grassStarted()) {  # Setup library(sf)  # Polygon of coastal Madagascar and Dypsis specimens madCoast4 <- fastData(\"madCoast4\") # polygons madDypsis <- fastData(\"madDypsis\") # points  # Convert vectors: coast4 <- fast(madCoast4) dypsis <- fast(madDypsis)  # Create another polygons vector from a convex hull around Dypsis points hull <- convHull(dypsis)  ### union() ###########  unioned <- union(coast4, hull) plot(unioned)  plus <- coast4 + hull # same as union()  ### intersect #############  inter <- intersect(coast4, hull) plot(coast4) plot(hull, border = \"red\", add = TRUE) plot(inter, border = \"blue\", add = TRUE)  ### xor #######  xr <- xor(coast4, hull) plot(coast4) plot(xr, border = \"blue\", add = TRUE)  ### erase #########  erased <- erase(coast4, hull) plot(coast4) plot(erased, border = \"blue\", add = TRUE)  minus <- coast4 - hull # same as erase()  }"},{"path":"/reference/zonal.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","title":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","text":"Function zonal() calculates statistics (mean, sum, etc.) cells GRaster \"zones\" created cells another GRaster GVector.","code":""},{"path":"/reference/zonal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","text":"","code":"# S4 method for class 'GRaster,ANY' zonal(x, z, fun = \"mean\", probs = 0.5)"},{"path":"/reference/zonal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","text":"x GRaster calculate summary statistics. z GRaster GVector used define zones: z GRaster, must type integer factor. Zones established based cells value raster. z GVector, zones created geometry. geometries overlap, zonal statistics calculated ones top. Thus statistics zones defined geometries may represent cells covered geometry. fun Character vector: Name function(s) summarize x . can include: \"*\": functions . \"cv\": Sample coefficient variation (expressed proportion mean). \"cvpop\": Population coefficient variation (expressed proportion mean). \"max\" \"min\": Highest lowest values across non-NA cells. \"mean\" (default): Average. \"meanAbs\": Mean absolute values. \"median\": Median. \"quantile\": Quantile (see also argument probs). \"range\": Range. \"sd\": Sample standard deviation. \"sdpop\": Population standard deviation. \"sum\": Sum. \"var\": Sample variance. \"varpop\": Population variance. probs Numeric: Quantile calculate quantile. single value 0 1 allowed.","code":""},{"path":"/reference/zonal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","text":"data.frame data.table.","code":""},{"path":"/reference/zonal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Statistics on cells of a GRaster stratified by cells of another raster — zonal,GRaster,ANY-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Elevation SpatRaster: madElev <- fastData(\"madElev\")  # Convert a SpatRaster to a GRaster: elev <- fast(madElev)  ### Calculate zonal statistics using a GRaster as zones #######################################################  # Generate a \"zones\" GRaster by dividing raster into areas based on # high/low elevation. names(elev) # Use this name in app() formula. fun <- \"= if (madElev <200, 0, if (madElev <400, 1, 2))\" zones <- app(elev, fun = fun)  # Calculate zonal statistics using a raster as zones zonal(elev, zones, fun = \"mean\") zonal(elev, zones, fun = \"*\") # all statistics  # Calculate zonal statistics on multi-layered GRaster elev2 <- c(elev, log10(elev)) zonal(elev2, zones, fun = c(\"mean\", \"sum\", \"sdpop\"))  ### Calculate zonal statistics using a GVector as zones #######################################################  madCoast4 <- fastData(\"madCoast4\") coast <- fast(madCoast4)  zonal(elev, z = coast, fun = \"mean\")  }"},{"path":"/reference/zonalGeog.html","id":null,"dir":"Reference","previous_headings":"","what":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","title":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","text":"function calculates geographic statistics set cells integer factor raster. Statistics include: Area Perimeter length \"Compact square\" statistic: \\(4 \\sqrt(area) / perimeter)\\) \"Compact circle\" statistic: \\(4 * P / ( 2 \\sqrt(\\pi * ))\\) P perimeter length area. fractal dimension: \\(2 ( log(P) / log(+ 0.001))\\) P perimeter length area. average x- y-coordinates zone.","code":""},{"path":"/reference/zonalGeog.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","text":"","code":"# S4 method for class 'GRaster' zonalGeog(x, unit = \"meters\")"},{"path":"/reference/zonalGeog.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","text":"x GRaster. unit Character: Units output. : \"meters\" (default) \"kilometers\" \"km\" \"miles\" \"mi\" \"yards\" \"yd\" \"feet\" \"ft\": International foot; 1 foot exactly equal 0.3048 meters \"cells\": Number cells Partial matching used case ignored.","code":""},{"path":"/reference/zonalGeog.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","text":"list data.frames data.tables, one per layer x. layers integers factors geographies calculated. layers NULL tables returned.","code":""},{"path":"/reference/zonalGeog.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geographic statistics for sets of cells with the same values — zonalGeog,GRaster-method","text":"","code":"if (grassStarted()) {  # Setup library(terra)  # Example data: Elevation and land cover madElev <- fastData(\"madElev\") madForest2000 <- fastData(\"madForest2000\") madCover <- fastData(\"madCover\")  # Convert to GRasters: elev <- fast(madElev) forest2000 <- fast(madForest2000) cover <- fast(madCover)  # Rename names(elev) <- \"elev\" names(forest2000) <- \"forest\"  # Geometric statistics for an integer raster zoned by elevation: fun <-   \"= if (elev <400 & forest == 1, 0, if (elev >=400 & forest == 1, 1, null()))\" forestByElev <- app(c(elev, forest2000), fun = fun) plot(forestByElev, main = \"forest < 400 m & >= 400 m\") zonalGeog(forestByElev)  # Geometric statistics for a categorical raster: zonalGeog(cover)  }"},{"path":"/news/index.html","id":"fasterraster-8307024-2024-09-17","dir":"Changelog","previous_headings":"","what":"fasterRaster 8.3.0.7024 (2024-09-17)","title":"fasterRaster 8.3.0.7024 (2024-09-17)","text":"o Added pkgdown site!!! (Experimental…)","code":""},{"path":"/news/index.html","id":"big-fixes-8-3-0-7024","dir":"Changelog","previous_headings":"","what":"Big fixes","title":"fasterRaster 8.3.0.7024 (2024-09-17)","text":"o bioclims() calculates BIO07 even BIO05 BIO06 explicitly called. o faster() accepts names list argument.","code":""},{"path":[]},{"path":"/news/index.html","id":"main-task-of-this-pre-release-8-3-0-7023","dir":"Changelog","previous_headings":"","what":"Main task of this pre-release","title":"fasterRaster 8.3.0.7023 (2024-09-15)","text":"o Fix issues arising check().","code":""},{"path":[]},{"path":"/news/index.html","id":"main-task-of-this-pre-release-8-3-0-7022","dir":"Changelog","previous_headings":"","what":"Main task of this pre-release","title":"fasterRaster 8.3.0.7022 (2024-09-07)","text":"o Examples help files checked , needed, either calling function(s) fixed. See “Bug fixes speed-ups” .","code":""},{"path":"/news/index.html","id":"new-functions-and-functionality-8-3-0-7022","dir":"Changelog","previous_headings":"","what":"New functions and functionality","title":"fasterRaster 8.3.0.7022 (2024-09-07)","text":"o dim3d() returns “region’s” dimensions called arguments. o global() calculates quantiles much faster (minutes vs. weeks) large rasters. o layerCor() default calculates inter-GRaster correlation. o reorient() converts facing angles north east orientations. o terrain() can return slope aspect radians, allows custom value set undefined aspects. o Default value memory faster() now 2 GB.","code":""},{"path":"/news/index.html","id":"potentially-co-breaking-changes-8-3-0-7022","dir":"Changelog","previous_headings":"","what":"Potentially co-breaking changes","title":"fasterRaster 8.3.0.7022 (2024-09-07)","text":"o global() argument prob changed probs can accommodate one value. o horizonHeight() function now uses argument step instead directions. o Removed sd() sdpop() replaced stdev().","code":""},{"path":"/news/index.html","id":"bug-fixes-and-speed-ups-8-3-0-7022","dir":"Changelog","previous_headings":"","what":"Bug fixes and speed-ups","title":"fasterRaster 8.3.0.7022 (2024-09-07)","text":"o atan2() works! o extract() extracts! o fast() can convert SpatRaster one layers subset larger SpatRaster GRaster without error. o fractalRast() faster. o freq() work input categorical GRaster. p interpSplines() bug causing lambda values returned fixed. o horizonHeight() returns GRasters can used directly sun(). o plotRGB() longer stuck infinite loop infinite loop infinite loop infinite loop infinite loop infinite loop infinite loop. o rSpatialDepRast() faster. o replace_double_square_brackets works! o simplifyGeom() works using “dp” “dpr” methods. o spatSample() works byStratum = TRUE. o subset_dollar bug fixed related rationalization dim() res(). o subset_double_square_brackets works = missing j = missing. o subset_single_bracket works x[, j] neither j missing. o sun() works GRasters horizonHeight(). o terrain() works methods (v = '*') called. o update() retains GVector’s data table. o vegIndex() fixed bug parsing index. o zonal() works zones set GVector.","code":""},{"path":[]},{"path":"/news/index.html","id":"potentially-co-breaking-changes-8-3-0-7021","dir":"Changelog","previous_headings":"","what":"Potentially co-breaking changes","title":"fasterRaster 8.3.0.7021 (2024-08-03)","text":"o Renamed terrainRuggednessIndex() ruggedness(). o Renamed topoWetnessIndex() wetness().","code":""},{"path":"/news/index.html","id":"new-functions-and-functionality-8-3-0-7021","dir":"Changelog","previous_headings":"","what":"New functions and functionality","title":"fasterRaster 8.3.0.7021 (2024-08-03)","text":"o [ (subset_single_bracket) can use GRaster inside [] specify cells GRaster subset. o [<- (replace_single_square_bracket) can use GRaster inside [] specify cells GRaster re-assigned. o bioclims() new function calculates “classic” “extended” set BIOCLIM rasters. works GRasters SpatRasters! o faster() now option clean, enables automatic deletion temporary files created functions. o mow() new function removes unused raster vector files GRASS cache. o project() now verbose argument displaying progress. o sineRast() now accepts arguments amplitude. o tiles() new function creates spatially exclusive subsets GRasters.","code":""},{"path":"/news/index.html","id":"issues-and-bug-fixes-8-3-0-7021","dir":"Changelog","previous_headings":"","what":"Issues and bug fixes","title":"fasterRaster 8.3.0.7021 (2024-08-03)","text":"o spatSample() now works values = TRUE.","code":""},{"path":"/news/index.html","id":"fasterraster-8307020-2024-07-05","dir":"Changelog","previous_headings":"","what":"fasterRaster 8.3.0.7020 (2024-07-05)","title":"fasterRaster 8.3.0.7020 (2024-07-05)","text":"+: Denotes potentially code-breaking changes","code":""},{"path":"/news/index.html","id":"new-functions-and-functionality-8-3-0-7020","dir":"Changelog","previous_headings":"","what":"New functions and functionality","title":"fasterRaster 8.3.0.7020 (2024-07-05)","text":"o sineRast(): Creates sine wave rasters.","code":""},{"path":"/news/index.html","id":"changes-in-functionality-8-3-0-7020","dir":"Changelog","previous_headings":"","what":"Changes in functionality","title":"fasterRaster 8.3.0.7020 (2024-07-05)","text":"o distance() now works calculation distances two GVectors GVector . o + extract() + spatSample(): Changed default value cats argument TRUE. o fragmentation() much faster SpatRasters SpatRasters GRasters, can display progress. o + plot() faster large rasters. Replaced argument maxcell simplify. o show() displays long raster names properly.","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7019","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7019 (2024-06-08)","text":"o .na(): Fixed bug causing incorrect answer.","code":""},{"path":"/news/index.html","id":"fasterraster-8307018-2024-06-07","dir":"Changelog","previous_headings":"","what":"fasterRaster 8.3.0.7018 (2024-06-07)","title":"fasterRaster 8.3.0.7018 (2024-06-07)","text":"+: Denotes potentially code-breaking changes","code":""},{"path":"/news/index.html","id":"new-functions-and-functionality-8-3-0-7018","dir":"Changelog","previous_headings":"","what":"New functions and functionality","title":"fasterRaster 8.3.0.7018 (2024-06-07)","text":"o + spatSample(): Much faster (though actually fast…) large samples taken GRasters. Removed argument seed GRaster signature, added argument verbose give something watch. o freq(): Added `function-specific example.","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7018","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7018 (2024-06-07)","text":"o global(): Fixed bug arising called functions main argument sources() name.","code":""},{"path":"/news/index.html","id":"fasterraster-8307017-2024-06-02","dir":"Changelog","previous_headings":"","what":"fasterRaster 8.3.0.7017 (2024-06-02)","title":"fasterRaster 8.3.0.7017 (2024-06-02)","text":"+: Denotes potentially code-breaking changes","code":""},{"path":"/news/index.html","id":"new-functions-and-functionality-8-3-0-7017","dir":"Changelog","previous_headings":"","what":"New functions and functionality","title":"fasterRaster 8.3.0.7017 (2024-06-02)","text":"o rast(): Attaches GRaster’s levels table SpatRaster output. o + rasterize(): Rewritten perform (nearly) terra::rasterize(). o predict(): Can accommodate models two-way interactions categorical rasters categorical predictor scalar. o scalepop(): Scales GRasters population standard deviation. o Stops somewhat informative error GRaster fails created (hidden function .makeGRaster())","code":""},{"path":"/news/index.html","id":"issues-8-3-0-7017","dir":"Changelog","previous_headings":"","what":"Issues","title":"fasterRaster 8.3.0.7017 (2024-06-02)","text":"o writeRaster(): Correctly assign datatype CELL rasters. O + cor() cov() removed incorporated layerCor()","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7017","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7017 (2024-06-02)","text":"o activeCat() activeCats(): Fixed bug introduced previous fix. o activeCat(): Correct output names = TRUE. o expanse(): Expanded list units; correct assignation units GRASS unit format. o extract(): Extracting GRaster lines polygons GVector works. o fast(): Fixed bug arising reading vector saved writeRaster(). o + global(): Removed functions \"countNA\" \"countNonNA\" global() since GRASS module r.report can mistaken. o nacell() nonnacell(): Correct (slow~~~) reporting NA non-NA cells (workaround error GRASS’s r.report module).","code":""},{"path":[]},{"path":"/news/index.html","id":"functionality-8-3-0-7016","dir":"Changelog","previous_headings":"","what":"Functionality","title":"fasterRaster 8.3.0.7016 (2024-05-27)","text":"o Added streams() calculating location stream channels DEM. o Added terrainRuggednessIndex() calculating terrain ruggedness index. o unscale() can skip unscaling rasters supplying NA center /scale vectors. o writeRaster() now automatically choose “least-lossy” datatype stack rasters. o robust checking whether vector topologically valid using fast(), added option aggregate disaggregate polygons overcome issue.","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7016","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7016 (2024-05-27)","text":"o crop() correctly sets westernmost coordinate (inappropriately far west, cases). o extend() works “extension” factor integer. o GRasters can now multiplied , divide , added , subtracted numerics scientific notation format. o hist() now works factor GRasters. o plot() relies writeRaster() datatype (better). o writeRaster() saves -NA rows columns.","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7015","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7015 (2024-05-21)","text":"o [ now works large GVectors (.e., >1M geometries). o Fixed behind-scenes issue arising CRS string couldn’t parsed shorter version (.locationCreate() related).","code":""},{"path":[]},{"path":"/news/index.html","id":"functionality-8-3-0-7014","dir":"Changelog","previous_headings":"","what":"Functionality","title":"fasterRaster 8.3.0.7014 (2024-05-17)","text":"o Added function flow() calculating flow water across landscape. o Added function flowPath() calculating flow water specific points landscape. o freq() inserts category labels results categorical GRasters. o Added function geomorphons() identifying geomorphological features. o Added function maskNA() converting non-NA cells NA cells user-defined value. o plot() displays levels categorical rasters. o Can save layer--layer writeRaster(). o Added ability create points GVectors numeric, matrices, data frames using fast(). o Improved auto-assessment raster datatype writeRaster(). o Updated README 8.3.0.7013!","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7014","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7014 (2024-05-17)","text":"o [ works consistently GVectors!!!!! o Hidden function .makeGVector() now catches cases zero extent polygons. o Fixed installation issue related activeCat()<- addCats()<- (thank , @kbondo1!) o Fixed bug arithmetic determining data type input raster. o crds() works GRASS vector attribute table. o extract() extracts values GVectors large numbers points without crashing. o plot() works! (Previous issue arose changing output writeRaster() GRaster). o rast() correctly returns SpatRaster. o vect() correctly returns SpatVector.","code":""},{"path":"/news/index.html","id":"issues-8-3-0-7014","dir":"Changelog","previous_headings":"","what":"Issues","title":"fasterRaster 8.3.0.7014 (2024-05-17)","text":"o Removed rasterPrecision option now use internal function .getPrec() ascertain proper precision rasters. o Option fail creation GRaster polygons GVector zero extent.","code":""},{"path":"/news/index.html","id":"changes-8-3-0-7014","dir":"Changelog","previous_headings":"","what":"Changes","title":"fasterRaster 8.3.0.7014 (2024-05-17)","text":"o complete.cases() missing.cases() return logical vectors vectors data tables (integer vectors).","code":""},{"path":[]},{"path":"/news/index.html","id":"functionality-8-3-0-7007","dir":"Changelog","previous_headings":"","what":"Functionality","title":"fasterRaster 8.3.0.7007 (2024-05-01)","text":"o Added function classify(). o Added function subst(). o Added function combineLevels(). o Added hidden function .plot(). o functions cases appropriate, “levels” table input GRaster passed output. o fragmentation() works windows sizes > 3 GRasters.","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7007","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7007 (2024-05-01)","text":"o writeRaster() correctly assigns levels categorical rasters >1 layer. o Fixed bug [[<- passed incorrect dimensions (failed).","code":""},{"path":"/news/index.html","id":"issues-8-3-0-7007","dir":"Changelog","previous_headings":"","what":"Issues","title":"fasterRaster 8.3.0.7007 (2024-05-01)","text":"o [ selects geometries GRaster, overcoming mis-selection GRASS o Removed datatype() method signature SpatRaster","code":""},{"path":[]},{"path":"/news/index.html","id":"functionality-8-3-0-7003","dir":"Changelog","previous_headings":"","what":"Functionality","title":"fasterRaster 8.3.0.7003 (2024-03-15)","text":"rbind() cbind() work GVectors.","code":""},{"path":"/news/index.html","id":"bug-fixes-8-3-0-7003","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"fasterRaster 8.3.0.7003 (2024-03-15)","text":"o Fix bug setting extent new raster crop()","code":""},{"path":"/news/index.html","id":"fasterraster-8307001-2024-03-15","dir":"Changelog","previous_headings":"","what":"fasterRaster 8.3.0.7001 (2024-03-15)","title":"fasterRaster 8.3.0.7001 (2024-03-15)","text":"Alpha release new, intuitive fasterRaster emulating interoperable terra!!!","code":""},{"path":"/news/index.html","id":"breaking-changes-8-3-0-7001","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"fasterRaster 8.3.0.7001 (2024-03-15)","text":"Nearly nothing new version fasterRaster compared version 0.7 lower. functions previous versions removed.","code":""},{"path":"/news/index.html","id":"new-features-8-3-0-7001","dir":"Changelog","previous_headings":"","what":"New features","title":"fasterRaster 8.3.0.7001 (2024-03-15)","text":"fasterRaster now compatible terra sf shares functions names (almost always) things (esp. terra, less sf).","code":""},{"path":"/news/index.html","id":"fasterraster-071-2022-08-05a","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.7.1 (2022-08-05a)","title":"fasterRaster 0.7.1 (2022-08-05a)","text":"Changed uses class() t* inherits()… fixes bug fasterFocal() (elsewhere?)","code":""},{"path":"/news/index.html","id":"fasterraster-070-2022-06-07","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.7.0 (2022-06-07)","title":"fasterRaster 0.7.0 (2022-06-07)","text":"fasterRaster can now use objects terra sf packages! Thanks suggestion, Miika!","code":""},{"path":"/news/index.html","id":"fasterraster-066-2021-11-30","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.6 (2021-11-30)","title":"fasterRaster 0.6.6 (2021-11-30)","text":"Fixed bug fasterHorizon(). Thanks, Forest!","code":""},{"path":"/news/index.html","id":"fasterraster-065-2021-10-13","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.5 (2021-10-13)","title":"fasterRaster 0.6.5 (2021-10-13)","text":"Fixed bug fasterTerrain(). Thanks, ankitsagar1!","code":""},{"path":"/news/index.html","id":"fasterraster-064-2021-06-04","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.4 (2021-06-04)","title":"fasterRaster 0.6.4 (2021-06-04)","text":"Added path t* GRASS directory Mac examples","code":""},{"path":"/news/index.html","id":"fasterraster-063-2021-03-17","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.3 (2021-03-17)","title":"fasterRaster 0.6.3 (2021-03-17)","text":"Updated documentation example data sets","code":""},{"path":"/news/index.html","id":"fasterraster-062-2021-01-08","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.2 (2021-01-08)","title":"fasterRaster 0.6.2 (2021-01-08)","text":"Fix bug workers stopping using fasterFocal() Mac","code":""},{"path":"/news/index.html","id":"fasterraster-060-2020-09-04","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.6.0 (2020-09-04)","title":"fasterRaster 0.6.0 (2020-09-04)","text":"Add generic function faster() call GRASS modules easily Add fasterContour(): Contours rasters Add fasterConvertDegree(): Convert degrees Add fasterMapcalc(): Raster calculation Add fasterSun(): Solar irradiation radiation Add fasterSurfFractal(): Fractal raster Add fasterTopoidx(): Topographic wetness index Revealed initGrass(): Now can use , ! User can provide names objects created GRASS functions Update PROJ4 strings data objects Update help lot","code":""},{"path":"/news/index.html","id":"fasterraster-051-2020-09-02","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.5.1 (2020-09-02)","title":"fasterRaster 0.5.1 (2020-09-02)","text":"Add fasterContour()","code":""},{"path":"/news/index.html","id":"fasterraster-050-2020-09-01","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.5.0 (2020-09-01)","title":"fasterRaster 0.5.0 (2020-09-01)","text":"Updated GRASS 7.8.","code":""},{"path":"/news/index.html","id":"fasterraster-04x-before-2020-09","dir":"Changelog","previous_headings":"","what":"fasterRaster 0.4.x (before 2020-09)","title":"fasterRaster 0.4.x (before 2020-09)","text":"Worked Open Source Geospatial (OSGeo) GRASS 7.4","code":""}]
