% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.r
\name{predict,GRaster-method}
\alias{predict,GRaster-method}
\alias{predict}
\title{Make predictions from a linear or generalized linear model to a GRaster}
\usage{
\S4method{predict}{GRaster}(object, model, type = "response")
}
\arguments{
\item{object}{A \code{GRaster} with one or more layers.}

\item{model}{An \code{lm} or \code{glm} model object.}

\item{type}{Character: Type of prediction to make. This can be either \code{link} (default; predictions are made on the scale of the link function) or \code{response} (predictions are made on the scale of the response variable). This function can only make predictions on the scale of the response for the identity, logit, log, or cloglog (complementary log-log) link functions.}
}
\value{
A \code{GRaster}.
}
\description{
This version of the \code{predict()} function make predictions to a set of \code{GRaster}s from a model object.

The model must be either a linear model, which is of class \code{lm} and typically created using the \code{\link[stats:lm]{stats::lm()}} function or a generalized linear model (GLM), which is class \code{glm} and typically created using \code{\link[stats:glm]{stats::glm()}}. Other packages can also create \code{lm} or \code{glm} objects, but they will probably not work in this function. For example, generalized additive models, which can be created using the \code{gam()} function in the \strong{mgcv} package, inherit the \code{glm} class, but cannot be used in this function.
}
\examples{
if (grassStarted()) {

# Setup
library(terra)

### This example creates a simple model of Dypsis distribution using
# elevation and distance to forest.

# Elevation raster, forest cover in year 2000, and points where Dypsis plants
# have been collected
madElev <- fastData("madElev")
madForest2000 <- fastData("madForest2000")
madDypsis <- fastData("madDypsis")

# Convert SpatRasters to GRasters and sf vector to GVector:
elev <- fast(madElev)
forest <- fast(madForest2000)
dypsis <- fast(madDypsis)

# Distance to forest
distToForest <- distance(forest, unit = "km")
distToForest <- log1p(distToForest) # log(x + 1) of distance
names(distToForest) <- "distToForest"

# "Stack" elevation and forest cover
land <- c(elev, distToForest)
plot(land)

# Scale predictors to mean of 0 and sd of 1
landScaled <- scale(land)
names(landScaled) <- c("elevation", "distToForest")

### Make model of dypsis locations:
# Extract elevation and forest cover at Dypsis locations
presEnv <- extract(landScaled, dypsis)
presEnv$presBg <- 1
head(presEnv)

# Extract elevation and forest cover at background 1000 sites:
bgEnv <- spatSample(landScaled, size = 1500, values = TRUE)
bgEnv <- bgEnv[stats::complete.cases(bgEnv), ]
bgEnv <- bgEnv[1:1000, ]
bgEnv$presBg <- 0
head(bgEnv)

# Combine presence and background data:
env <- rbind(presEnv, bgEnv)

# Calibrate model:
form <- presBg ~ elevation + distToForest +
I(distToForest^2) + elevation * distToForest

model <- stats::glm(form, data = env, family = stats::binomial)

summary(model)

# Make predictions and map:
prediction <- predict(landScaled, model, type = "response")
prediction

plot(prediction)
plot(dypsis, pch = 1, add = TRUE)

# Not a great model!

}
}
\seealso{
\code{\link[terra:predict]{terra::predict()}}; \code{\link[stats:predict]{stats::predict()}}
}
