% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.r
\name{predict,GRaster-method}
\alias{predict,GRaster-method}
\alias{predict}
\title{Make predictions from a linear or generalized linear model to a GRaster}
\usage{
\S4method{predict}{GRaster}(object, model, type = "response")
}
\arguments{
\item{object}{A \code{GRaster} with one or more layers.}

\item{model}{An \code{lm} or \code{glm} model object.}

\item{type}{Character: Type of prediction to make. This can be either \code{link} (default; predictions are made on the scale of the link function) or \code{response} (predictions are made on the scale of the response variable). This function can only make predictions on the scale of the response for the identity, logit, log, or cloglog (complementary log-log) link functions.}
}
\value{
A \code{GRaster}.
}
\description{
This version of the \code{predict()} function make predictions to a set of \code{GRaster}s from a model object.

The model must be either a linear model, which is of class \code{lm} and typically created using the \code{\link[stats:lm]{stats::lm()}} function or a generalized linear model (GLM), which is class \code{glm} and typically created using \code{\link[stats:glm]{stats::glm()}}. Other packages can also create \code{lm} or \code{glm} objects, but they may not work in this function. For example, generalized additive models, which can be created using the \code{gam()} function in the \strong{mgcv} package, inherit the \code{glm} class, but cannot be used in this function, but ones created with the \strong{speedglm} package can.

This \code{predict()} function can handle categorical predictors (i.e., \link[=tutorial_raster_data_types]{categorical} rasters), but only if the factor levels are used as offsets/intercepts (i.e., not in an interaction term).
}
\examples{
if (grassStarted()) {

# Setup
library(sf)
library(terra)

### This example creates a simple model of Dypsis distribution using
# elevation, distance to forest, and land cover class.

# Elevation raster, forest cover in year 2000, land cover class, and
# points where Dypsis plants have been collected
madElev <- fastData("madElev")
madForest2000 <- fastData("madForest2000")
madCover <- fastData("madCover")
madDypsis <- fastData("madDypsis")

# Convert SpatRasters to GRasters and sf vector to GVector:
elev <- fast(madElev)
forest <- fast(madForest2000)
dypsis <- fast(madDypsis)
cover <- fast(madCover)

# Distance to forest
distToForest <- distance(forest, unit = "km")
distToForest <- log1p(distToForest) # log(x + 1) of distance
names(distToForest) <- "distToForest"

# "Stack" elevation and forest cover
land <- c(elev, distToForest)
plot(land)

# Scale continuous predictors to mean of 0 and sd of 1
landScaled <- scale(land)
names(landScaled) <- c("elevation", "distToForest")

# Project land cover raster
coverProj <- project(cover, landScaled)

# Combine continuous/categorical data
covariateRasters <- c(landScaled, coverProj)

### Make model of Dypsis locations:
# Extract elevation and forest cover at Dypsis locations
presEnv <- extract(covariateRasters, dypsis, cats = TRUE)
presEnv$presBg <- 1
head(presEnv)

# Extract elevation and forest cover at background 2000 sites:
bgEnv <- spatSample(covariateRasters, size = 3000, values = TRUE, cats = TRUE)
bgEnv <- bgEnv[stats::complete.cases(bgEnv), ]
bgEnv <- bgEnv[1:2000, ]
bgEnv$presBg <- 0
head(bgEnv)

# Combine presence and background data:
env <- rbind(presEnv, bgEnv)

# Calibrate model:
form <- presBg ~ elevation + distToForest +
I(distToForest^2) + elevation * distToForest +
madCover

model <- stats::glm(form, data = env, family = stats::binomial)
summary(model)

# Make predictions and map:
prediction <- predict(covariateRasters, model, type = "response")
prediction

plot(prediction)
plot(dypsis, pch = 1, add = TRUE)

# Not a great model!

}
}
\seealso{
\code{\link[terra:predict]{terra::predict()}}; \code{\link[stats:predict]{stats::predict()}}
}
