% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fasterFocal.r
\name{fasterFocal}
\alias{fasterFocal}
\title{Calculations on "neighboring" cells of a raster}
\usage{
fasterFocal(
  rast,
  fun = "mean",
  w = 3,
  circle = FALSE,
  weightFx = NULL,
  weightFactor = NULL,
  mask = NULL,
  quantile = 0.5,
  largeNum = 1e+06,
  cores = 1,
  grassDir = options()$grassDir,
  grassToR = TRUE,
  inRastName = ifelse(is.null(names(rast)), "rast", names(rast)),
  outGrassName = "focalRast"
)
}
\arguments{
\item{rast}{A \code{SpatRaster} or the name of a raster already in an existing \code{GRASS} session.}

\item{fun}{Name of the function to calculate on each neighborhood.
\itemize{
    \item \code{'average'} or \code{'mean'} (default): \code{See note about rounding below!}
    \item \code{'median'}
    \item \code{'mode'}
    \item \code{'minimum'} or \code{'maximum'}
    \item \code{'range'}
    \item \code{'stddev'} or \code{'sd'}: Standard deviation. \code{See note about rounding below!} \emph{Also note:} In \code{GRASS} the standard deviation is calculated as the population standard deviation: \deqn{sqrt(\sum((x_i - x_bar)^2) / N}, whereas in \code{base R} and in \pkg{terra}, it is calculated as the sample standard deviation: \deqn{sqrt(\sum((x_i - x_bar)^2) / (N - 1)}, (i.e., the same as in the function \code{sd}). Which is correct?  It depends on whether you considerall of the cells in a neighborhood are the complete statistical "population" of cells in the neighborhood, or represent a random sample thereof.
    \item \code{'sum'}: Sum of non-\code{NA} cells.
    \item \code{'count'}: Number of non-\code{NA} cells.
    \item \code{'variance'} or \code{'var'}: \code{See note about rounding below!}. As with \code{stdev} (above), this is the population variance, not sample variance.
    \item \code{'diversity'}: Number of unique values.
    \item \code{'interspersion'}: Percent of cells with values different from focal cell, plus 1 (e.g., if 6 of 8 cells have different values, then the interspersion is 100 * 6/8 + 1 = 76). \code{See note about rounding below! Unlike other functions, rounding is NOT corrected for.}
    \item \code{'quart1'}, \code{'quart3'}: First and third quarties (i.e., 25th and 75th quantiles).
    \item \code{'perc90'}: The 90th quantile.
    \item \code{'quantile'}
}
The center cell value is always included in the calculations.\cr
\emph{Rounding}: Some of the functions noted above normally have outputs rounded to the nearest integer when executed in \code{GRASS}. To obviate this issue, for these functions the raster is first multipled by a large number (given in \code{largeNum}). The operation is performed, then the raster is divided by this large number again. If this is an issue, you can multiply the raster by a large number, do the focal operation, then divide by the same number. You can skip this step by setting \code{largeNum} to \code{NULL} (i.e., so output will be rounded for these functions).}

\item{w}{Either the size of each neighborhood in number of cells across (a single, odd integer), \emph{or} a matrix of weights (example: \code{matrix(c(0.5, 1, 0.5, 1, 2, 1, 0.5, 1, 0.5), nrow=3)}). You cannot use a weights matric when \code{circle = TRUE} or \code{weightFx = 'gaussian' or 'exponential'}.}

\item{circle}{If \code{FALSE} (default), use a square neighborhood. If \code{TRUE}, then \code{size} will be the diameter of the circle (in the x- or y-direction). Cannot be used with \code{weightFx} or when \code{w} is a matrix.}

\item{weightFx}{Either \code{NULL} or the name of a weighting function. Valid values include: \code{'gaussian'} (Gaussian weighting) or \code{'exponential'} (exponential weighting). See also argument \code{weightFactor}. Cannot be used when \code{circle = TRUE} or \code{w} is a matrix.}

\item{weightFactor}{Either \code{NULL}, or factor used in the weighting function (if it is Gaussian or exponential). Ignored otherwise. If the weighting function is Gaussian, then this is the value of \eqn{\sigma} (the standard deviation), as in \deqn{exp(-(x*x+y*y)/(2*\sigma^2))/(2*π*σ^2)}. If exponential, this is the value of the decay parameter \eqn{d}, as in \deqn{exp(d*\sqrt(x^2+y^2))}. Negative values cause weights of cells more distant from the center to have less influence.}

\item{mask}{Either \code{NULL}, a \code{SpatRaster}, or name of a raster already in \code{GRASS}. This is used to select cells to be used in calculations. If provided, then only cells that are not \code{NA} in the mask are filled in. All others are assigned the value in \code{rast}.}

\item{quantile}{Quantile to calculate when \code{method = 'quantile'}. The default value is 0.5 (median), and valid values are in [0, 1].}

\item{largeNum}{For functions that normally produce rounded output in \code{GRASS}, multiply the raster first by this value then execute the focal operation, then divide by this number. Note that scientific notation cannot be used. If you wish to skip this step (i.e., round the output), then set this equal to \code{NULL}. The default values is 1000000, so values should be accurate to within 1E-5. This \emph{really should} be an integer (positive or negative).}

\item{cores}{Number of cores to use (default is 1).}

\item{grassDir}{Name of the folder path in which \code{GRASS} is installed. For a Windows system, this might be something like \code{'C:/Program Files/GRASS GIS 8.2'}. For a Mac system, this might be like \code{"/Applications/GRASS-8.2.app/Contents/Resources"}. If you are using a lot of \pkg{fasterRaster} functions, it can be easier to set this once using \code{\link{fasterOptions}}. By default, this is \code{NULL}, in which case the install path for \code{GRASS} will be searched for, but if not found, will result in an error.}

\item{grassToR}{If \code{TRUE} (default) then the output will be returned to \pkg{R}. If \code{FALSE}, then the output is left in the \code{GRASS} session and named the value in \code{outGrassName}. You can then refer to the output in subsequent \pkg{fasterRaster} functions and avoid the need to re-import it. This is called "chaining" functions together, and it can save a lot of computational time.}

\item{inRastName}{The name of the input raster in \code{GRASS}. This is useful only if you are "chaining" \code{fasterRaster} functions together and wish to refer to the input raster later. The default value is the name of the raster (i.e., \code{names(rast)}).}

\item{outGrassName}{Character. Name of output in \code{GRASS}. This is useful if you want to refer to the output object in \code{GRASS} later in a session by "chaining" functions.}
}
\value{
if \code{returnToR} is \code{TRUE}, a \code{SpatRaster}. Either way, a raster with the name given by \code{outGrassName} is created in a \code{GRASS} session.
}
\description{
Calculates statistics on a moving set of cells in a "neighborhood".
}
\examples{
\dontrun{

library(terra)

### mean
madElev <- fasterData('madElev')
meanFocalFR <- fasterFocal(madElev, w=3, fun='mean', cores=2)
meanFocalTerra <- terra::focal(madElev, w=3, fun='mean', na.rm=TRUE)

# same!
meanFocalFR
meanFocalTerra

### mean with circular neighborhood
meanCircleFR <- fasterFocal(madElev, w=3, fun='mean', circle=TRUE,
outGrassName='circle', cores=2)

w <- matrix(c(0, 1, 0, 1, 1, 1, 0, 1, 0), nrow=3)
meanCircleTerra <- terra::focal(madElev, w=w, fun='mean', na.rm=TRUE)

# same!
meanCircleFR
meanCircleTerra

### using weights matrix
w <- matrix(c(0.5, 1, 0.5, 1, 2, 1, 0.5, 1, 0.5), nrow=3)
w <- w / sum(w) # normalize
meanWeightsFR <- fasterFocal(madElev, w=w, fun='sum', cores=2)
meanWeightsTerra <- terra::focal(madElev, w=w, fun='sum', na.rm=TRUE)

# same!
meanWeightsFR
meanWeightsTerra

# Using a "high-pass" weights matrix:
w <- matrix(c(-1, -1, -1, -1, 8, -1, -1, 1, -1) / 9, nrow=3)
hpFilter <- fasterFocal(madElev, w=w, fun='sum', cores=2)

### sum with mask
mask <- fasterData('madForest2000')
maskFocal <- fasterFocal(madElev, w=3, fun='sum', mask=mask, cores=2)

### sum with weighting function
gaussFocal <- fasterFocal(madElev, w=3, fun='sum', weightFx='gaussian',
weightFactor=1, cores=2)

### standard deviations
sdFocalFR <- fasterFocal(madElev, w=3, fun='sd', cores=2)
sdFocalTerra <- focal(madElev, w=3, fun='sd', na.rm=TRUE)
# also see focalCpp() in terra package

# different!
sdFocalFR
sdFocalTerra

# why different? Because GRASS uses population SD and terra the sample SD.
madElevMat <- as.matrix(madElev, wide = TRUE)
nr <- nrow(madElevMat)
nc <- ncol(madElevMat)

sdMat1 <- sdMat2 <- sdMat3 <- NA * madElevMat
for (row in 2:(nr - 1)) {
  for (col in 2:(nc - 1)) {
    neigh <- madElevMat[(row - 1):(row + 1), (col - 1):(col + 1)]
    numer <- sqrt( sum((neigh - mean(neigh, na.rm=T))^2) )

    denom1 <- sqrt(sum(!is.na(neigh)))
    denom2 <- sqrt(sum(!is.na(neigh)) - 1)

    if (!is.na(denom2)) if (denom2 == 0) denom2 <- NA

    sdMat1[row, col] <- numer / denom1
    sdMat2[row, col] <- numer / denom2
    sdMat3[row, col] <- sd(neigh, na.rm=TRUE)
  }
}

sdRast1 <- rast(sdMat1, crs=crs(madElev), extent=ext(madElev))
sdRast2 <- rast(sdMat2, crs=crs(madElev), extent=ext(madElev))
sdRast3 <- rast(sdMat3, crs=crs(madElev), extent=ext(madElev))

sdRast1 # fasterRaster/ GRASS
sdRast2 # terra
sdRast3 # base R

}
}
\seealso{
\code{\link[terra]{focal}} and \code{\link[terra]{focalCpp}} in package \pkg{terra}; \href{https://grass.osgeo.org/grass82/manuals/r.neighbors.html}{\code{r.neighbors}} in \code{GRASS}
}
