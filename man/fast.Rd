% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fast.r
\name{fast,character-method}
\alias{fast,character-method}
\alias{fast}
\alias{fast,SpatRaster-method}
\alias{fast,SpatVector-method}
\alias{fast,sf-method}
\title{Create a GRaster or GVector}
\usage{
\S4method{fast}{character}(x, rastOrVect = NULL, snap = NULL, ...)

\S4method{fast}{SpatRaster}(x)

\S4method{fast}{SpatVector}(x, snap = NULL)

\S4method{fast}{sf}(x, snap = NULL)
}
\arguments{
\item{x}{Any one of:
\itemize{
\item A \code{SpatRaster} raster. Rasters can have one or more layers.
\item A \code{SpatVector} or \code{sf} spatial vector.
\item A character string or a vector of strinngs with the path(s) and filename(s) of one or more rasters or one vector to be loaded directly into \strong{GRASS}. The function will attempt to ascertain the type of object from the file extension (raster or vector), but it can help to indicate which it is using the \code{rastOrVect} argument if it is unclear.
}}

\item{rastOrVect}{Either \code{NULL} (default), or \code{"raster"} or \code{"vector"}: If \code{x} is a filename, then the function will try to ascertain whether it represents a raster or a vector, but sometimes this will fail. In that case, it can help to specify if the file holds a raster or vector. Partial matching is used.}

\item{snap}{For polygon \code{GVector}s only: Either \code{NULL} (default) or a positive numeric value: Sometimes, polygons created in other software are topologically incorrect--the borders of adjacent polygons may cross one another, or there may be small gaps between them. These errors can be corrected by slightly moving vertices. The value of \code{snap} indicates how close vertices need to be for them to be shifted to to the same location for a correct topology. Small values are recommended, and units are in map units (usually meters). By default, this is \code{NULL}, meaning no snapping is done. Vectors that have been snapped may need to be cleaned using \code{\link[=cleanGeom]{cleanGeom()}} with the \code{break}, \code{duplicated}, and \code{smallAngles} tools.}

\item{...}{Other arguments. These are typically used internally so not of use to most users. They can include:
\itemize{
\item \code{levels} (\code{GRaster}s): A \code{data.frame}, \code{data.table}, or list of \code{data.frame}s or \code{data.table}s with categories for categorical rasters: The first column of a table corresponds to raster values and must be of type \code{integer}. A subsequent column corresponds to category labels. By default, the second column is assumed to represent labels, but this can be changed with \code{\link[fasterRaster]{activeCat<-}}. Level tables can also be \code{NULL} (e.g., \code{data.fame(NULL)}).
\item \code{table} (\code{GVector}s): A \code{data.frame} or \code{data.table} with one row per geometry in a \code{GVector}: Serves as an attribute table.
}}
}
\value{
A \code{GRaster} or \code{GVector}.
}
\description{
\code{fast()} creates a \code{GRaster} or \code{GVector} from a file, or from a \code{SpatRaster}, \code{SpatVector}, or \code{sf} vector. This function will also create a connection to \strong{GRASS} the given coordinate reference system of the raster or vector if none has been made yet.

\strong{GRASS} supports loading from disk a variety of raster formats (see the \strong{GRASS} manual page for \href{https://grass.osgeo.org/grass84/manuals/r.in.gdal.html}{\code{r.in.gdal}}) and vector formats (see the \strong{GRASS} manual page for \href{https://grass.osgeo.org/grass84/manuals/v.in.ogr.html}{\code{v.in.ogr}}), though not all of them will work with this function.
}
\examples{
if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev <- fastData("madElev")
madForest2000 <- fastData("madForest2000")
madCoast0 <- fastData("madCoast0")
madRivers <- fastData("madRivers")
madDypsis <- fastData("madDypsis")

### GRaster properties
######################

# convert SpatRasters to GRasters
elev <- fast(madElev)
forest <- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# information on the GRASS session in which the GRaster is located
location(elev) # location
mapset(elev) # mapset

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy <- elev
copy[] <- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts <- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) <- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] <- elev > 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) <- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties
######################

# convert sf vectors to GVectors
coast <- fast(madCoast4)
rivers <- fast(madRivers)
dypsis <- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent
bottom(rivers) # bottom extent

# coordinate reference system
crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# session information
location(rivers) # GRASS location
mapset(rivers) # GRASS mapset

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
update(elev)

### operations on GVectors
##########################

# convert to data frame
as.data.frame(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2] # row/geometry 1 and column 1
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers <- update(rivers)

# Concatenating multiple vectors
rivers2 <- c(rivers, rivers)
dim(rivers)
dim(rivers2)

}
}
\seealso{
\code{\link[rgrass:readRAST]{rgrass::read_RAST()}} and \code{\link[rgrass:readVECT]{rgrass::read_VECT()}}, plus \strong{GRASS} modules \href{https://grass.osgeo.org/grass84/manuals/r.in.gdal.html}{\code{v.in.ogr}}, \href{https://grass.osgeo.org/grass84/manuals/v.in.ogr.html}{\code{v.in.ogr}}, and \href{https://grass.osgeo.org/grass84/manuals/r.import.html}{\code{r.import}}.
}
