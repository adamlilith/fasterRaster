% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distance.r
\name{distance,GRaster,missing-method}
\alias{distance,GRaster,missing-method}
\alias{distance}
\alias{distance,GRaster,GVector-method}
\alias{distance,GVector,GVector-method}
\alias{st_distance,GVector,GVector-method}
\title{Geographic distance}
\usage{
\S4method{distance}{GRaster,missing}(
  x,
  y,
  target = NA,
  fillNA = TRUE,
  unit = "meters",
  method = "Euclidean",
  minDist = NULL,
  maxDist = NULL
)

\S4method{distance}{GRaster,GVector}(
  x,
  y,
  fillNA = TRUE,
  dense = TRUE,
  unit = "meters",
  method = "Euclidean",
  minDist = NULL,
  maxDist = NULL
)

\S4method{distance}{GVector,GVector}(x, y, unit = "meters", minDist = NULL, maxDist = NULL)

\S4method{st_distance}{GVector,GVector}(x, y, unit = "meters", minDist = NULL, maxDist = NULL)
}
\arguments{
\item{x}{A \code{GRaster} or \code{GVector}.}

\item{y}{Either missing, or a \code{GVector}.}

\item{target}{Numeric: Only applicable for case 1, when \code{x} is a \code{GRaster} and \code{y} is missing.  If this is \code{NA} (default), then cells with \code{NA}s have their values replaced with the distance to the nearest non-\code{NA} cell. If this is another value, then cells with these values have their values replaced with the distance to any other cell (\code{NA} and non-\code{NA}, except for cells with this value).}

\item{fillNA}{Logical: Determines which raster cells to fill with distances.
\itemize{
\item Case 1, when \code{x} is a \code{GRaster} and \code{y} is missing: If \code{TRUE} (default), fill values of \code{NA} cells with distances to non-\code{NA} cells. If \code{FALSE}, fill non-\code{NA} cells width distance to \code{NA} cells.
\item Case 2, when \code{x} is a \code{GRaster} and \code{y} is a \code{GVector}: If \code{TRUE} (default), then the returned raster will contain the distance from the cell to the closest feature in the vector. If \code{FALSE}, then cells covered by the vector will have their values replaced with the distance to the nearest cell not covered, and cells that are not covered by the vector will have values of 0.
\item Case 3, when \code{x} is a \code{GVector} and \code{y} is a \code{GVector}: This argument is not used in this case.
}}

\item{unit}{Character: Units of the output. Either of \code{'meters'} or \verb{'kilometers' (or '}km'`). Partial matching is used.}

\item{method}{Character: The type of distance to calculate. Partial matching is used and capitalization is ignored. Possible values include:
\itemize{
\item \code{Euclidean} (default): Euclidean distance
\item \code{squared}: Squared Euclidean distance (faster than just Euclidean distance but same rank--good for cases where only order matters)
\item \code{maximum}: Maximum Euclidean distance
\item \code{geodesic}: Geographic distance
\item \code{Manhattan}: Manhattan distance (i.e., "taxicab" distance, distance along cells going only north-south and east-west and never along a diagonal).
}}

\item{minDist, maxDist}{Either \code{NULL} (default) or numeric values: Ignore distances less than or greater than these distances.}

\item{dense}{Logical: Only applicable for case 2, when \code{x} is a \code{GRaster} and \code{y} is a \code{GVector}. If \code{TRUE} (default), then the vector will be represented by "densified" lines (i.e., any cell that the line/boundary touches, not just the ones on the rendering path).}
}
\value{
If \code{x} is a \code{GRaster}, then the output is a \code{GRaster}. If \code{x} is a \code{GVector}, then the output is a numeric vector.
}
\description{
This function produces a raster or a matrix of geographic distances, depending on the input:

\strong{Case 1: Argument \code{x} is a \code{GRaster} and \code{y} is missing:} By default, this function replaces values in all \code{NA} cells with the distance between them and their closest non-\code{NA} cell. Alternatively, all non-\code{NA} cells can have their values replaced by the distance to \code{NA} cells. You can also specify which cells (by value) have their values replaced by distance to other cells.

\strong{Case 2: Argument \code{x} is a \code{GRaster} and \code{y} is a \code{GVector}:} All cells in the raster have their value replaced by the distance to the nearest features in the \code{GVector}. Alternatively, calculate the distance from any cell covered by a vector object and the nearest cell \emph{not} covered by a vector object. Note that the vector is rasterized first.

\strong{Case 3: Argument \code{x} is a \code{GVector} and \code{y} is a \code{GVector}:} A matrix of pairwise distances between all features in one versus the other \code{GVector} is returned.
}
\examples{
\dontrun{
# NB This example is in a "dontrun{}" block because it requires users to have
# GRASS GIS Version 8+ installed on their system.

# IMPORTANT #1: If you already have a GRASS session started, you will need to
# run the line below and the last line in this example to work with it again.
# If you have not started a GRASS session, you can skip this step and go to
# step #2.

# IMPORTANT #2: Select the appropriate line below and change as necessary to
# where GRASS is installed on your system.
grassDir <- "/Applications/GRASS-8.2.app/Contents/Resources" # Mac
grassDir <- 'C:/Program Files/GRASS GIS 8.2' # Windows
grassDir <- '/usr/local/grass' # Linux

# setup
library(sf)
library(terra)

# elevation raster, rivers vector, locations of Dypsis plants
madElev <- fastData('madElev')
madRivers <- fastData('madRivers')
madDypsis <- fastData('madDypsis')

# start GRASS session for examples only
wd <- forwardSlash(tempdir())

faster(crs = madElev, grassDir = grassDir,
workDir = wd, location = 'examples') # line only needed for examples

# convert a SpatRaster to a GRaster, and sf to a GVector
elev <- fast(madElev)
rivers <- fast(madRivers)
dypsis <- fast(madDypsis)

### case 1: GRaster by itself

# distance between NA cells and nearest non-NA cells
naDist <- distance(elev)
names(naDist) <- 'NA Distance'

# distance between non-NA cells and nearest NA cells
nonNaDist <- distance(elev, fillNA = FALSE)
names(nonNaDist) <- 'non-NA Distance'

# distance between cells with an elevation of 3 and any other cell that != 3
distFocal3 <- distance(elev, target = 3)
names(distFocal3) <- 'Distance from 3'

# distance between any cell and cells with a value of 3
distTo3 <- distance(elev, fillNA = FALSE, target = 3)
names(distTo3) <- 'Distance to 3'

naDistRast <- rast(naDist)
nonNaDistRast <- rast(nonNaDist)
distFocal3Rast <- rast(distFocal3)
distTo3Rast <- rast(distTo3)

plot(c(naDistRast, nonNaDistRast, distFocal3Rast, distTo3Rast))

### case 2: GRaster and GVector
distToVect <- distance(elev, rivers)
distToVectRast <- rast(distToVect)

plot(distToVectRast)
plot(st_geometry(madRivers), add=TRUE)

### case 3: GVector vs GVector
plot(st_geometry(madRivers))
plot(st_geometry(madDypsis), add = TRUE)

distToRivers <- distance(dypsis, rivers)
distToPlants <- distance(rivers, dypsis)
distToRivers
distToPlants

# IMPORTANT #3: Revert back to original GRASS session if needed.
sessionRestore(opts.)
removeSession('examples')

}
}
\seealso{
\code{\link[terra:distance]{terra::distance()}}; \code{\link[sf:geos_measures]{sf::st_distance()}}, \strong{GRASS} module \code{r.grow.distance}
}
