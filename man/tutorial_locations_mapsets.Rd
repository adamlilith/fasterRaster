% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tutorial_locations_mapsets.r
\name{tutorial_locations_mapsets}
\alias{tutorial_locations_mapsets}
\title{Locations and mapsets}
\description{
\strong{GRASS GIS} uses "locations" and "mapsets" to store files (rasters, vectors, etc.). \strong{fasterRaster} uses them, to, but invisibly to most users. Thus, this tutorial is mostly of interest to developers and other curious people.
\subsection{\strong{GRASS} locations}{

Upon starting, \strong{GRASS} creates (or loads) a location, which corresponds to a folder on the user's system. Importantly, all rasters and vectors in a location must have the same coordinate reference system (CRS). Confusingly, rasters and vectors in the same \strong{GRASS} location do not necessarily have to represent the same place on Earth. In general, rasters and vectors can only interact with one another if they are in the same location and mapset.  \strong{GRASS} can only have a connection to a single location at a time.

\strong{fasterRaster} handles locations and mapsets automatically, so users typically do not need to manage them. Locations are created on an as-needed basis. Within a given \strong{R} session, if no locations have been made, calling \code{\link[=fast]{fast()}} to create a \code{GRaster} or \code{GVector} will 1) make a connection to \strong{GRASS} and 2) create a location with a CRS the same as the raster or vector. The raster or vector is then stored in this location. \code{\link[=fast]{fast()}} starts the connection and creates the location using the exported by publicly undocumented function \code{.locationCreate()}.

If \code{\link[=fast]{fast()}} is called and a location already exists that has the same CRS as the raster or vector, one of two things will happen. First, if \strong{GRASS} is already connected to that location, the raster or vector is simply imported. Second, if \strong{GRASS} is not connected to the location that has the appropriate CRS, it will use \code{.locationRestore()} to connect to the proper one, then import the raster or vector.

Other functions might also cause \strong{GRASS} to connect to a pre-existing location. Generally, if a function is applied to a \code{GRaster} or \code{GVector}, it will first check to see that \strong{GRASS} is connected to the location in which the raster or vector is stored. If not, it will use \code{.locationRestore()} to do so first.

Creating a new location or switching connections to pre-existing locations adds a few seconds to processing time of rasters and vectors. To avoid this, users can work as much as possible on sets of rasters and vectors with the same CRS (i.e., the same location).
}

\subsection{\strong{FasterRaster} mapsets}{

\strong{GRAS} "mapsets" are sub-folders within a location. Every location \emph{must} have a mapset (and thus, a sub-folder) named "PERMANENT". Users of Mapsets are intended to store sub-projects that use rasters and vectors with the same CRS. Users of \strong{GRASS} can switch between mapsets. However, for ease-of-use and development, \strong{fasterRaster} always uses the "PERMANENT" mapset within a given location.
}

\subsection{Functions that manage locations and mapsets}{

These functions are exported but not publicly documented. You can, however, read the documentation by opening the development file (i.e., at the \strong{fasterRaster} GitHub \href{https://github.com/adamlilith/fasterRaster}{repository}). All functions take "\code{x}" as an argument.
\itemize{
\item \code{.location(x)}: Name of the location of \code{x} (a \strong{fasterRaster} object), or the current location (if \code{x} is missing).
\item \code{.locations()}: Names and CRSs of all available locations (takes no arguments).
\item \code{.locationCreate(x)}: Create a location with the same CRS as \code{x}.
\item \code{.locationRestore(x)}: Connect to a pre-existing location. \code{x} can be a \strong{fasterRaster} object, a \code{SpatRaster}, \code{SpatVector}, or \code{sf} object, or the name of a location.
\item \verb{.locationFind(x, return = <option>)}: Given a spatial object \code{x}, find the name, index, or CRS of a location that matches it. If \code{x} is missing, return a list of all locations. \verb{<option>} can be \code{"name"} (name of the location), \code{"index"} (index), or "\code{crs}" (coordinate reference string in WKT format).
\item \code{.ls()}: List all file names of rasters and/or vectors in the current location.
\item \code{.mapset(x)}: Name of the mapset that contains the object \code{x}.
}
}

\subsection{More rabbit-holing}{

\strong{fasterRaster} maintains a package-specific environment named \code{.fasterRaster}, where it keeps a list of locations at \code{.fasterRaster$locations}. This is a named list of locations, where each element is has the name of the location, and the value of the element is the location's CRS. The current location is tracked at \code{.fasterRaster$activeLocation}.
}
}
\examples{
if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev <- fastData("madElev")
madForest2000 <- fastData("madForest2000")
madCoast0 <- fastData("madCoast0")
madRivers <- fastData("madRivers")
madDypsis <- fastData("madDypsis")

### GRaster properties
######################

# convert SpatRasters to GRasters
elev <- fast(madElev)
forest <- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# information on the GRASS session in which the GRaster is located
location(elev) # location
mapset(elev) # mapset

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy <- elev
copy[] <- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts <- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) <- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] <- elev > 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) <- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties
######################

# convert sf vectors to GVectors
coast <- fast(madCoast4)
rivers <- fast(madRivers)
dypsis <- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent
bottom(rivers) # bottom extent

# coordinate reference system
crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# session information
location(rivers) # GRASS location
mapset(rivers) # GRASS mapset

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
update(elev)

### operations on GVectors
##########################

# convert to data frame
as.data.frame(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2] # row/geometry 1 and column 1
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers <- update(rivers)

# Concatenating multiple vectors
rivers2 <- c(rivers, rivers)
dim(rivers)
dim(rivers2)

}
}
\keyword{tutorial}
