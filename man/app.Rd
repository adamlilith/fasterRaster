% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app.r
\name{app,GRaster-method}
\alias{app,GRaster-method}
\alias{app}
\alias{appFuns,logical-method}
\alias{appFuns}
\alias{appCheck,GRaster,character-method}
\alias{appCheck}
\title{Apply a function to a set of rasters}
\usage{
\S4method{app}{GRaster}(x, fun, ensure = "auto", seed = NULL)

\S4method{appFuns}{logical}(show = FALSE)

\S4method{appCheck}{GRaster,character}(x, fun, msgOnGood = TRUE, failOnBad = TRUE)
}
\arguments{
\item{x}{A \code{GRaster} with one or more named layers.}

\item{fun}{Character: The function to apply. This must be written as a character string that follows these rules:
\itemize{
\item It must begin with an equals sign ("\code{=}"").
\item It must use typical arithmetic operators like \code{+}, \code{-}, \code{*}, \code{/} and/or functions that can be seen using \code{appFuns(TRUE)}.
\item It has no functions that have the same names as the \code{\link[=names]{names()}} of any of the raster layers. Note that \code{x} and \code{y} are forbidden names :(
The help page for \code{r.mapcalc} on the \strong{GRASS} website provides more details.
}}

\item{ensure}{Character: This ensures that rasters are treated as a certain type before they are operated on. This is useful when using rasters that have all integer values, which \strong{GRASS} can assume represent integers, even if they are not supposed to. In this case, the output of operations on this raster might be an integer if otherwise not corrected. Partial matching is used, and options include:
\itemize{
\item \code{"integer"}: Force all rasters to integers by truncating their values. The output may still be of type \code{float} if the operation creates non-integer values.
\item \code{"float"}: Force rasters to be considered floating-point values.
\item \code{"double"}: Force rasters to be considered double-floating point values.
\item \code{"auto"} (default): Ensure that rasters are represented by their native \code{\link[=datatype]{datatype()}} (i.e., "CELL" rasters as integers, "FCELL" rasters as floating-point, and "DCELL" as double-floating point).
}}

\item{seed}{Numeric integer vector or \code{NULL} (default): A number for the random seed. Used only for \code{app()} function \code{rand()}, that generates a random number. If \code{NULL}, a seed will be generated. Defining the seed is useful for replicating a raster made with \code{rand()}. This must be an integer!}

\item{show}{Logical (function \code{appFuns()}):
\itemize{
\item \code{FALSE} (default): Return a \code{data.frame} or \code{data.table} with definitions of functions.
\item \code{TRUE}: Open a searchable, sortable \strong{shiny} table in a browser.
}}

\item{msgOnGood}{Logical (function \code{appCheck()}): If \code{TRUE} (default), display a message if no overt problems with the raster names and formula are detected.}

\item{failOnBad}{Logical (function \code{appCheck()}): If \code{TRUE} (default), fail if overt problems with raster names and the formula are detected.}
}
\value{
A \code{GRaster}.
}
\description{
\code{app()} applies a function to a set of "stacked" rasters. \code{appFuns()} provides a table of \strong{GRASS} functions and their equivalent \strong{R} function. \code{appCheck()} tests whether a formula supplied to \code{app()} has any "forbidden" function calls.

\code{app()} function operates in a manner slightly different from \code{\link[terra:app]{terra::app()}}. The function to be applied \emph{must} be written as a character string. For example, if the raster had layer names "\code{x1}" and "\code{x2}", then the function might be like \code{"= max(sqrt(x1), log(x2))"}. Rasters \strong{cannot} have the same names as functions used in the formula. In this example, the rasters could not be named "max", "sqrt", or "log".

The \code{app()} function will automatically check for raster names that appear also to be functions that appear in the formula, but the \code{appCheck()} function can be applied to the raster stack plus the formula to do this outside of \code{app()}. You can obtain a list of functions using \code{appFuns()}. Note that these are sometimes different from how they are applied in \strong{R}.

TIPS:
\itemize{
\item In \strong{GRASS}, \code{null()} is the same as \code{NA} in \strong{R}.
\item If you want to calculate values using while removing \code{NA} (or \code{null}) values, see the functions that begin with \code{n} (like \code{nmean}).
\item Be mindful of the data type that a function returns. In \strong{GRASS}, these are \code{CELL} (integer), \code{FCELL} (floating point values--precise to about the 7th decimal place), and \code{DCELL} (double-floating point values--precise to about the 15th decimal place). In cases where you want to ensure a raster to be treated like a float or double data type raster, wrap the raster in the \code{float()} or \code{double()} functions to ensure it is treated as such. This is especially useful if the raster might be assumed to be the \code{CELL} type because it only contains integer values. You can get the data type of a raster using \code{\link[=datatype]{datatype()}}. You can change the data type of a \code{GRaster} using \code{\link[=as.int]{as.int()}}, \code{\link[=as.float]{as.float()}}, and \code{\link[=as.doub]{as.doub()}}. Note that \link[=tutorial_raster_data_types]{categorical} are really \code{CELL} rasters with an associated "levels" table. You can also change a \code{CELL} raster to a \code{FCELL} raster by adding then subtracting a decimal value, as in \code{x - 0.1 + 0.1}.
\item The \code{rand()} function returns \code{CELL} (integer) values by default. If you want non-integer values, use the tricks mentioned above to ensure non-integer values. For example, the \code{\link[=runifRast]{runifRast()}} function's expression is (essentially) \verb{= float(rand(0 + 0.1, 1 + 0.1) - 0.1)}
}
}
\examples{
\dontrun{
# NB This example is in a "dontrun{}" block because it requires users to have
# GRASS GIS Version 8+ installed on their system.

# IMPORTANT #1: If you already have a GRASS session started, you will need to
# run the line below and the last line in this example to work with it again.
# If you have not started a GRASS session, you can skip this step and go to
# step #2.
opts. <- getFastOptions()

# IMPORTANT #2: Select the appropriate line below and change as necessary to
# where GRASS is installed on your system.
grassDir <- "/Applications/GRASS-8.3.app/Contents/Resources" # Mac
grassDir <- "C:/Program Files/GRASS GIS 8.3" # Windows
grassDir <- "/usr/local/grass" # Linux

# Setup
library(terra)

# Elevation raster
madElev <- fastData("madElev")

# Start GRASS session for examples only:
faster(x = madElev, grassDir = grassDir,
workDir = tempdir(), location = "examples") # line only needed for examples

# Convert SpatRaster to a GRaster:
elev <- fast(madElev)

# Create a "stack" of rasters for us to operate on:
x <- c(elev, elev^2, sqrt(elev))

# Demonstrate check for badly-named rasters:
names(x) <- c("cos", "asin", "exp")
fun <- "= cos / asin + exp"
appCheck(x, fun, failOnBad = FALSE)

# Rename rasters acceptable names and run the function:
names(x) <- c("x1", "x2", "x3")
fun <- "= (x1 / x2) + x3"
appCheck(x, fun, failOnBad = FALSE)
app(x, fun = fun)

# This is the same as:
(x[[1]] / x[[2]]) + x[[3]]

# We can view a Shiny table using appFuns():
appFuns()

# This is the same as:
data(appFunsTable)

# Apply other functions:
fun <- "= median(x1 / x2, x3, x1 * 2, cos(x2))"
app(x, fun = fun)

fun <- "= round(x1) * tan(x2) + log(x3, 10)"
app(x, fun = fun)

# Demonstrate effects of data type. The "+" sign does not guarantee
# output is of a given type, and the rasters are coerced to integers before
# the operation is conducted in the second function.
fun <- "= x1 + x3"
app(x, fun = fun, ensure = "float") # output is floating-point
app(x, fun = fun, ensure = "integer") # output is integer

# Some functions override the "ensure" argument. In this case, the output will
# not be an integer because the sin() function returns a float value.
fun <- "= sin(x2)"
app(x, fun = fun, ensure = "integer")

# Make a raster with random numbers between 1 and 4, with equal probability
# of each:
fun <- "= round(rand(0.5, 4.5))"
rand <- app(elev, fun = fun)
rand

freq(rand) # cell frequencies

# IMPORTANT #3: Revert back to original GRASS session if needed.
fastRestore(opts.)
removeSession("examples")

}
}
\seealso{
\code{\link[terra:app]{terra::app()}}, and modules \code{r.mapcalc} and \code{r.mapcalc.simple} in \strong{GRASS}.
}
