% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tutorial_raster_data_types.r
\name{tutorial_raster_data_types}
\alias{tutorial_raster_data_types}
\title{Raster data types}
\description{
\strong{fasterRaster} \code{GRaster}s can represent three numeric data types and one categorical type.
\subsection{Integers}{

Rasters that represent integers are called "integer" rasters in \strong{fasterRaster} and \code{CELL} rasters in \strong{GRASS}. You can force a raster to be an integer using \code{\link[=as.int]{as.int()}}. Some of the functions in \code{\link[=app]{app()}} function will also return integer-type rasters. Integer rasters typically take the least memory.
}

\subsection{Floating-point values}{

Floating-point values are accurate to about the 6th to 9th decimal place. These are called "float" rasters in \strong{fasterRaster} and \code{FCELL} rasters in \strong{GRASS}. By default, operations conducted using raster math (e.g., \code{raster1 * raster2}) return double floating-point valued rasters, but this can be changed to floating point precision using \code{\link[=setFastOptions]{setFastOptions()}} (e.g., \code{setFastOptions(rasterDataType = "float")}). Floating-point rasters typically take more memory than integer rasters, but less than double-floating point rasters.
}

\subsection{Double-floating point values}{

Double-floating point values are accurate to about the 15th to 17th decimal place. These are called "double" rasters in \strong{fasterRaster} and \code{DCELL} rasters in \strong{GRASS}. These rasters typically take the most memory. All "\code{numeric}" values in \strong{R} are double-floating point values. \strong{R} does not use single floating-point values.
}

\subsection{Categorical rasters}{

Categorical rasters (also called "factor" rasters) are actually integer rasters, but have an associated attribute table that maps each integer value to a category label, such as "wetland" or "forest". The table has at least two columns. The first is integer values, and (by default) the second is category names. This second column is the "active" category column, but can be changed using \link{activeCat<-}.
}

\subsection{Functions relevant to raster data types}{
\itemize{
\item \code{\link[=activeCat]{activeCat()}} and \verb{[activeCat<-]} can be used to see or assign which column in a "levels" table associated with a categorical raster is used as category labels.
\item \code{\link[=addCats]{addCats()}} adds information to the "levels" table using \code{\link[data.table:merge]{data.table::merge()}} (same as \code{\link[=merge]{merge()}}).
\item \verb{[addCats<-]} add new levels to a "levels" table.
\item \code{\link[=as.int]{as.int()}}, \code{\link[=as.float]{as.float()}}, and \code{\link[=as.doub]{as.doub()}} coerce a raster to an integer, float, or double.
\item \code{\link[=catNames]{catNames()}} reports the column names of the "levels" table of each layer of a raster.
\item \code{\link[=cats]{cats()}} returns the entire "levels" table of a categorical raster.
\item \code{\link[=datatype]{datatype()}} returns the data type of a \code{GRaster}.
\item \code{\link[=droplevels]{droplevels()}} removes "unused" levels in a "levels" table.
\item \code{\link[=freq]{freq()}}: Frequency of each category across cells of a raster\cr
\item \code{\link[=is.factor]{is.factor()}} indicates if the raster is a categorical raster.
\item \code{\link[=levels]{levels()}} returns the "levels" table of a categorical raster (just the value column and the active column).
\item \verb{[levels<-]} and \code{\link[=categories]{categories()}} can be used to assign categories to an integer raster and make it categorical (i.e., a "factor" raster).
\item \code{\link[=missingCats]{missingCats()}} finds values in categorical rasters that do not have a category assigned to them.
\item \code{\link[=nlevels]{nlevels()}} returns the number of levels represented by a categorical raster.
}
}

\subsection{Saving rasters to disk}{

You can save substantial space on disk if you set the \code{datatype} argument in \code{\link[=writeRaster]{writeRaster()}} when saving a raster. This argument allows for finer "divisions" than just integer/float/double-float, so depending on the range of values in your raster, you can optimize file size by selecting the one that best matches the values in the raster. See the documentation for \code{\link[=writeRaster]{writeRaster()}} for more information.\tabular{lllll}{
   \strong{\code{fasterRaster}} \tab \strong{\code{terra}} \tab \strong{\code{GRASS}} \tab \strong{\code{GDAL}} \tab \strong{Values} \cr
   \code{integer} \tab \code{INT1U} \tab \code{CELL} \tab \code{Byte} \tab Integer values from 0 to 255 \cr
   \code{integer} \tab \code{INT2U} \tab \code{CELL} \tab \code{UInt16} \tab Integer values from 0 to 65,534 \cr
   \code{integer} \tab \code{INT2S} \tab \code{CELL} \tab \code{Int16} \tab Integer values from -32,767 to -32,767 \cr
   \code{integer} \tab \code{INT4S} \tab \code{CELL} \tab \code{Int32} \tab Integer values from -2,147,483,647 to 2,147,483,647 \cr
   \code{float} \tab \code{FLT4S} \tab \code{FCELL} \tab \code{Float32} \tab Values from -3.4e+38 to 3.4e+38, including decimal values \cr
   \code{double} \tab \code{FLT8S} \tab \code{DCELL} \tab \code{Float64} \tab Values from -1.7e+308 to 1.7e+308, including decimal values \cr
   \code{factor} \tab \code{INT}* \tab \code{CELL} \tab * \tab Integer values corresponding to categories \cr
}


\code{*} Depends on the integers (signed/unsigned, range of values)
}
}
\examples{
\dontrun{
# NB This example is in a "dontrun{}" block because it requires users to have
# GRASS GIS Version 8+ installed on their system.

# IMPORTANT #1: If you already have a GRASS session started, you will need to
# run the line below and the last line in this example to work with it again.
# If you have not started a GRASS session, you can skip this step and go to
# step #2.
opts. <- getFastOptions()

# IMPORTANT #2: Select the appropriate line below and change as necessary to
# where GRASS is installed on your system.
grassDir <- "/Applications/GRASS-8.3.app/Contents/Resources" # Mac
grassDir <- "C:/Program Files/GRASS GIS 8.3" # Windows
grassDir <- "/usr/local/grass" # Linux

# setup
library(sf)
library(terra)

# example data
madElev <- fastData("madElev")
madCoast0 <- fastData("madCoast0")
madRivers <- fastData("madRivers")
madDypsis <- fastData("madDypsis")

# start GRASS session for examples only
faster(x = madElev, grassDir = grassDir,
workDir = tempdir(), location = "examples") # line only needed for examples

### GRaster properties
######################

# convert SpatRasters to GRasters
elev <- fast(madElev)
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# information on the GRASS session in which the GRaster is located
location(elev) # location
mapset(elev) # mapset

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)
st_crs(elev)

# extent (bounding box)
ext(elev)
st_bbox(elev)

# data type
datatype(elev)

# assigning
copy <- elev
copy[] <- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts <- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) <- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["forest"]]

# assigning
rasts[[4]] <- elev > 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) <- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties
######################

# convert sf vectors to GVectors
coast <- fast(madCoast4)
rivers <- fast(madRivers)
dypsis <- fast(madDypsis)

# extent
ext(rivers)
st_bbox(rivers) # extent

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent
bottom(rivers) # bottom extent

# coordinate reference system
crs(rivers)
st_crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# session information
location(rivers) # GRASS location
mapset(rivers) # GRASS mapset

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# refresh values from GRASS
# (reads values from GRASS... does not appear to do anything in this case)
refresh(elev)

### operations on GVectors
##########################

# convert to data frame
as.data.frame(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 geometries
rivers[-5:-11] # reverse select
rivers[ , 1] # columns
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 1] # rows and columns
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers <- refresh(rivers)

# Concatenating multiple vectors
rivers2 <- c(rivers, rivers)
dim(rivers)
dim(rivers2)

# IMPORTANT #3: Revert back to original GRASS session if needed.
restoreSession(opts.)
removeSession("examples")

}
}
\keyword{tutorial}
