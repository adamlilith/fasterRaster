% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/project.r
\name{project,GRaster-method}
\alias{project,GRaster-method}
\alias{project}
\alias{project,GVector-method}
\title{Change the coordinate reference system of a GRaster or GVector}
\usage{
\S4method{project}{GRaster}(
  x,
  y = NULL,
  align = FALSE,
  method = NULL,
  fallback = TRUE,
  wrap = FALSE
)

\S4method{project}{GVector}(x, y = NULL)
}
\arguments{
\item{x}{A \code{GRaster} or \code{GVector} to be projected.}

\item{y}{A character or \code{GLocation} object (i.e., typically a \code{GRaster} or \code{GVector}):
\itemize{
\item If \code{x} is a \code{GRaster} and \code{y} is a character string representing a coordinate reference system in WKT format, the raster will be projected but not resampled.
\item If \code{x} is a \code{GRaster} and \code{y} is a \code{GRaster} or \code{GRegion}, then \code{x} will be projected to the CRS of \code{y} and resampled to the same resolution as \code{y}. \code{x} will be cropped to the extent of \code{y} if \code{align} is \code{TRUE}.
\item If \code{x} is a \code{GRaster} and \code{y} is a \code{GVector}, then \code{x} will be projected to the CRS of \code{y}. \code{x} will not be resampled.
\item If \code{x} is a \code{GVector}, then \code{x} will be projected to the CRS of \code{y}.
}}

\item{align}{Logical: If \code{FALSE} (default), and \code{x} and \code{y} are \code{GRaster}s, then the extent of \code{x} will be cropped to the extent of \code{y}.}

\item{method}{Character or \code{NULL} (\code{GRaster}s only): Method to use to conduct the transformation (rasters only). Partial matching is used.
\itemize{
\item \code{NULL} (default): Automatically choose based on raster properties (\code{near} for categorical data, \code{bilinear} for continuous data).
\item \code{"near"}: Nearest neighbor. Best for categorical data, and often a poor choice for continuous data.  If \code{\link[=datatype]{datatype()}} is \code{integer}, this method will be used by default.
\item \code{"bilinear"}: Bilinear interpolation (default for non-categorical data; uses weighted values from 4 cells).
\item \code{"bicubic"}: Bicubic interpolation (uses weighted values from 16 cells).
\item \code{"lanczos"}: Lanczos interpolation (uses weighted values from 25 cells).
}

\emph{Note #1}: If \code{x} and \code{y} are \code{GRaster}s, then the same \code{method} is used to resample \code{x} to the resolution of \code{y} before projecting \code{x}.

\emph{Note #2}: Methods that use multiple cells will cause the focal cell to become \code{NA} if there is at least one cell with an \code{NA} in the cells it draws from. These \code{NA} cells can often be filled using the \code{fallback} option.}

\item{fallback}{Logical (projecting \code{GRaster}s only): If \code{TRUE} (default), then use "lower" methods to fill in \code{NA} cells when a "higher" method is used. For example, if \code{method = "bicubic"}, \code{NA} cells will be filled in using the \code{bilinear} method, except when that results in \code{NA}s, in which case the \code{near} method will be used. Fallback causes fewer cells to revert to \code{NA} values, so may be better at capturing complex "edges" (e.g., coastlines). Fallback does increase processing time because each "lower" method must be applied, then results merged. Fallback is not used if \code{method = "near"}.}

\item{wrap}{Logical (\code{GRaster}s only): When projecting rasters that "wrap around" (i.e., whole-world rasters or rasters that have edges that actually circle around to meet on the globe), \code{wrap} should be \code{TRUE} to avoid removing rows and columns from the "edge" of the map. The default is \code{FALSE}.}
}
\value{
A \code{GRaster} or \code{GVector}.
}
\description{
\strong{fasterRaster} offers three ways to project rasters and vectors into a different coordinate reference system (CRS). Each of these ways are different from how they are implemented in \strong{terra}, so it is important to understand how it works in \strong{fasterRaster}.

\strong{Case #1: Changing the CRS for a \code{SpatRaster}, \code{SpatVector}, or \code{sf} object already in R}: Use the \code{\link[=fast]{fast()}} function. This function will project the object to the CRS of the current \strong{GRASS} \link[=tutorial_locations_mapsets]{location}. Note that for rasters, the \code{method}, \code{fallback}, and \code{wrap} arguments in the \code{fast()} function may be important to what you want to achieve.

\strong{Case #2: Change the projection of rasters or vectors stored on disk}: Simply use the \code{\link[=fast]{fast()}} function with the file name of the object. Again, the \code{method}, \code{fallback}, and \code{wrap} arguments may be important .

**Case #3: Change the CRS of a \code{GRaster} or \code{GVector}: Use the \code{project()} function (this function). First, initiate a new \strong{GRASS} \link[=tutorial_locations_mapsets]{location} using \code{\link[=faster]{faster()}} with the CRS to which you want to transform the object. This means you need to keep track of which \strong{GRASS} "location" in which you are working.  Second, apply this function. If you want to return to the original "location," use \code{location('original_location_name')}. You can get the name of the current location with \code{\link[=location]{location()}} (with no arguments), and its coordinate reference system with \code{\link[=crs]{crs()}} or \code{\link[=st_crs]{st_crs()}} (also no arguments).
}
\details{
When projecting a raster, the "fallback" methods in \strong{GRASS} module \code{r.import} are actually used, even though the \code{method} argument takes the strings specifying non-fallback methods. See the manual page for the \code{r.import} \strong{GRASS} module.
}
\examples{
if (grassStarted()) {

### Setup for all examples
##########################

library(sf)
library(terra)

# Climate raster, elevation raster, rivers vector
madElev <- fastData("madElev")
madRivers <- fastData("madRivers")
madChelsa <- fastData("madChelsa")

# Convert objects into fasterRaster formats
chelsa <- fast(madChelsa)
elev <- fast(madElev)
rivers <- fast(madRivers)

### Project raster without resampling
elevWGS84 <- project(elev, crs(chelsa))
elevWGS84

### Project raster and resample to resolution of another raster
elevWGS84Resamp <- project(elev, chelsa)
elevWGS84Resamp

res(elevWGS84)
res(elevWGS84Resamp)
res(chelsa)

### Project vector
riversWGS84 <- project(rivers, chelsa)
riversWGS84
cat(crs(rivers)) # using "cat()" to make it look nice
cat(crs(riversWGS84))

}
}
\seealso{
\code{\link[terra:project]{terra::project()}}, \code{\link[sf:st_transform]{sf::st_transform()}}, modules \code{r.proj} and \code{v.proj} in \strong{GRASS}
}
