% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/project.r
\name{project,GRaster-method}
\alias{project,GRaster-method}
\alias{project}
\alias{project,GVector-method}
\title{Change the coordinate reference system of a GRaster or GVector}
\usage{
\S4method{project}{GRaster}(
  x,
  y = NULL,
  align = FALSE,
  method = NULL,
  fallback = TRUE,
  wrap = FALSE
)

\S4method{project}{GVector}(x, y = NULL)
}
\arguments{
\item{x}{A \code{GRaster} or \code{GVector} to be projected.}

\item{y}{A character or \code{GLocation} object (i.e., typically a \code{GRaster} or \code{GVector}):}

\item{align}{Logical: If \code{FALSE} (default), and \code{x} and \code{y} are \code{GRaster}s, then the extent of \code{x} will be cropped to the extent of \code{y}.}

\item{method}{Character or \code{NULL} (\code{GRaster}s only): Method to use to conduct the transformation (rasters only). Partial matching is used.
\itemize{
\item \code{NULL} (default): Automatically choose based on raster properties (\code{near} for categorical data, \code{bilinear} for continuous data).
\item \code{"near"}: Nearest neighbor. Best for categorical data, and often a poor choice for continuous data.  If \code{\link[=datatype]{datatype()}} is \code{integer}, this method will be used by default.
\item \code{"bilinear"}: Bilinear interpolation (default for non-categorical data; uses weighted values from 4 cells).
\item \code{"bicubic"}: Bicubic interpolation (uses weighted values from 16 cells).
\item \code{"lanczos"}: Lanczos interpolation (uses weighted values from 25 cells).
}

\emph{Note #1}: If \code{x} and \code{y} are \code{GRaster}s, then the same \code{method} is used to resample \code{x} to the resolution of \code{y} before projecting \code{x}.

\emph{Note #2}: Methods that use multiple cells will cause the focal cell to become \code{NA} if there is at least one cell with an \code{NA} in the cells it draws from. These \code{NA} cells can often be filled using the \code{fallback} option.}

\item{fallback}{Logical (projecting \code{GRaster}s only): If \code{TRUE} (default), then use "lower" methods to fill in \code{NA} cells when a "higher" method is used. For example, if \code{method = "bicubic"}, \code{NA} cells will be filled in using the \code{bilinear} method, except when that results in \code{NA}s, in which case the \code{near} method will be used. Fallback causes fewer cells to revert to \code{NA} values, so may be better at capturing complex "edges" (e.g., coastlines). Fallback does increase processing time because each "lower" method must be applied, then results merged. Fallback is not used if \code{method = "near"}.}

\item{wrap}{Logical (\code{GRaster}s only): When projecting rasters that "wrap around" (i.e., whole-world rasters or rasters that have edges that actually circle around to meet on the globe), \code{wrap} should be \code{TRUE} to avoid removing rows and columns from the "edge" of the map. The default is \code{FALSE}.}
}
\value{
A \code{GRaster} or \code{GVector}.
}
\description{
\code{project()} changes the coordinate reference system (CRS) of a \code{GRaster} or \code{GVector}. It has three use cases:
\itemize{
\item \code{x} is a \code{GRaster} and \code{y} is a \code{GRaster}: \code{x} will be projected to the CRS of \code{y} and resampled to have the same resolution as \code{y}. If argument \code{align} is \code{FALSE}, then it will also be cropped to the extent of \code{y}.
\item \code{x} is a \code{GRaster} and \code{y} is a \code{GVector} or a CRS string (typically in WKT format): \code{x} will be projected to the CRS specified by \code{y} but not resampled or cropped.
\item \code{x} is a \code{GVector} and \code{y} is a \code{GRaster}, \code{GVector}, or CRS string: The vector will be projected to the CRS of \code{y}.
}
}
\details{
When projecting a raster, the "fallback" methods in \strong{GRASS} module \code{r.import} are actually used, even though the \code{method} argument takes the strings specifying non-fallback methods. See the manual page for the \code{r.import} \strong{GRASS} module.
}
\examples{
if (grassStarted()) {

### Setup for all examples
##########################

library(sf)
library(terra)

# Climate raster, elevation raster, rivers vector
madElev <- fastData("madElev")
madRivers <- fastData("madRivers")
madChelsa <- fastData("madChelsa")

# Convert objects into fasterRaster formats
chelsa <- fast(madChelsa)
elev <- fast(madElev)
rivers <- fast(madRivers)

### Project raster without resampling
elevWGS84 <- project(elev, crs(chelsa))
elevWGS84

### Project raster and resample to resolution of another raster
elevWGS84Resamp <- project(elev, chelsa)
elevWGS84Resamp

res(elevWGS84)
res(elevWGS84Resamp)
res(chelsa)

### Project vector
riversWGS84 <- project(rivers, chelsa)
riversWGS84
cat(crs(rivers)) # using "cat()" to make it look nice
cat(crs(riversWGS84))

}
}
\seealso{
\code{\link[terra:project]{terra::project()}}, \code{\link[sf:st_transform]{sf::st_transform()}}, modules \code{r.proj} and \code{v.proj} in \strong{GRASS}
}
