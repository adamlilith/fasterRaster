% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tutorial_vector_topology.r
\name{tutorial_vector_topology}
\alias{tutorial_vector_topology}
\title{Vector topology}
\description{
\strong{GRASS} uses a "topological" model for vectors. Topologically correct vectors have several properties, which mainly apply to polygon (\strong{GRASS}: "area") vectors:
\itemize{
\item Boundaries of polygons do not cross (lines can cross one another, though).
\item Shared boundaries of polygons are only represented once in the vector.
}

There are other properties involving combinations of lines and polygons in the same vector, but \strong{fasterRaster} does not allow shapes of different types in the same vector.

By default \strong{GRASS} (not \strong{fasterRaster}) corrects vector topology when loading vectors using the \code{v.in.ogr} module. Owing to the stipulation that shared boundaries are represented only once, polygons read into \strong{GRASS} polygons created in other software are often topologically incorrect. For example, the borders of adjacent polygons may cross one another, or there may be small gaps between them. The \code{v.in.ogr} module will try to correct these errors by creating "slivers" where two adjacent polygons slightly overlap, or (optionally), by snapping vertices that are close to one another together. Topologically incorrect lines can be corrected by creating "dangles" in places where line terminuses do not match exactly.

By default, \strong{fasterRaster} will \emph{not} correct topological errors when creating a \code{GVector} with \code{\link[=fast]{fast()}}. This is a design decision based on the fact that \code{\link[terra:vect]{terra::vect()}} does not correct topology, and to the degree possible, \strong{fasterRaster} tries to emulate \strong{terra}. Not correcting topology also has the advantage of loading vectors faster. It also obviates issues matching a vector's data table to each feature. For example, if two polygons overlap slightly, correcting the topology could create a sliver that represents the area of overlap. It is unclear which row of a data table this sliver should match.
\subsection{Turning topology correction on or off}{

You can control topology correction in two ways:
\itemize{
\item First, you can turn topology correction on or off for all uses of \code{\link[=fast]{fast()}} using the \code{correct} setting in \code{\link[=faster]{faster()}}. For example, \code{faster(correct = TRUE)} turns topology correction on, and \code{faster(correct = FALSE)} turns it off. By default, the \code{correct} option is set to \code{FALSE} (no topology correction).
\item Second, you turn topology correction on or off on a case-by-case basis using the \code{correct} argument when using the \code{\link[=fast]{fast()}} function. This overrides the option set by \code{faster()}.
}
}

\subsection{Correcting topology}{
\enumerate{
\item Automatic basic correction while creating a \code{GVector}: You can set the \code{correct} argument in \code{\link[=fast]{fast()}} to \code{TRUE} to correct issues on a case-by-case basis, or set the \code{correct} option in \code{\link[=faster]{faster()}} to \code{TRUE} to correct issues every time you use \code{\link[=fast]{fast()}}.
}

2a. Manual correction while creating a \code{GVector}: Regardless of the value of \code{correct}, you can also use the \code{snap} and/or \code{area} arguments in \code{\link[=fast]{fast()}} to correct topological issues by snapping nearby vertices to one another and/or removing polygons with areas that are smaller than some threshold.

2b. Automatic advanced correction while creating a \code{GVector}: You can also attempt automatic snapping and/or area removal. To do this, set \code{snap} and/or \code{area} to \code{NULL}, and also define the \code{iter} argument to an integer >1. When using automatic correction, \code{fast()} will first try to load the vector without snapping or area removal. If this does not work, it will then use an automated procedure to increase the value(s) or \code{snap} and/or \code{area}, load the vector, and repeat, until either the vector is loaded or \code{iter} attempts have been made.
\enumerate{
\item After creating a \code{GVector}: You can apply the \link[=breakPolys]{various tools} to can snap, remove areas, delete dangles and too-small angles, and do several other tasks related to cleaning vectors, plus \code{\link[=fillHoles]{fillHoles()}}.
}

Although not really a cleaning tool, you can use \code{\link[=simplifyGeom]{simplifyGeom()}} or \code{\link[=smoothGeom]{smoothGeom()}} to reduce the complexity of vector geometries.
}
}
\examples{
if (grassStarted()) {

# Setup
library(sf)
library(terra)

# Example data
madElev <- fastData("madElev")
madForest2000 <- fastData("madForest2000")
madCoast0 <- fastData("madCoast0")
madRivers <- fastData("madRivers")
madDypsis <- fastData("madDypsis")

### GRaster properties
######################

# convert SpatRasters to GRasters
elev <- fast(madElev)
forest <- fast(madForest2000)

# plot
plot(elev)

dim(elev) # rows, columns, depths, layers
nrow(elev) # rows
ncol(elev) # columns
ndepth(elev) # depths
nlyr(elev) # layers

res(elev) # resolution

ncell(elev) # cells
ncell3d(elev) # cells (3D rasters only)

topology(elev) # number of dimensions
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

minmax(elev) # min/max values

# information on the GRASS session in which the GRaster is located
location(elev) # location
mapset(elev) # mapset

# "names" of the object
names(elev)

# coordinate reference system
crs(elev)

# extent (bounding box)
ext(elev)

# data type
datatype(elev)

# assigning
copy <- elev
copy[] <- pi # assign all cells to the value of pi
copy

# concatenating multiple GRasters
rasts <- c(elev, forest)
rasts

# adding a raster "in place"
add(rasts) <- ln(elev)
rasts

# subsetting
rasts[[1]]
rasts[["madForest2000"]]

# assigning
rasts[[4]] <- elev > 500

# number of layers
nlyr(rasts)

# names
names(rasts)
names(rasts) <- c("elev_meters", "forest", "ln_elev", "high_elevation")
rasts

### GVector properties
######################

# convert sf vectors to GVectors
coast <- fast(madCoast4)
rivers <- fast(madRivers)
dypsis <- fast(madDypsis)

# extent
ext(rivers)

W(rivers) # western extent
E(rivers) # eastern extent
S(rivers) # southern extent
N(rivers) # northern extent
top(rivers) # top extent
bottom(rivers) # bottom extent

# coordinate reference system
crs(rivers)

# column names and data types
names(coast)
datatype(coast)

# session information
location(rivers) # GRASS location
mapset(rivers) # GRASS mapset

# points, lines, or polygons?
geomtype(dypsis)
geomtype(rivers)
geomtype(coast)

is.points(dypsis)
is.points(coast)

is.lines(rivers)
is.lines(dypsis)

is.polygons(coast)
is.polygons(dypsis)

# dimensions
nrow(rivers) # how many spatial features
ncol(rivers) # hay many columns in the data frame

# 2- or 3D
topology(rivers) # dimensionality
is.2d(elev) # is it 2D?
is.3d(elev) # is it 3D?

# Update values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case)
update(elev)

### operations on GVectors
##########################

# convert to data frame
as.data.frame(rivers)

# subsetting
rivers[c(1:2, 5)] # select 3 rows/geometries
rivers[-5:-11] # remove rows/geometries 5 through 11
rivers[ , 1] # column 1
rivers[ , "NAM"] # select column
rivers[["NAM"]] # select column
rivers[1, 2] # row/geometry 1 and column 1
rivers[c(TRUE, FALSE)] # select every other geometry (T/F vector is recycled)
rivers[ , c(TRUE, FALSE)] # select every other column (T/F vector is recycled)

# removing data table
noTable <- dropTable(river)
noTable
nrow(rivers)
nrow(noTable)

# Refresh values from GRASS
# (Reads values from GRASS... will not appear to do anything in this case
# since the rivers object is up-to-date):
rivers <- update(rivers)

# Concatenating multiple vectors
rivers2 <- c(rivers, rivers)
dim(rivers)
dim(rivers2)

}
}
\keyword{tutorial}
