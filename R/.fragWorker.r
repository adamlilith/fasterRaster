#' Worker function for calculating raster fragmentation statistics in parallel
#'
#' This function is meant as a worker function for multi-core calculation of raster fragmentation statistics. It is intended to be used by other functions and thus is not likely to be of use to normal users.
#' @param x Raster with binary values (1 or 0 or \code{NA}).
#' @param i Integer, block number of \code{x}.
#' @param clustBlockSize List with three elements: \code{row}, \code{nrows}, and \code{n} (can be generated by \code{\link[raster]{blockSize}}).
#' @param size Integer, number of cells wide and high of the window used to calculate fragmentation. This must be an odd integer (default is 3).
#' @param calcDensity Logical, if \code{TRUE} (default) then calculate density raster.
#' @param calcConnect Logical, if \code{TRUE} (default) then calculate connectivity raster.
#' @param calcConnect Logical, if \code{TRUE} (default) then calculate classification raster. Note that to calculate the classification raster the density and connectivity rasters must also be calculated (\code{calcDensity} and \code{calcConnect} should both be \code{TRUE}). If they are not then the will be forced to \code{TRUE} with a warning.
#' @param na.rm Logical, if \code{FALSE} (default) then \code{NA} cells count as part of the area potentially occupied in a window (i.e., the count in the denominator when calculating density and they are counted as potential links in the connectance calculations if a neighboring cell has a value of 1). If \code{FALSE} then areas that border \code{NA} cells could still be classified as "interior" or otherwise have less apparent fragmentation if the occupied cells are fully surrounded by other occupied cells (except for the \code{NA} cells).
#' @param ... Other arguments (not used).
#' @return A list object with three elements, each of which is a matrix: density, connectivity, and fragmentation class (if \code{calcDensity}, \code{calcConnect}, and \code{calcClass} are \code{TRUE}, respectively).
.fragWorker <- compiler::cmpfun(function(
	x,
	w,
	calcDensity = TRUE,
	calcConnect = TRUE,
	calcClass = TRUE,
	na.rm = FALSE,
	...
) {


	halfWindowSize <- (nrow(w) - 1) / 2

	# initialize
	if (calcDensity | calcClass) blockDensity <- NA * x
	if (calcConnect | calcClass) blockConnect <- NA * x
	if (calcClass) blockClass <- NA * x
	
	# by row and column
	for (countRow in 1:stopAtRow) {
		for (countCol in 1:ncol(x)) {
			
			# window limits
			topRow <- max(1, countRow - halfWindowSize)
			bottomRow <- countRow + halfWindowSize
			leftCol <- max(1, countCol - halfWindowSize)
			rightCol <- min(ncol(x), countCol + halfWindowSize)
			thisWindow <- x[topRow:bottomRow, leftCol:rightCol]
			
			# calculate density, connectivity, and class
			if (calcDensity) blockDensity[countRow, countCol] <- .fragDensity(x=thisWindow, na.rm=na.rm)
			if (calcConnect) blockConnect[countRow, countCol] <- .fragConnect(x=thisWindow, na.rm=na.rm)
			if (calcClass) blockClass[countRow, countCol] <- .fragClassify(c(blockDensity[countRow, countCol], blockConnect[countRow, countCol]))
			
		}
		
	}

	out <- list()
	if (calcDensity) out$density <- blockDensity
	if (calcConnect) out$connect <- blockConnect
	if (calcClass) out$class <- blockClass
	
	out
	
})
